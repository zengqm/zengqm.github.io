[{"title":"8.开发工具","date":"2022-08-30T23:38:55.615Z","url":"/2022/08/31/8.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/","tags":[["开发工具","/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"git简易的命令行入门教程:git init (初始化本地仓库) -&gt; git remote add origin ‘仓库地址’(链接远程仓库) -&gt; git pull origin master (下拉主分支) -&gt;git add . (添加当前目录下所有更改到暂存区) -&gt; git commit -m ‘提交日志’ （提交到本地仓库）-&gt; git push (提交到远程仓库) 推送项目的一般步骤： 图 ECharts ECharts是百度开源的纯 Javascript 图表库，目前开源可以与highcharts相匹敌的一个图表库.支持折线图（区域图）、柱状图（条状图）、散点图（气泡图）、K线图、饼图（环形图）、雷达图（填充雷达图）、和弦图、力导向布局图、地图、仪表盘、漏斗图、事件河流图等12类图表，同时提供标题，详情气泡、图例、值域、数据区域、时间轴、工具箱等7个可交互组件，支持多图表、组件的联动和混搭展现。 简单配置 1.Head内通过script引入ECharts3的js：2.为 ECharts 准备一个具备大小（宽高）的 DOM :3.初始化echarts实例var myChart = echarts.init(document.getElementById(‘main’));4.设置Option中参数，指定图表的配置项和数据5.使用setoption生成图表显示图表：myChart.setOption(option); 图表名词 line：折线图，堆积折线图，区域图，堆积区域图。bar：柱形图（纵向），堆积柱形图，条形图（横向），堆积条形图。scatter：散点图，气泡图。散点图至少需要横纵两个数据，更高维度数据加入时可以映射为颜色或大小，当映射到大小时则为气泡图k：K线图，蜡烛图。常用于展现股票交易数据。pie：饼图，圆环图。饼图支持两种（半径、面积）南丁格尔玫瑰图模式radar：雷达图，填充雷达图。高维度数据展现的常用图表。chord：和弦图。常用于展现关系数据，外层为圆环图，可体现数据占比关系，内层为各个扇形间相互连接的弦，可体现关系数据force ：力导布局图。常用于展现复杂关系网络聚类布局。map：地图。内置世界地图、中国及中国34个省市自治区地图数据、可通过标准GeoJson扩展地图类型。支持svg扩展类地图应用，如室内地图、运动场、物件构造等。gauge：仪表盘。用于展现关键指标数据，常见于BI类系统。funnel：漏斗图。用于展现数据经过筛选、过滤等流程处理后发生的数据变化，常见于BI类系统。evnetRiver：事件河流图。常用于展示具有时间属性的多个事件，以及事件随时间的演化。treemap：矩形式树状结构图，简称：矩形树图。用于展示树形数据结构，优势是能最大限度展示节点的尺寸特征。venn：韦恩图。用于展示集合以及它们的交集。 canvas简介：是H5新增的组件，就像一块幕布，一个可以使用脚本（通常为Javascript）在其中绘制图形的HTML元素，他可以用来制作各种图、表，或者一些动画，同时还可以实现动画、缩放、各种过滤和像素 转换等高级操作。 特点：canvas 元素是html5的核心功能之一，使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。每次更改某个canvas元素，此canvas元素都需要整体重绘。无法只修改某个canvas元素的某一部份。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。canvas 元素本身没有绘图能力。"},{"title":"7.性能优化与安全","date":"2022-08-25T00:32:46.155Z","url":"/2022/08/25/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/","tags":[["性能优化与安全","/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/"]],"categories":[["性能优化与安全","/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/"]],"content":"性能优化前端性能优化手段前端性能优化手段从以下几个方面入手：加载优化、执行优化、渲染优化、样式优化、脚本优化 加载优化: 减少HTTP请求、缓存资源、压缩代码、无阻塞、首屏加载、按需加载、预加载、压缩图像、减少Cookie、避免重定向、异步加载第三方资源 执行优化：CSS写在头部，JS写在尾部并异步、避免img、iframe等的src为空、尽量避免重置图像大小、图像尽量避免使用DataURL 渲染优化：设置viewport、减少DOM节点、优化动画、优化高频事件、GPU加速 样式优化：避免在HTML中书写style、避免CSS表达式、移除CSS空规则、正确使用display：display、不滥用float等 脚本优化：减少重绘和回流、缓存DOM选择与计算、缓存.length的值、尽量使用事件代理、尽量使用id选择器、touch事件优化 检测方案：使用lighthouse进行性能检测，并对lighthouse提出的建议进行优化 安全如何提高网站的安全性？前端常见安全问题的7个方面： iframe opener CSRF（跨站请求伪造） XSS（跨站脚本攻击） ClickJacking（点击劫持） HSTS（HTTP严格传输安全） CND劫持 "},{"title":"6.浏览器","date":"2022-08-16T15:40:26.438Z","url":"/2022/08/16/6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/","tags":[["浏览器","/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"]],"categories":[["浏览器","/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"]],"content":"浏览器在浏览器中输入url并回车会发生什么？1.浏览器拿到url后解析url，获取到域名2.通过域名解析服务器进行域名解析,获取到域名对应的ip地址3.接下来就是对该ip地址对应的服务器发起tcp连接4.通过三次握手，建立客户端和服务器的连接，就可以进行请求和传输数据了5.客户端拿到服务器传输过来的文件，最后由浏览器渲染到页面上。 【5.客户端拿到服务器传输过来的文件，浏览器会解析html源码创建一个dom树，浏览器解析css代码计算出最终的样式数据，形成一个css对象模型，利用dom树和css对象模型构建一个渲染树，浏览器根据渲染树把页面绘制到屏幕上。】 URL 解析DNS 查询TCP 连接处理请求接受响应渲染页面 浏览器如何渲染页面的？ HTML 被 HTML 解析器解析成 DOM 树； CSS 被 CSS 解析器解析成 CSSOM（css对象模型） 树； 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment； 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点； 将布局绘制(paint)在屏幕上，显示出整个页面。 cookie sessionStorage localStorage 区别共同点：都是保存在浏览器端、且同源的 区别： cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 web Storage（Web Storage实际上由两部分组成：sessionStorage与localStorage）支持事件通知机制，可以将数据更新的通知发送给监听者 web Storage的api接口使用更方便 cookie session cookie数据存放在客户的浏览器上，session数据放在服务器上。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie。 sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，localStorage持久存在，除非清除浏览器缓存。 如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。 session与sessionStorage事实上，两者没有任何关联。如果要强行联系，也就是两者在名称中都包含”session”这个单词。Session位于服务器端，sessionStorage位于客户端，无任何关联。（1）Session翻译成汉语具有”会话”的意思，它用于维护HTTP会话状态。（2）顾名思义，sessionStorage就是”会话期间存储”的意思。（3）sessionStorage会话周期（生命周期）会在网页选项卡或者浏览器窗口关闭时结束。 二.两者区别总结：（1）sessionStorage存储在客户端，Session在服务器端。（2）Session主要用于维护会话状态。（3）sessionStorage则是在会话期间存储相关数据。 但是Session与sessionStorage会话周期是不同的，下面简单介绍如下：（1）关闭浏览器或者服务器端Session过期，会话结束。（2）关闭当前选项卡或者浏览器窗口，sessionStorage数据被删除，也就算会话结束。特别说明：在新标签或窗口打开一个页面会初始化一个新的会话，即便链接相同也是如此。 如何写一个会过期的localStorage，说说想法如何定时删除localstorage数据localStorage 能跨域吗localstorage的限制重绘、重排区别如何避免 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等 区别：重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置） 引发重排 1 添加、删除可见的dom 2 元素的位置改变 3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性) 4 页面渲染初始化 5 浏览器窗口尺寸改变 6 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。 优化： 1 浏览器自己的优化：浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘 2 减少 reflow/repaint：（1）不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)（5）不要在布局信息改变的时候做查询（会导致渲染队列强制刷新） 事件循环Event loop主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下:主 线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查microtask队列是否为空（执行完一个 任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去 任务队列中取下一个任务执行。 详细步骤： 选择当前要执行的宏任务队列，选择一个最先进入任务队列的宏任务，如果没有宏任务可以选择，则会 跳转至microtask的执行步骤。 将事件循环的当前运行宏任务设置为已选择的宏任务。 运行宏任务。 将事件循环的当前运行任务设置为null。 将运行完的宏任务从宏任务队列中移除。 microtasks步骤：进入microtask检查点。 更新界面渲染。 返回第一步。执行进入microtask检查的的具体步骤如下: 设置进入microtask检查点的标志为true。 当事件循环的微任务队列不为空时：选择一个最先进入microtask队列的microtask；设置事件循环的当 前运行任务为已选择的microtask；运行microtask；设置事件循环的当前运行任务为null；将运行结束 的microtask从microtask队列中移除。 对于相应事件循环的每个环境设置对象（environment settings object）,通知它们哪些promise为 rejected。 清理indexedDB的事务。 设置进入microtask检查点的标志为false。需要注意的是:当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个 事件。同一次事件循环中, 微任务永远在宏任务之前执行。 浏览器垃圾回收机制网络传输跨域是什么？如何解决跨域？ 什么是同源策略？同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 协议www.nowcoder.com 域名:8080 端口号/courses 请求资源地址 同源策略限制内容有? Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了但是有三个标签是允许跨域加载资源： 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。 跨域解决方案解决方案有jsonp、cors、postMessage、websocket、Node中间件代理(两次跨域)、nginx反向代理、window.name + iframe、location.hash + iframe、document.domain + iframe，CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案，JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。日常工作中，用得比较多的跨域方案是cors和nginx反向代理 jsonp jsonp 是 “JSON with padding” 的简写,是web服务器上流行的一种变体。jsonp看起来和json一样，只是会被包在一个函数的调用里。 jsonp的原理由于浏览器的同源策略限制，不允许跨域请求；但是页面中的 script、img、iframe标签是例外，不受同源策略限制。Jsonp 就是利用 script标签跨域特性进行请求。JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好一个同名回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数。JSONP缺点：它只支持 GET请求，而不支持 POST请求等其他类型的HTTP请求。 就是利用&lt;script&gt;标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址，形如： &lt;script src=&quot;; 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如： callback(&#123;&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;&#125;) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 JSONP的例子：html代码，直接浏览器打开即可 后端使用的egg.js，核心代码只有ctx.body那一句’use strict’; 为了让后端知道我们前端的回调函数的名字，我们在script的请求中加入了call=callfun参数，后端接收到ctx.query.call， 再和’(“nihao”)’合并，最后形成了字符串 callfun(“nihao”)这一句JS代码，传到前端。这个”nihao”就是我们从后端跨域传输到前端的数据了。callfun函数处理这个数据，显示到了屏幕中。 JSONP优缺点JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性, 不安全可能会遭受XSS攻击。 JSON JSON是一种通用的数据格式 JSON语法支持3种类型的值： 简单值：字符串、数值、布尔值、null。特殊值undefined不支持 对象 数组 JSON对象有两个方法：JSON.stringify()和JSON.parse()。 JSON.stringify() 会输出不包含空格或缩进的JSON字符串，此外值为undefined的任何属性都会被跳过JSON.stringify()还有两个参数，一个是过滤器，可以是数组或函数，第二个是用于缩进结果JSON字符串的选项 如果给JSON.parse()传入的JSON字符串无效，则会导致报错JSON.parse()也可以接收额外的一个参数，这个函数会针对每一个键值对都调用一次 corsCORS 需要浏览器和后端同时支持。IE8 和9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 nginx反向代理实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 Node中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求 转发给服务器。 拿到服务器 响应 数据。 将 响应 转发给客户端。 postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递上面三个场景的跨域数据传递postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 websocketWebsocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容 本地文件socket.html向localhost:3000发生数据和接受数据 window.name + iframewindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作 location.hash + iframe实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是;而c.html是 document.domain + iframe该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。 只需要给页面添加document.domain =’test.com’表示二级域名都相同就可以实现跨域。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 有什么方法可以保持前后端实时通信实现保持前后端实时通信的方式有以下几种 WebSocket： IE10以上才支持，Chrome16, FireFox11,Safari7以及Opera12以上完全支持，移动端形势大 event-source: IE完全不支持（注意是任何版本都不支持），Edge76，Chrome6,Firefox6,Safari5和Opera以上支持， 移动端形势大好 AJAX轮询： 用于兼容低版本的浏览器 永久帧（ forever iframe）可用于兼容低版本的浏览器 flash socket 可用于兼容低版本的浏览器 这几种方式的优缺点: WebSocket优点：WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议，可从HTTP升级而来，浏览器和服务器只需要一次握手，就可以进行持续的，双向的数据传输，因此能显著节约资源和带宽缺点：1. 兼容性问题:不支持较低版本的IE浏览器（IE9及以下）2.不支持断线重连，需要手写心跳连接的逻辑 3.通信机制相对复杂 心跳机制1、心跳机制是每隔一段时间会向服务器发送一个数据包： 告诉服务器（后台）自己还活着，同时客户端（浏览器）会确认服务器端是否还活着2、如果还活着的话，就会回传一个数据包给客户端3、服务端断开连接了。客户端需要重连~ server-sent-event（event-source）优点：（1）只需一次请求，便可以stream的方式多次传送数据，节约资源和带宽 （2）相对WebSocket来说简单易用 （3）内置断线重连功能(retry)缺点： （1）是单向的，只支持服务端-&gt;客户端的数据传送，客户端到服务端的通信仍然依靠AJAX，没有”一家人整整齐齐“的感觉（2）兼容性令人担忧，IE浏览器完全不支持 AJAX轮询优点：兼容性良好，对标低版本IE缺点：请求中有大半是无用的请求，浪费资源 Flash Socket缺点：（1）浏览器开启时flash需要用户确认，（2）加载时间长，用户体验较差 （3）大多数移动端浏览器不支持flash，为重灾区优点： 兼容低版本浏览器 永久帧（ forever iframe）缺点： iframe会产生进度条一直存在的问题，用户体验差优点：兼容低版本IE浏览器 综上，综合兼容性和用户体验的问题，在项目中选用了WebSocket -&gt;server-sent-event -&gt; AJAX轮询这三种方式做从上到下的兼容 常见http status1XX系列：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。 2XX系列：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。 3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。 4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。 5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。常见有500、503状态码。 http和httpsHTTP和HTTPS的基本概念HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性 HTTP与HTTPS有什么区别？HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 http1.x 和http2.x区别http1.x 和http2.x主要有以下4个区别： HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示 HTTP2支持多路复用因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求 HTTP2头部压缩HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值 HTTP2支持服务器推送HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容 http请求方式http请求方式有以下8种，其中get和post是最常用的： OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性 HEAD向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。 GET向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form PUT向指定资源位置上传其最新内容 (数据发送到服务器以创建或更新资源，侧重于创建数据，对应insert操作) DELETE请求服务器删除Request-URL所标识的资源 TRACE回显服务器收到的请求，主要用于测试或诊断 CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 GET和POST区别 get用来获取数据，post用来提交数据 get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制 get请求的数据会附加在url之 ，以 “ ？ “分割url和传输数据，多个参数用 “&amp;”连接，而post请求会把请求的数据放在http请求体中。 get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。 get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中 http 缓存策略浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和 Last-Modified 通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。 HTTP缓存都是从第二次请求开始的：第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。 介绍下 HTTPS 中间人攻击https 协议由 http + ssl 协议构成。 中间人攻击过程如下：服务器向客户端发送公钥；攻击者截获公钥，保留在自己手上；然后攻击者自己生成一个【伪造的】公钥，发给客户端；客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器；攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥；同时生成假的加密 hash 值，发给服务器；服务器用私钥解密获得假秘钥；服务器用假秘钥加密传输信息； 防范方法：服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（现有 HTTPS 很难被劫持，除非信任了劫持者的 CA 证书）。 tcp 是如何确保有效传输的，拥塞控制 通过以下7种方式确保有效传输校验和序列号确认应答超时重传连接管理流量控制拥塞控制 拥塞控制TCP不仅可以可以控制端到端的数据传输，还可以对网络上的传输进行监控。这使得TCP非常强大智能，它会根据网络情况来调整自己的收发速度。网络顺畅时就可以发的快，拥塞时就发的相对慢一些。拥塞控制算法主要有四种：慢启动，拥塞避免，快速重传，快速恢复。 tcp/ip协议栈、网络模型TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是应用层、传输层、网络层和链路层， 链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；应用层：定义数据格式，并按照对应的格式解读数据。 OSI七层协议创建ajax过程创建XMLHttpRequest对象,也就是创建一个异步调用对象创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息设置响应HTTP请求状态变化的函数发送HTTP请求获取异步调用返回的数据使用JavaScript和DOM实现局部刷新 axios的拦截器原理及应用应用场景请求拦截器用于在接口请求之前做的处理，比如为每个请求带上相应的参数（token，时间戳等）。返回拦截器用于在接口返回之后做的处理，比如对返回的状态进行判断（token是否过期）。 拦截器的使用 在src目录下建立api文件夹 文件夹内建立axios.js文件，进行接口请求的初始化配置 在main.js中引入，并将其绑定到Vue原型上，设为全局，不用在每个页面重新引入 页面使用 xhr 的 readyStatereadyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。readyState总共有5个状态值，分别为0~4，每个值代表了不同的含义 0：初始化，XMLHttpRequest对象还没有完成初始化 1：载入，XMLHttpRequest对象开始发送请求 2：载入完成，XMLHttpRequest对象的请求发送完成 3：解析，XMLHttpRequest对象开始读取服务器的响应 4：完成，XMLHttpRequest对象读取服务器响应结束 CDNCDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。 cdn加速原理SSL 连接断开后如何恢复？hosts 文件是什么hosts 文件是个没有扩展名的系统文件，其作用就是将网址域名和其对应的 IP 地址建立一个关联“数据库”，当用户在浏览器中输入一个 url 时，系统会首先自动从 hosts 文件中寻找对应的 IP 地址。 什么是粘包问题，如何解决？默认情况下，TCP 连接会采用延迟传送算法（Nagle 算法），在数据发送之前缓存他们。如果短时间有多个数据发送，会缓冲到一起作一次发送（缓冲大小是socket.bufferSize），这样可以减少 IO 消耗提高性能。（TCP 会出现这个问题，HTTP 协议解决了这个问题） 解决方法:多次发送之前间隔一个等待时间：处理简单，但是影响传输效率；关闭 Nagle 算法：消耗资源高，整体性能下降；封包/拆包：使用一些有标识来进行封包拆包（类似 HTTP 协议头尾）；"},{"title":"5.打包","date":"2022-08-14T15:16:21.918Z","url":"/2022/08/14/5.%E6%89%93%E5%8C%85/","tags":[["打包","/tags/%E6%89%93%E5%8C%85/"]],"categories":[["打包","/categories/%E6%89%93%E5%8C%85/"]],"content":"webpack打包后文件体积过大怎么办？很多方法：异步加载模块（代码分割）；提取第三方库（使用cdn或者vender）；代码压缩；去除不必要的插件；去除devtool选项，dllplugin等等。 webpack 有哪些阶段 webpack的准备阶段 modules和chunks的生成阶段 文件生成阶段 webpack的打包流程Webpack的运行流程是一个串行的过程，从启动到结束依次执行以下流程： 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。 编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。 输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。 如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下：初始化 ↓ ←- 编译 ↑ ↓ ↑ 文件发生变化 输出–→"},{"title":"3.微信小程序合集","date":"2022-08-14T15:09:23.971Z","url":"/2022/08/14/3.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%88%E9%9B%86/","tags":[["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["微信小程序","/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"content":"微信小程序是单页应用吗?是，通过路由进行页面切换 小程序的开发，发送一个请求，怎么请求数据的 在微信小程序进行网络通信，只能和指定的域名进行通信服务器域名在：小程序后台=&gt; 开发=&gt; 开发设置 =&gt; 服务器域名中配置，配置时需注意：1）域名只支持https（request, uploadFile，downloadFile）和wss（connectSocket）协议。2）域名不能使用ip地址或localhost。3）域名必须经过ICP备案。4）服务器域名一个月内可申请5次修改。 微信小程序包括四种类型的网络请求 普通HTTPS请求(wx.request) 上传文件(wx.uploadFile) 下载文件(wx.downloadFile) WebSocket通信(wx.connectSocket) 小程序没有跨域的限制小程序中的代码并不运行在浏览器中，因此小程序开发中，不存在数据的跨域请求限制问题。 小程序中数据怎么同步渲染通过setData方法 setData工作原理：小程序分为逻辑层和渲染层，而我们每次逻辑层改变了，要借由 Native 进行。小程序的渲染层和逻辑层由两个线程管理：渲染层的界面使用了 WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端 Native 做中转，逻辑层发送网络请求也经由 Native 转发 所以我们不要重复 setdata ，以及减少数据的传输量。我们的数据传输实际是一次 Javascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程。去除不必要的事件绑定（ WXML 中的 bind 和 catch ），从而减少通信的数据量和次数。 微信小程序应用的生命周期onLaunch 小程序初始化完成时触发，全局只触发一次onShow 小程序启动，或从后台进入前台显示时触发onHide 小程序从前台进入后台时触发onError 小程序发生脚本错误或 API 调用报错时触发onPageNotFound 小程序要打开的页面不存在时触发onUnhandledRejection() 小程序有未处理的 Promise 拒绝时触发onThemeChange 系统切换主题时触发 微信小程序页面的生命周期生命周期 说明 作用onLoad | 生命周期回调—监听页面加载 | 发送请求获取数据onShow | 生命周期回调—监听页面显示 | 请求数据onReady | 生命周期回调—监听页面初次渲染完成 | 获取页面元素（少用）onHide | 生命周期回调—监听页面隐藏 | 终止任务，如定时器或者播放音乐onUnload | 生命周期回调—监听页面卸载 | 终止任务 微信小程序组件的生命周期 组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。 此时还不能调用 setData 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。 created 在组件实例刚刚被创建时执行 attached 在组件实例进入页面节点树时执行 ready 在组件在视图层布局完成后执行 moved 在组件实例被移动到节点树另一个位置时执行 detached 在组件实例被从页面节点树移除时执行 error 每当组件方法抛出错误时执行 “组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括： show 组件所在的页面被展示时执行 hide 组件所在的页面被隐藏时执行 resize 组件所在的页面尺寸变化时执行 小程序rpx单位 rpx是微信小程序独有的、解决屏幕自适应的尺寸单位 可以根据屏幕宽度进行自适应，不论大小屏幕，规定屏幕宽为750rpx 通过 rpx 设置元素和字体的大小，小程序在不同尺寸的屏幕下，可以实现自动适配1 rpx = 0.5 px = 1 物理像素 微信小程序与vue区别 生命周期不一样，微信小程序生命周期比较简单 数据绑定也不同，微信小程序数据绑定需要使用\"{{}}\"vue直接 v-bind: 就可以 3. 显示与隐藏元素: vue中，使用v-if和v-show控制元素的显示和隐藏 小程序中，使用wx-if和hidden控制元素的显示和隐藏 4. 事件处理不同: 小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件 vue，使用v-on:event绑定事件，或者使用@event绑定事件 5. 数据双向绑定也不也不一样在: vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变 微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个data中声明的变量 ## 简述微信小程序原理 1. 微信小程序采用JavaScript、WXML、WXSS三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口 2. 微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现 3. 小程序分为两个部分webview和appService。其中webview主要用来展现UI ，appService有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现 UI 的渲染、事件的处理 ## bindtap和catchtap的区别是什么 相同点：都是作为点击事件函数，就是点击时触发。 不同点：bindtap是不会阻止冒泡事件的，catchtap是阻止冒泡的 ## 小程序wxml与标准的html的异同？ 相同： 1. 都是用来描述页面的结构； 2. 都由标签、属性等构成； 不同： 1. 标签名字不一样，且小程序标签更少，单一标签更多； 2. 多了一些wx:if这样的属性以及 \"{{}}\" 这样的表达式 WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览； 组件封装不同，WXML对组件进行了重新封装， 小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。 小程序简单介绍下三种事件对象的属性列表？ 基础事件（BaseEvent） type:事件类型 timeStamp：事件生成时的时间戳 target：触发事件的组件的属性值集合 currentTarget：当前组件的一些属性集合 自定义事件（CustomEvent） detail 触摸事件（TouchEvent） touches changedTouches 小程序有哪些参数传值的方法? 给 HTML 元素添加 data-*属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或 onload的 param参数获取。但 data -名称 不能有大写字母和不可以存放对象 设置id的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值 在navigator中添加参数传值 全局变量：在globalData中增加属性，再用getApp()获取属性，修改属性值 子组件向父组件传值（triggerEvent） 父组件向子组件传值（properties） 微信小程序的优劣势？优势： 无需下载，通过搜索和扫一扫就可以打开。 良好的用户体验：打开速度快。 开发成本要比App要低。 安卓上可以添加到桌面，与原生App差不多。 为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。 劣势： 限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。 推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。 "},{"title":"4.css合集","date":"2022-08-14T14:47:23.388Z","url":"/2022/08/14/4.css%E5%90%88%E9%9B%86/","tags":[["css","/tags/css/"]],"categories":[["CSS","/categories/CSS/"]],"content":"css清除浮动清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。 1、父级div定义height； 2、父级div 也一起浮动； 3、常规的使用一个class； 4、SASS编译的时候，浮动元素的父级div定义伪类:after px和em都是长度单位，区别是：px值固定，容易计算。em值不固定，是相对单位，其相对应父级元素的字体大小会调整 描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？Reset样式的目的是清除浏览器某些默认样式，方便css书写，例如：*｛margin:0;padding:0;list-style:none;｝Normalize的理念与reset不同，它并不清除浏览器默认样式，而是尽量将所有浏览器的默认样式统一。 为什么要初始化样式？用于浏览器默认css样式的存在并且不同浏览器对相同HTML标签的默认样式不同，若不初始化会造成不同浏览器之间的显示差异。 overflow:hidden的作用（溢出隐藏、清除浮动、解决外边距塌陷、margin重叠等等）1.假设一个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0。2.如果加上overflow: hidden，将1个子元素设置高度为400px，另一个设置高度为200px，那么父元素的高度就为400px。3.通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。4.给一个元素中设置overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。5.父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷，因此，给父级元素添加overflow:hidden，就可以解决这个问题了。6.属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠，将其中一个盒子外层加一层父元素div并给父级元素添加overflow:hidden，就可以解决这个问题。 BFC（垂直排列）块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局1.内部的盒子会在垂直方向，一个接一个地放置；2.盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；3.每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；4.BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。5.计算 BFC 的高度时，浮动元素也参与计算。 BFC应用场景1.自适应两栏布局应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。2、清除内部浮动BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。（overflow: hidden;）3、 防止垂直 margin 合并同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。 CSS预处理器Sass、LESS是什么？他们是CSS预处理器。LESS结构清晰，便于扩展。可以方便地屏蔽浏览器私有语法差异。可以轻松实现多重继承。完全兼容 CSS 代码，可以方便地应用到老项目中。"},{"title":"1.js合集","date":"2022-07-31T12:08:08.256Z","url":"/2022/07/31/1.js%E5%90%88%E9%9B%86/","tags":[["js","/tags/js/"]],"categories":[["js","/categories/js/"]],"content":"js1.怎么判断一个对象是否为空前提：对象属性是可遍历 for-in 遍历，并通过 hasOwnProperty 方法确认是否存在某个 key , 这种方法不能够遍历到 enumerable 为 false 的属性 使用 Object.keys()方法， 然后判断 length 即可，keys 返回的是自身可枚举属性，因此同样的不可遍历到 enumerable 为 false 的属性 使用 JSON.Stringify() 方法将对象转为字符串，与字符串 ‘{}’ 对比，同样该方法无法获取到不可遍历属性 使用 Object.getOwnPropertyNames() 方法，获取所有属性名，这样就算是不可枚举属性依然能够获取到（推荐使用） 扩展知识： Symbol的特点： Symbol的值是唯一的，用来解决命名冲突的问题 Symbol 值不能与其他类型的值进行运算，会报错。 Symbol 定义的属性不可以使用for…in进行遍历,可以使用Reflect.ownKeys()获取所有的键名，可以通过Object.getOwnPropertySymbols获取所有的Symbol值 可以通过显示的方式转为字符串或者布尔类型，不可以转为数字类型 Symbol类型是不可枚举的，作为key值使用要加方括号[] 可枚举性（enumerable）: 用来控制所描述的属性，是否将被包括在for…in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。 for..in循环 Object.keys方法 JSON.stringify方法 Object.getOwnPropertyNames返回的是对象所有自己的属性，而Object.keys(obj)则返回的是所有可枚举属性 2.数组降维/去重/排序1. 数组降维（1）数组字符串化 （2）递归 （3）flat() es10新特性 （4）flatMap() es10新特性 2. 数组去重主要考察数组的常用方法和基本操作是否能用多种方式去重 （1）将原数组排序，在与相邻的进行比较，如果不同则存入新数组。 （2）利用数组的indexOf下标属性来查询 （3）利用forEach和数组原型对象上的includes方法 （4）利用ES6的set方法 3. 数组排序（1）冒泡排序 原理：不断比较相邻元素，如果前一个比后一个大，就元素交换，直到没有需要比较的元素。 （2）选择排序 原理：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 （3）快速排序 原理：在数组中找到基准点（比如中间位置的数字），其他数与之比较，新建两个数组，小于基准点的数存储在左边数组，大于基准点的数存储在右边数组，拼接数组，然后左边数组与右边数组继续比较存储，直到最后完成数组排序。 扩展知识： 当+号作为二元操作符时 为了方便描述，我们把+号左侧的值叫做A，右侧的叫做B： 第一步：如果A和B都是number类型，直接相加； 第二步：接下来看A和B两个操作数是否有一个是string类型，存在一个字符类型的话，那么另外一个操作数也会无条件地转换为字符串，然后连接； 第三步：既不是number,也不是string, 两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成NaN，再往下操作)，再进行加法算数操作 例如：如果是[1,2,3]+4 转换规则如下： 能转换成数字，返回之 否则调用valueOf()，如果执行结果是基本类型，返回之； 否则调用toString()，如果执行结果是基础类型，返回之； 无法得到原始值，抛异常。 参考链接： 3.深拷贝和浅拷贝浅拷贝，深拷贝只针对引用数据类型，如对象 浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝，如果对象里的属性是基本类型，拷贝的就是基本类型的值。如果对象里的属性是引用类型，拷贝的就是内存地址即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 深拷贝，开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 4. js中bind,call和apply的区别 作用： bind,call,apply都是用来改变this指向的 区别：call和apply的传参方式不同bind,call,apply的返回值不同 使用场景: call: 判断数据类型 类数组转数组 apply: 给定数组求最大值/最小值 bind: react类组件事件响应函数的绑定 5.js判断数据类型的方式有哪些 typeof优点：使用简单缺点：功能残缺，只能用来判断6种数据类型 Object.prototype.toString.call()优点：适用于判断所有数据类型缺点：使用上相对typeof而言比较麻烦 instanceofinstanceof 运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上 6.JS数据类型有哪些 基本数据类型:string,number,Boolean,null,undefined,symbol(ES6新增) 引用数据类型object(Object,Array),function 7.null和undefined区别 null 表示一个对象是“没有值”的值，也就是值为“空”；undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined；null 的类型(typeof)是object； 8.数组的常用方法(至少说出8个) 9.对象的原生方法1.Object.hasOwnProperty( ) 检查属性是否被继承2.Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型3.Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性4.Object.toLocaleString( ) 返回对象的本地字符串表示5.Object.toString( ) 定义一个对象的字符串表示6.Object.valueOf( ) 指定对象的原始值 外部JS文件出现中文字符，会出现什么问题，怎么解决？会出现乱码，加charset=”utf-8”; es61. async await async await 理解 async 是一个修饰符，async 定义的函数会默认的返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数 await 也是一个修饰符，await 关键字 只能放在 async 函数内部， await关键字的作用 就是获取 Promise中返回的内容， 获取的是Promise函数中resolve或者reject的值 async/await 的优势在于处理 then 链单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它） async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。 await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误 理解 async/await以及对Generator的优势async await 是用来解决异步的，async函数是Generator函数的语法糖使用关键字async来表示，在函数内部使用 await 来表示异步async函数返回一个 Promise 对象，可以使用then方法添加回调函数当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 async较Generator的优势：（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化 （3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用 2. Promise 什么是promise?简单来说可以把promise当作一个装着异步操作结果的容器。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。它将异步函数以同步的方式书写，也解决了回调地狱问题特点：（1）对象状态不受外界影响 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果缺点：（1），无法取消promise，一旦新建它就会立即执行，无法中途取消 （2），如果不设置回调函数，promise内部抛出的错误，不会反应到外部 （3）无法得知目前进展到哪一个阶段（刚刚开始还是即将结束）三个状态：进行中、已成功、已失败。 Promise构造函数是同步执行还是异步执行，那么 then 方法呢? promise构造函数是同步执行的，then方法是异步执行的 promise有几种状态，什么时候会进入catch? 三个状态: pending、fulfilled、reject 两个过程: padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch 下面的输出结果是多少 Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3 promise.all Promise.all的使用常见使用场景 ： 多个异步结果合并到一起Promise.all可以将多个Promise实例包装成一个新的Promise实例。用于将多个Promise实例，包装成一个新的Promise实例。 Promise.race的使用类似于Promise.all() ,区别在于 它有任意一个返回成功后，就算完成，但是 进程不会立即停止常见使用场景：把异步操作和定时器放到一起，如果定时器先触发，认为超时，告知用户 promise的then什么场景？ 是异步转化为串行执行的基本实现方式。promise的then中默认返回一个promise实例当then中没有return时返回的是undefined当then中return的对象或者基本类型等非new Promise实例时，对下一个进程then是同时执行的当then中return的是一个new Promise或者Promise.resolve()等实例时，对下一个进程then时队列顺序执行的 Promise 中reject 和 catch 处理上有什么区别 reject 是用来抛出异常，catch 是用来处理异常 reject 是 Promise 的方法，而 catch 是 Promise 实例的方法 reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch 网络异常（比如断网），会直接进入catch而不会进入then的第二个回调 3. let 和 const 和 var var 全局作用域 声明覆盖 变量提升 let 块级作用域 for循环使用let声明变量，每一轮声明的变量都是新的变量i。那变量i是怎么知道上一轮循环的值呢，这是因为 JavaScript 引擎内部会记住上一轮循环的值 同一个作用域不可使用 let 重复声明同一个变量 for循环设置循环的那一部分是一个父作用域，而循环内部是一个子作用域 不出现变量提升 const 一但声明必须初始化（赋值） 块级作用域 不可重复声明 不出现变量提升 const声明一个变量，变量指向的那个内存地址所保存的数据不得改动。也就是说声明基本类型，就等同于常量；声明引用类型，则不能改变内存地址 什么是暂时性死区？ 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区” 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 看下面代码： ​ 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。​ ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。​ 再看如下代码： ​ 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。​ 再看如下代码： ​ 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“ .​ 改成如下代码： ​ 上面代码中，如果y的默认值是x，就不会报错，因为此时x已经声明了。 4. ES6 一共有 6 种声明变量的方法 var,function,let,const,import,class 5. 箭头函数特点： 相比普通函数，箭头函数有更加简洁的语法。 箭头函数不绑定this，会捕获其所在上下文的this，作为自己的this。这句话需要注意的是，箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量。 箭头函数是匿名函数，不能作为构造函数，不可以使用new命令，否则后抛出错误。 箭头函数不绑定arguments，值由外围最近一层非箭头函数决定。下面的这个函数会报错，在浏览器环境下。 下面的箭头函数不会报错，因为arguments是外围函数的。 箭头函数可以通过拓展运算符获取传入的参数。 箭头函数没有原型对象prototype这个属性由于不可以通过new关键字调用，所以没有构建原型的需求，所以箭头函数没有prototype这个属性。 箭头函数不能用作Generator函数，不能使用yeild关键字 在以下场景中不要使用箭头函数去定义： 定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。箭头函数里不但没有 this，也没有 arguments, super Generator Genertor 函数是es6 新增的一种异步编程的解决方案，语法和传统的函数完全不同；Genertor 函数的最大的特点就是可以交出函数的执行权（即暂停执行） 对于Generator 函数也可以叫做生成器函数 形式上： Generator函数是一个普通的函数，不过相对于普通函数多出了两个特征。一是在function关键字和函数明之间多了’*’号；二是函数内部使用了* yield表达式，用于定义Generator函数中的每个状态。语法上： Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator(迭代器)对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。调用上： 普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 6. proxy7. map和set8. es6的继承和es5的继承有什么区别 ES6 中有类 class 的概念，类 class 的继承是通过 extends 来实现的。 ES5 中是通过设置构造函数的 prototype 属性，来实现继承的。 ES6 与 ES5 中的继承有 2 个区别: ES6 中子类会继承父类的属性 super() 与 A.call(this) 是不同的，在继承原生构造函数的情况下，体现得很明显，ES6 中的子类实例可以继承原生构造函数实例的内部属性，而在 ES5 中做不到。 9. Symbol，写一个应用实例，并说出它的其他应用场景js构造函数、原型、实例的关系每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例，就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。 _proto_和prototype student.proto === Student.prototype 隐式原型 显式原型 当在一个对象上寻找不到属性和方法的时候，就会到它的隐式原型上去找 student实例由Student类创建的，Student类上有个prototype的属性与student实例上的_proto_是一样的 因此student实例上的_proto_ 和 Student类上prototype 指向的是同一个对象（Student.prototype），即构造这个类的显式原型 而这个显式原型是一个对象，对象上还会有一个_proto_隐式原型 原型链 从某个对象出发，依次寻找隐式原型的指向，将形成一条链条，这条链条叫做原型链。 原型链最终的指向是Object的prototype, 而Object中的__proto__是nullconsole.log(Object.prototype.__proto__); //null 继承 原型链 盗用构造函数 组合继承 原型链式继承 寄生式继承 寄生式组合继承 内存泄漏 –内存泄漏分析工具的使用[] 内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用，于是产生溢出；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露（memory leak），是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。比如，内存泄露是指new了一块内存，但无法被释放或者被垃圾回收。new了一个对象之后，它申请占用了一块堆内存，当把这个对象指针置为null时或者离开作用域导致被销毁，那么这块内存没有人引用它了在JS里面就会被自动垃圾回收。但是如果这个对象指针没有被置为null，且代码里面没办法再获取到这个对象指针了，就会导致无法释放掉它指向的内存，也就是说发生了内存泄露。 导致内存泄漏的几种常见情况 意外形成全局变量解决方法：加上 ‘use strict’ 启用严格模式来避免这类问题, 严格模式会阻止你创建意外的全局变量. 闭包解决方法：在函数外部定义事件处理函数，解除闭包。或在闭包中，删除没用的属性以减少对内存的消耗。或在外部函数中删除对DOM的引用。 清除页面dom元素时，dom元素绑定的事件未解绑解决办法：手工移除事件。 console解决办法：及时清理console.log。 作用域链 作用域链：上下文中的代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 闭包 什么是闭包：指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。 闭包形成的原理：作用域链。内部函数的作用域链，包含了外部函数的作用域，可以访问外部函数作用域中的变量。 闭包不会造成内存泄漏，程序写错了才会造成内存泄漏。 栈不需要垃圾回收，垃圾回收是堆的问题；将函数指向null,解除对函数的引用,这样就可以释放内存了 栈–create执行上下文全局执行上下文– 变量p分配内存（Person对象），getP方法指向p（Person对象），winP指向getP()。 当create方法执行结束后create执行上下文就销毁了,也就是变量p和getP方法被销毁了。但由于winP指向getP()，而getP()指向p。因此p没有被垃圾回收，会在堆里形成一个闭包（closure）的变量，把p放进去。 闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量；避免命名冲突； this指向 如果在全局函数中调用，this在非严格模式下等于window，在严格模式下this等于undefined 如果作为某个对象的方法调用，则this等于这个对象。但匿名函数在这种情况下，this不会绑定某个对象，就意味着this在非严格模式下等于window，在严格模式下this等于undefined. 不是说内部函数的作用域链，包含了外部函数的作用域，为什么匿名函数没有使用其包含作用域的this对象呢？因为每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments，内部函数永远不可能直接访问外部函数的这两个变量，但如果把this保存到闭包可以访问的另一个变量中，则是行的通的。 在箭头函数中，this引用的是定义箭头函数的上下文 new操作符具体做了什么 创建一个空对象，并且this变量引用该对象，同时继承了该函数的原型（实例对象通过__proto__属性指向原型对象；obj.proto = Base.prototype;） 属性和方法被加入到 this 引用的对象中。 V8 栈与堆 基本类型分配到栈里，引用类型分配到堆里 栈 栈用于存放js中的基本类型和引用类型指针 栈的空间是连续的，增加删除只需要移动指针，操作速度非常快 栈的空间是有限的，当栈满了，就会抛出一个错误 栈一般是在执行函数时创建的，在函数执行完毕后，栈就会被销毁 堆 如果不需要连续空间，或是申请的内存较大，可以使用堆 堆主要用于存储JS中的引用类型 同步和异步所谓单线程，无非就是同步队列和异步队列，js代码是自上向下执行的，在主线程中立即执行的就是同步任务，比如简单的逻辑操作及函数，而异步任务不会立马执行，会挪步放到到异步队列中，比如ajax、promise、事件、计时器等等。 也就是先执行同步，主线程结束后再按照异步的顺序再次执行。 同步：阻塞的浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面 异步：非阻塞的浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新 宏任务 （macrotask）和微任务 （microtask）异步队列可以分为宏任务队列和微任务队列。在事件循环中，每进行一次循环操作称为tick，tick 的任务处理模型是比较复杂的，里边有两个词：分别是 Macro Task （宏任务）和 Micro Task（微任务）。 宏任务：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)微任务：Promise .then() .catch() .finally()、MutaionObserver、process.nextTick(Node.js 环境) 先执行微观任务，再执行宏观任务 事件循环先执行主任务，把异步任务放入循环队列当中，等待主任务执行完，再执行队列中的异步任务。异步任务先执行微观任务，再执行宏观任务。一直这样循环，反复执行，就是事件循环机制。 执行上下文 执行上下文（执行环境）分为，全局环境和函数环境、eval环境 全局执行上下文：只有一个，浏览器中的全局对象就是window对象，this指向这个全局对象 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文 Eval 函数执行上下文：指的是运行在eval函数中的代码，很少用而且不建议使用 执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶 创建阶段创建阶段即当函数被调用，但未执行任何其内部代码之前创建阶段做了三件事： 确定 this 的值，也被称为This Binding LexicalEnvironment（词法环境） 组件被创建 VariableEnvironment（变量环境） 组件被创建 执行阶段在这阶段，执行变量赋值、代码执行如果Javascript引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配undefined值回收阶段执行上下文出栈等待虚拟机回收执行上下文 经典面试题：（涉及闭包，作用域链，事件循环） 解析：执行栈– 全局执行上下文任务队列–i++,i++,i++,i++,i++–首先在执行任何代码前，先创建执行上下文，然后在全局环境执行for循环，共执行5次。因为js是单线程的，setTimeout不能马上执行，因此出现了任务队列的机制，由浏览器经行处理，得出结果后把结果放入任务队列里，等到执行栈执行结束后，才会根据时间间隔来开始执行任务队列里的结果。因此序号1的i为全局的i，循环后输出值为5。现在全局执行上下文没有需要执行的代码了，就可以执行任务队列里的任务。现在5个i++依次放入执行栈中，当前i的值为5，因此setTimeout里面的匿名函数，序号2会依次输出5，6，7，8，9。相当于闭包的原理，匿名函数可以访问到作用域链上的全局i。注意，这里的4秒指的是执行栈执行完所有任务以后，执行4秒。再执行任务队列里的任务。因此真正执行的时间会超过4秒。 如果希望setTimeout后输出i的值为0，1，2，3，4，那就使用立即执行函数 先全局执行上下文，再立即执行函数执行上下文，遇到回调函数，把这个函数交给浏览器处理，处理的结果是0，0就放在任务队列里，函数执行栈执行完成以后， 立即执行函数执行上下文 = &#123;作用域链:&#123;立即执行函数变量对象+全局对象&#125;,&#123;变量对象:x&#125;&#125;全局执行上下文 = &#123;作用域链:&#123;全局变量对象&#125;,&#123;变量对象:i&#125;&#125; 从全局弹出，回到全局执行上下文 全局执行上下文 = &#123;作用域链:&#123;全局变量对象&#125;,&#123;变量对象:i&#125;&#125; 进入第二次for循环此时i等于1，于是立即执行函数执行上下文，同时创建作用域链和变量对象，遇到回调函数，把这个函数交给浏览器处理，处理的结果是1，1就放在任务队列里，函数执行栈执行完成以后，从全局弹出，回到全局执行上下文, 以此类推，数值2，3，4依次加入到任务队列里，现在序号1输出5后，全局执行上下文没有要执行的任务了，于是从执行栈中弹出。任务队列再依次输出0，1，2，3，4 防抖节流说白了，防抖节流就是使用定时器来实现我们的目的。 防抖(debounce)：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。典型的案例：输入框搜索，输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时；思路：触发事件，清除定时器，重新设置定时器，计时结束后执行任务 节流(throttle)：规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。典型的案例：鼠标不断点击触发，规定在n秒内多次点击只生效一次；滚动屏幕请求数据；思路：触发事件，执行任务，并设置时间间隔，如果时间间隔内有触发行为就不执行任务；如果时间间隔后有触发行为，就再次执行任务和设置时间间隔 为什么要掌握防抖和节流函数节流（throttle）与函数防抖（debounce）都是可以限制函数的执行频次，根据不同的场景来对执行频率进行限制，避免了函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。 函数柯里化函数柯里化是指将使用多个参数的函数转化成一系列使用一个参数的函数的技术, 它返回一个新的函数, 这个新函数去处理剩余的参数。 柯里化通常有以下三大作用 参数复用所谓参数复用，就是利用闭包的原理，让我们前面传输过来的参数不要被释放掉。 提前确认这一特性经常是用来对浏览器的兼容性做出一些判断并初始化api，比如说我们目前用来监听事件大部分情况是使用addEventListener来实现的，但是一些较久的浏览器并不支持该方法，所以在使用之前，我们可以先做一次判断，之后便可以省略这个步骤了。 延迟运行js中的bind这个方法，用到的就是柯里化的这个特征。 面试题:实现一个add函数的方法add(1)(2)(3) = 6;add(1,2,3)(4) = 10;add(1)(2)(3)(4)(5) = 15; 事件冒泡从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。 事件捕获最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。向下传播。 事件委托/事件代理 事件委托：又名事件代理，事件委托利用事件冒泡，可以只使用一个事件处理程序，来管理一种类型的事件。 事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件是在冒泡阶段触发，事件委托就是在冒泡阶段完成。 当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。 适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress 优点：减少整个页面所需的内存，提升整体性能动态绑定，减少重复工作 局限性：focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的 要点击删除香蕉、苹果、鸭梨 点击li，因为事件冒泡，所以事件可以在父级触发，而把删除li元素的事件委托给父级，就能让父级ul代替子级li执行删除操作。 ajax AjAX（异步JavaScript加XML） 是在不重新加载整个页面的情况下，与服务器交换数据并更新部分网络页面内容 目的：为了提高用户浏览网站的体验 场景： 页面上拉加载更多数据 列表数据无刷新分页 表单项离开焦点数据验证 搜索框提示文字下拉列表 实现： XMLHttpRequest 对象 :用于在后台与服务器交换数据open(method, url, async) :规定请求的类型、URL以及是否异步处理请求send() :将请求发送到服务器readyState 属性 :保存 XMLHttpRequest 的状态，从0到4发生变化 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪onreadystatechange 事件: 每当readyState属性改变时，就会调用该函数status : 200: “OK” 404: 未找到页面 ajax请求应该放在哪个生命周期？mounted，因为js是单线程，ajax异步获取数据 axios axios 是一个基于promise的http客户端，同时支持浏览器和nodejs环境 特点： 它是一个基于promise的异步ajax请求库，支持promise所有的api node和浏览器环境都可以使用 支持请求或响应拦截器 支持请求取消 可以转换请求数据和响应数据，并对响应回来的内容自动转换成JSON类型的数据 批量发送多个请求 安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从cookie中拿到的key,根据浏览器同源策略，假的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假网站上的误导输入，从而采取正确的策略。 拦截器简介对于大多数SPA应用程序来说，通常会使用token进行用户的身份认证。这就要求在认证通过后，我们需要在每个请求上都携带认证信息。针对这个需求，为了避免为每个请求单独处理，我们可以通过封装统一的request函数来为每个请求统一添加 token 信息。但后期如果需要为某些GET请求设置缓存时间或者控制某些请求的调用频率的话，我们就需要不断修改request函数来扩展对应的功能。此时，如果在考虑对响应进行统一处理的话，我们的request函数将变得越来越庞大，也越来越难维护。 Axios提供了请求拦截器和响应拦截器来分别处理请求和响应通过service.interceptors.request和service.interceptors.response 提供的use方法就可以分别设置请求拦截器和响应拦截器 请求拦截器：该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加token字段 响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为401时，自动跳转到登录页 axios是什么，怎么使用，简述使用它完成登录的流程axios是一个基于promise的用于浏览器和nodejs的http客户端主要作用是向后端发送请求优势：支持promise提供了一些并发的方法提供了拦截器浏览器支持防止csrf（跨站请求伪造） axios fetch ajax (jquery) 区别axios、fetch是基于promise的，ajax主要还是利用callback的形式fetch 脱离了xhr 是新语法（默认不传cookie）axios、ajax 可以监听到请求的进度 正则计算机基础设计 模式设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。常用的设计模式： 单体模式：单体是一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象，如果他可以被实例化，那么他只能被实例化一次。 工厂模式:提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象） 单例模式：单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 观察者模式（发布订阅模式）： 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。 策略模式：策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体 模板模式：定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑 代理模式：代理模式的中文含义就是帮别人做事，javascript的解释为：把对一个对象的访问, 交给另一个代理对象来操作. 外观模式： 外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段 操作系统线程和进程进程间通信线程间的通信方式"},{"title":"2.vue和react的合集","date":"2022-07-18T14:42:59.658Z","url":"/2022/07/18/2.vue%E5%92%8Creact%E7%9A%84%E5%90%88%E9%9B%86/","tags":[["Vue","/tags/Vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"架构概念mvc和mvvm的区别单页应用优缺点虚拟DOM和Diff算法框架带来的好处和弊端模块化、组件化、工程化谈谈对 MVC、MVP、MVVM 模式的理解vuev-model 作用v-model本质上不过是语法糖，可以用 v-model 指令在表单及元素上创建双向数据绑定。 它会根据控件类型自动选取正确的方法来更新元素 它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理 ??? v-model会忽略所有表单元素的value、checked、selected特性的初始值,而总是将 Vue 实例的数据作为数据来源，因此我们应该通过 JavaScript 在组件的data选项中声明初始值 扩展：v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用value属性和input事件； checkbox 和 radio 使用checked属性和change事件； select 字段将value作为 prop 并将change作为事件。 v-model实现原理v-model只不过是一个语法糖而已,真正的实现靠的还是 v-bind:绑定响应式数据 触发oninput 事件并传递数据 Vue2.0 双向绑定的缺陷？Vue2.0的数据响应是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty () 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应监听回调。 vue 实例创建后，无法检测到对象属性的新增或删除，只能追踪到数据是否被修改 不能监听数组的变化 既然函数是引用类型，为什么 vue 的 data 还是可以用函数data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。 VUE 中什么是组件，为什么要封装组件？组件中 data 为什么是一个函数？为什么要封装组件？主要就是为了解耦，提高代码复用率。 什么是组件？页面上可以复用的都称之为组件 它是 HTML、CSS、JS 的聚合体。组件就相当于库，把一些能在项目里或者不同项目里可以复用的代码进行需求性的封装。 组件中的 data 为什么是一个函数？让每个返回的实例都可以维护一份被返回对象的独立的拷贝。 描述监听data变化监听对象变化：vue2.0核心api是Object.defineProperty，vue3.0是启用proxy实现响应式监听数组变化：重写数组的push.pop.shift.unshift.splice.sort.reverse方法 vue 中 $nextTick 作用与原理作用：是为了可以获取更新后的DOM 。由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 Vue.nextTick()，就是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。 原理：在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用 Promise MutationObserver setImmediate 如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。 vue的特性表单操作自定义指令计算属性过滤器侦听器生命周期 v-if v-show区别相同：都能控制元素的显示和隐藏不同：v-show是通过控制css中的display设置为none，控制隐藏v-if是动态的向DOM树内添加或者删除DOM元素而且v-if不停的销毁和创建比较消耗性能。 v-showv-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。之后切换的时候，通过display: none;样式来显示隐藏元素。可以说只是改变css的样式，几乎不会影响什么性能。v-if在首次渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。 Vue 列表为什么加 keyvue中列表循环需加:key=”唯一标识” 唯一标识且最好是静态的，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM v-for中的key的理解？需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。主要是为了高效的更新虚拟DOM。 为什么选择用vue做页面展示 MVVM 框架：Vue 正是使用了这种 MVVM 的框架形式，并且通过声明式渲染和响应式数据绑定的方式来帮助我们完全避免了对 DOM 的操作。 单页面应用程序Vue 配合生态圈中的 Vue-Router 就可以非常方便的开发复杂的单页应用 轻量化与易学习Vue 的生产版本只有 30.90KB 的大小，几乎不会对我们的网页加载速度产生影响。同时因为 Vue 只专注于视图层，单独的 Vue 就像一个库一样，所以使我们的学习成本变得非常低 渐进式与兼容性Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。Vue 只做界面，而把其他的一切都交给了它的周边生态（axios（Vue 官方推荐）、Loadsh.js、Velocity.js 等）来做处理，这就要求 Vue 必须要对其他的框架拥有最大程度的兼容性 视图组件化Vue 允许通过组件来去拼装一个页面，每个组件都是一个可复用的 Vue 实例，组件里面可以包含自己的数据，视图和代码逻辑。方便复用 虚拟 DOM（Virtual DOM）Vue 之所以可以完全避免对 DOM 的操作，就是因为 Vue 采用了虚拟 DOM 的方式，不但避免了我们对 DOM 的复杂操作，并且大大的加快了我们应用的运行速度。 社区支持得益于 Vue 的本土化身份（Vue 的作者为国人尤雨溪），再加上 Vue 本身的强大，所以涌现出了特别多的国内社区，这种情况在其他的框架身上是没有出现过的，这使得我们在学习或者使用 Vue 的时候，可以获得更多的帮助 未来的 Vue 走向Vue 是由国人尤雨溪在 Google 工作的时候，为了方便自己的工作而开发出来的一个库，而在 Vue 被使用的过程中，突然发现越来越多的人喜欢上了它。所以尤雨溪就进入了一个边工作、边维护的状态，在这种情况下 Vue 依然迅速的发展。 双向数据绑定原理采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。 既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?前置知识: 依赖收集、虚拟 DOM、响应式系统 现代前端框架有两种方式侦测变化，一种是 pull ，一种是 push pull: 其代表为React，我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。 push: Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一但数据发生变化,响应式系统就会立刻得知。因此Vue是一开始就知道是「在哪发生变化了」，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher一但我们的绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。 简单聊聊 new Vue 以后发生的事情new Vue会调用 Vue 原型链上的_init方法对 Vue 实例进行初始化；首先是initLifecycle初始化生命周期，对 Vue 实例内部的一些属性（如 children、parent、isMounted）进行初始化；initEvents，初始化当前实例上的一些自定义事件（Vue.$on）；initRender，解析slots绑定在 Vue 实例上，绑定createElement方法在实例上；完成对生命周期、自定义事件等一系列属性的初始化后，触发生命周期钩子beforeCreate；initInjections，在初始化data和props之前完成依赖注入（类似于 React.Context）；initState，完成对data和props的初始化，同时对属性完成数据劫持内部，启用监听者对数据进行监听（更改）；initProvide，对依赖注入进行解析；完成对数据（state 状态）的初始化后，触发生命周期钩子created；进入挂载阶段，将 vue 模板语法通过vue-loader解析成虚拟 DOM 树，虚拟 DOM 树与数据完成双向绑定，触发生命周期钩子beforeMount；将解析好的虚拟 DOM 树通过 vue 渲染成真实 DOM，触发生命周期钩子mounted； 为什么做首屏优化？首屏时间的快与慢，直接影响到了用户对网站的认知度。所以首屏时间的长短对于用户的滞留时间的长短、用户转化率都尤为重要。 vue首屏白屏如何解决？ 路由懒加载 vue-cli开启打包压缩 和后台配合 gzip访问 进行cdn加速 开启vue服务渲染模式 用webpack的externals属性把不需要打包的库文件分离出去，减少打包后文件的大小 在生产环境中删除掉不必要的console.log 开启nginx的gzip ,在nginx.conf配置文件中配置 添加loading效果，给用户一种进度感受 vue单页面和传统的多页面区别？单页面应用（SPA）通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。 多页面（MPA）指一个应用中有多个页面，页面跳转时是整页刷新 单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。 单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。 $root、$refs、$parent的使用？ $root可以用来获取vue的根实例，比如在简单的项目中将公共数据放再vue根实例上(可以理解为一个全局 store ),因此可以代替vuex实现状态管理； $refs在子组件上使用ref特性后，this.属性可以直接访问该子组件。可以代替事件$emit 和 $on的作用。使用方式是通过ref特性为这个子组件赋予一个ID的引用，再通过 this.$refs.testId获取指定元素。注意：refs只会在组件渲染完成之后生效，并且他们不是响应式的。应该避免在模板和计算属性中访问refs。 $parent$parent属性可以用来从一个子组件访问父组件的实例，可以替代将数据以 prop 的方式传入子组件的方式；当变更父级组件的数据的时候，容易造成调试和理解难度增加； 路由跳转和location.href的区别？ 使用location.href=’/url’来跳转，简单方便，但是刷新了页面； 使用路由方式跳转，无刷新页面，静态跳转 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？ css的预编译。 使用步骤：先装css-loader、node-loader、sass-loader等加载器模块在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss在同一个文件，配置一个module属性然后在组件的style标签加上lang属性 ，例如：lang=”scss” 特性:可以用变量，例如（$变量名称=值）；可以用混合器，例如（）可以嵌套 delete与vue.delete区别? delte会删除数组的值，但是它依然会在内存中占位置 而vue.delete会删除数组在内存中的占位 computed和watch的区别 computed计算结果并返回，只有当被计算的属性发生改变时才会触发（即：计算属性的结果会被缓存，除非依赖的响应属性变化才会重新及孙） watch监听某一个值，当被监听的值发生变化时，执行相关操作。 与computed的区别是，watch更加适用于监听某一个值得变化，并做对应操作，比如请求后端接口等。而computed适用于计算已有的值并返回结果。 监听简单数据类型： Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题？你能说说如下代码的实现原理么？ Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题 Vue使用了Object.defineProperty实现双向数据绑定 在初始化实例时对属性执行 getter/setter 转化 属性必须在data对象上存在才能让Vue将它转换为响应式的（这也就造成了Vue无法检测到对象属性的添加或删除）所以Vue提供了Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value) 框架本身是如何实现的呢?Vue 源码位置：vue/src/core/instance/index.js 我们阅读以上源码可知，vm.$set 的实现原理是： 如果目标是数组，直接使用数组的 splice 方法触发相应式； 如果目标是对象，会先判读属性是否存在、对象是否是响应式， 最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理 导航守卫导航守卫主要用来通过跳转或取消的方式守卫导航。简单的说，导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。 扩展： 路由守卫的具体方法：(1)全局前置守卫你可以使用 router.beforeEach 注册一个全局前置守卫 当一个导航开始时，全局前置守卫按照注册顺序调用。守卫是异步链式调用的，导航在最后的一层当中。 每个守卫方法接收三个参数（往后的守卫都大同小异）： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法将控制权交给下一个守卫，执行效果依赖 next 方法的参数。next(): 进入下一个守卫。如果全部守卫执行完了。则导航的状态就是 confirmed (确认的)。next(false): 中断当前的导航（把小明腿打断了）。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器 后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航（小明被打断腿并且送回家了）。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递router.onError() 注册过的回调。 注意：永远不要使用两次next，这会产生一些误会。 全局解析守卫这和 router.beforeEach 类似，但他总是被放在最后一个执行。 全局后置钩子导航已经确认了的，小明已经到了外婆家了，你打断他的腿他也是在外婆家了。 路由独享的守卫在路由内写的守卫 组件内的守卫 5.1 beforeRouteEnter5.2 beforeRouteUpdate (2.2 新增)5.3 beforeRouteLeave 导航全过程导航被触发。在准备离开的组件里调用 beforeRouteLeave 守卫。调用全局的 beforeEach 守卫。在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。（如果你的组件是重用的）在路由配置里调用 beforeEnter。解析即将抵达的组件。在即将抵达的组件里调用 beforeRouteEnter。调用全局的 beforeResolve 守卫 (2.5+)。导航被确认。调用全局的 afterEach 钩子。触发 DOM 更新。用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 路由守卫进行判断登录在vue项目中，切换路由时肯定会碰到需要登录的路由，其原理就是在切换路径之前进行判断，你不可能进入页面再去判断有无登录重新定向到login，那样的话会导致页面已经渲染以及它的各种请求已经发出。 如需要登录的路由可在main.js中统一处理（全局前置守卫）我们可以在入口文件man.js里面进行配置，使用router.beforeEach方法，不懂得可以打印to，from的参数就ok，requireAuth可以随意换名的，只要man.js里面跟配置路由的routes里面的字段保持一致： vue-router 实现懒加载懒加载：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 实现：结合 Vue 的异步组件和 Webpack 的代码分割功能，可以实现路由组件的懒加载首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)： 在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)： 结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。 在路由配置中什么都不需要改变，只需要像往常一样使用Foo： js是如何监听HistoryRouter的变化的HashRouter 和 HistoryRouter的区别和原理Vue router 原理, 哪个模式不会请求服务器组件通信的方式组件通信的方式的方式有以下8种方法：父与子 props和$emit这是最最常用的父子组件通信方式，父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的 parent和children ref 也可以访问组件实例； v-model父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值 boradcast和dispatchvue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。 比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和on和emit的封装，但在一些基础组件中却很实用 兄弟组件 中央事件总线上面方式都是处理的父子组件之间的数据传递，那如果两个组件不是父子关系呢?也就是兄弟组件如何通信?这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.on监听触发的事件。 跨级通信 attrs和listeners第一种方式处理父子组件之间的数据传输有一个问题：如果多层嵌套，父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢?如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C;要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。从Vue 2.4开始，提供了listeners来解决这个问题，能够让组件A之间传递消息给组件C。 provide和inject父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。 多个组件 vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的 vue组件间传值， attrs和listeners 了解过吗？attrs和listeners的作用：解决多层嵌套情况下，父组件A下面有子组件B，组件B下面有组件C，组件A传递数据给组件B的问题，这个方法是在Vue 2.4提出的。 listeners解决问题的过程：C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props(除了B组件中props声明的) 组建传值，事件总线是怎么用的中央事件总线主要用来解决兄弟组件通信的问题。实现方式：新建一个Vue事件bus对象，然后通过bus.on监听触发的事件。 vue生命周期中异步加载在mouted还是create里实现最常用的是在 created 钩子函数中调用异步请求 解析：一般来说，可以在，created，mounted中都可以发送数据请求，但是，大部分时候，会在created发送请求。Created的使用场景：如果页面首次渲染的就来自后端数据。因为，此时data已经挂载到vue实例了。在 created（如果希望首次选的数据来自于后端，就在此处发请求）（只发了异步请求，渲染是在后端响应之后才进行的）、beforeMount、mounted（在mounted中发请求会进行二次渲染） 这三个钩子函数中进行调用。因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是最常用的是在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有两个优点：第一点：能更快获取到服务端数据，减少页面 loading 时间；第二点：放在 created 中有助于一致性，因为ssr 不支持 beforeMount 、mounted 钩子函数。 vue keep-alivekeep-alive：keep-alive可以实现组件缓存，是Vue.js的一个内置组件。 作用：它能够把不活动的组件实例保存在内存中，而不是直接将其销毁它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中 使用方式：常用的两个属性include/exclude，允许组件有条件的进行缓存。两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。keep-alive的中还运用了LRU(Least Recently Used)算法。 原理：Vue 的缓存机制并不是直接存储 DOM 结构，而是将 DOM 节点抽象成了一个个 VNode节点，所以，keep-alive的缓存也是基于VNode节点的而不是直接存储DOM结构。其实就是将需要缓存的VNode节点保存在this.cache中／在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。 所有组件都实现缓存： 实现指定组件缓存就需要用到include和exclude这两个属性了 include所绑定的Home组件就实现缓存了 其他的组件就没实现缓存 而Home对应的是Home组件中的name名字 而exclude属性与include的功能恰恰相反 exclude绑定的组件中name名不实现缓存，没绑定的实现缓存 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用&lt;keep-alive&gt;&lt;/keep-alive&gt;进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染 谈谈对vue生命周期的理解beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。updated发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 dom diff算法和虚拟DOM算法实现 1 步骤一：用JS对象模拟DOM树2 步骤二：比较两棵虚拟DOM树的差异3 步骤三：把差异应用到真正的DOM树上 说说你对MVVM的理解用户操作view层，view数据变化会同步到Model，Model数据变化会立即反应到view中。viewModel通过双向数据绑定把view层和Model层连接了起来 单向绑定的优点是可以带来单向数据流，这样的好处是流动方向可以跟踪，流动单一，程序的调试会变得相对容易 谈谈你对组件的理解可组合，可复用，可维护，可测试 在 Vue 中，子组件为何不可以修改父组件传递的 Prop为了保证数据的单向流动，防止从子组件意外改变父级组件的状态，便于对数据进行追踪，避免数据混乱。 Vue 的响应式原理中 Object.defineProperty 有什么缺陷？Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 双向绑定和 vuex 是否冲突 会在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。当需要在组件中使用vuex中的state时，有2种解决方案：1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值2、使用带有setter的双向绑定计算属性 Vue 的父组件和子组件生命周期钩子执行顺序是什么 加载渲染过程父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 父组件更新过程父beforeUpdate-&gt;父updated 销毁过程父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？不需要，直接监听就行，如果循环的是组件，而且组件没有支持该事件，需要加native修饰符(一般UI库会对这个做支持，兼听不到事件的时候才需要加) vue本身不做事件代理（react将所有事件都委托到document上，然后进行派发） 普通html元素和在组件上挂了.native修饰符的事件。最终EventTarget.addEventListener()挂载事件 组件上的，vue组件实例上的自定义事件（不包括.native）会调用原型上的$on,$emit（包括一些其他api $off,$once等等） vue自身没有做事件代理，如果需要，则直接代理到父节点 事件代理作用主要是 2 个将事件处理程序代理到父节点，减少内存占用率动态生成子节点时能自动绑定事件处理程序到父节点 vue 渲染大量数据时应该怎么优化？ 增加加载动画提升用户体验 异步渲染组件 使用分页 谈一谈 nextTick 的原理为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。 Vue 中的 computed 和 watch 的区别在哪里computed：计算属性 一个数据受多个数据影响watch：监听数据的变化 一个数据影响多个数据 v-if、v-show、v-html 的原理是什么，它是如何封装的？ v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染； v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值 如何优化自己的代码？代码重用避免全局变量（命名空间，封闭空间，模块化mvc..）拆分函数避免函数过于臃肿注释 简述readyonly与disabled的区别Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去 vue3Vue3.0 实现数据双向绑定的方法vue3.0 实现数据双向绑定是通过ProxyProxy是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。 扩展：使用proxy实现，双向数据绑定，相比2.0的Object.defineProperty ()优势： 可以劫持整个对象，并返回一个新对象 有13种劫持操作 ？？ vuexVuex是什么，每个属性是干嘛的，如何使用 Vuex是专门为Vuejs应用程序设计的状态管理工具。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 Vuex的属性包含以下6个：1）statestate是存储的单一状态，是存储的基本数据。2）Gettersgetters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。3）Mutationsmutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）4）Actionsactions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）5）ModuleModule是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。6）辅助函数Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store。 vuex的工作流程就是：（1）通过dispatch去提交一个actions，（2）actions接收到这个事件之后，在actions中可以执行一些异步|同步操作，根据不同的情况去分发给不同的mutations，（3）actions通过commit去触发mutations，（4）mutations去更新state数据，state更新之后，就会通知vue进行渲染。（5）也可以使用$store.commit方法去触发mutations，更改state存储的状态。 Vuex的使用方法？ Vuex实现原理具体见 通过以下三个方面来阐述vuex的实现原理： store是怎么注册的? mutation，commit 是怎么实现的? 辅助函数是怎么实现的? mutation和action有什么区别？action中处理异步，mutation不可以mutation做原子操作，action可以整合多个mutationaction 提交的是 mutation，而不是直接变更状态。 ElementUI修改ElementUI 样式的几种方式?修改ElementUI 样式的方式有四种： 新建全局样式表新建 global.css 文件，并在 main.js 中引入。 global.css 文件一般都放在 src-&gt;assets 静态资源文件夹下的 style 文件夹下，在 main.js 的引用写法如下： 在 global.css 文件中写的样式，无论在哪一个 vue 单页面都会覆盖 ElementUI 默认的样式。 在当前-vue-单页面中添加一个新的style标签在当前的vue单页面的style标签后，添加一对新的style标签，新的style标签中不要添加scoped属性。在有写scoped的style标签中书写的样式不会覆盖 ElementUI 默认的样式。 使用/deep/深度修改标签样式(vue样式穿透)找到需要修改的 ElementUI 标签的类名，然后在类名前加上/deep/，可以强制修改默认样式。这种方式可以直接用到有scoped属性的 style 标签中。 通过内联样式 或者 绑定类样式覆盖默认样式通过内联样式 style ，绑定类样式的方式，可以在某些标签中可以直接覆盖默认样式，不是很通用。具体实例如下：默认按钮 export default { data() { return { selfstyle: { color: \"white\", marginTop: \"10px\", width: \"100px\", backgroundColor: \"cadetblue\" } }; } } 通过绑定修改样式方式修改：默认按钮 export default { data() { return { selfbutton: \"self-button\" }; } } .self-button { color: white; margin-top: 10px; width: 100px; background-Color: cadetblue; } 扩展：第一种全局引入css文件的方式，适合于对elementUI整体的修改，比如整体配色的修改；第二种添加一个style标签的形式，也能够实现修改默认样式的效果，但实际上因为是修改了全局的样式，因此 在不同的vue组件中修改同一个样式有可能会有冲突。第三种方式通过 /deep/ 的方式可以很方便的在vue组件中修改默认样式，也不会于其他页面有冲突。第四种方式局限性比较大，可以使用，但不推荐使用。 elementui 有什么用?Element-UI：是一套采用 Vue 2.0 作为基础框架实现的组件库，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的组件库，提供了配套设计资源，帮助网站快速成型 reactreact组件间的数据传递 兄弟组件不能直接相互传送数据，此时可以将数据挂载在父组件中，由两个组件共享 子组件向父组件通讯，可以通过父组件定义事件（回调函数），子组件调用该函数，通过实参的形式来改变父组件的数据来通信 非父子组件间的通信：可以使用全局事件来实现组件间的沟通，React中可以引入eventProxy模块，利用eventProxy.trigger()方法发布消息，eventProxy.on()方法监听并接收消息。 组件间层级太深，可以使用上下文方式，让子组件直接访问祖先的数据或函数，通过this.context.xx vue和reactreact和vue的区别 相同：都有虚拟dom，都支持服务器渲染，都可以使用props对组件进行父子通信，组件化开发，数据驱动视图 不同：React严格上只针对MVC的view层，Vue则是MVVM模式虚拟dom不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。React每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制。vue是双向数据绑定，react则是单向数据流 "},{"title":"vue","date":"2022-07-18T14:09:42.585Z","url":"/2022/07/18/vue/","tags":[["Vue","/tags/Vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"vue1.v-show和v-if区别 2.为何v-for要用key 3.描述vue组件声明周期 4.vue组件如何通信 5.描述组件渲染和更新的过程 6.双向数据绑定v-model的实现原理 7.对mvvm的理解 8.computed有何特性 9.VUE 中如何封装组件？什么组件，为什么要封装组件？组件中 data 为什么是一个函数？ 10.ajax请求应该放在哪个生命周期？ 11.如何将组件所有props传递给子组件？ 12.如何自定实现v-model? 13.多个组件有相同逻辑，如何抽离？ 14.何时要使用异步组件？ 15.何时使用keep-alive？ 16.何时使用beforeDestroy？ 17.什么是作用域插槽？ 18.vuex中action和mutation有何区别？ 19.vue-router常用路由模式 20.如何配置vue-router异步加载 21.请用vnode描述一个dom结构 22.监听data变化的核心api是什么？ 23.vue如何监听数据变化？ 24.请描述响应式原理？ 25.简述diff算法过程（了解） 26.vue为何是异步渲染，$nextTick何用？ 27.vue常见性能优化方式？ 28、VUEX 是什么？怎么使用？那种场合能用？ 29、vue 的指令用法 30、vue.js的两个核心是什么？ 31.vue中子组件调用父组件的方法? 32.vue中父组件调用子组件的方法? 33.vue页面级组件之间传值? 34.说说vue的动态组件。 35.$route和 $router的区别是什么？ 36.为什么使用vue开发？ 37.vue和react 有什么区别？ 38.Vuex和Redux的区别 39.说一下vue的生命周期/钩子函数都有哪些？ 40.双向数据绑定的理解？ 41.vue组件中data为什么函数返回一个对象 42.vue中哪些数组方法可以直接对数组修改实现视图更新 43.有哪些指令？v-if和v-show区别，v-if、v-for优先级 44.v-for中key 的作用 45.使用过keep-alive吗 46.computed、watch（自动监听、深度监听）、methods区别 47.vue中对象更改检测的注意事项 48.什么是$nextTick？ 49.ref 的作用？ 50.什么是vuex？vuex核心包括？怎么修改state中数据？在项目中哪里使用？ 51.路由模式有哪些？路由传参有哪些方式？路由守卫有哪些，有没有在项目中使用过？ 52.vue过滤器 53.有没有封装过组件，封装过什么，怎么封装？注意点或有哪些原则？ 注意点或有哪些原则？ 54.移动端项目如何适配（rem）？ 55.有没有使用过axios、axios拦截器，跨域如何解决？ 56.vue项目做过哪些优化 57.为什么做首屏优化？ 58.如何做首屏优化？ 59.vue常用的修饰符 60.v-on可以监听多个方法吗？ 61.vue中编写可复用的组件(深度好题，掌握思路,不用背诵) 1.在 Vue 组件中，状态称为 props，事件称为 events，片段称为 slots。 2.组件间通信 3.命名 4.业务数据无关 5.组件职责 6.命名空间 7.上下文无关 8.数据扁平化 9.使用自定义事件实现数据的双向绑定 v-model 10.使用自定义 watch 优化 DOM 操作 11.项目骨架 62.vue如何监听键盘事件中的按键？（大声朗读2遍） 63.解决非工程化项目初始化页面闪动问题(好题,理解) 64.v-for产生的列表，实现active的切换 tab切换 65.v-model语法糖使用 66.十个常用的自定义过滤器 67.vue等单页面应用及其优缺点 68.vue的计算属性，特性，应用 69.vue父组件向子组件通过props传递数据 70.vue-cli生产环境使用全局常量(了解) 71.vue弹窗后如何禁止滚动条滚动？（了解） 72.vue-cli中自定义指令的使用 73.父组件异步获取动态数据传递给子组件(好题) 74.父组件给子组件props传参，子组件接收的6种方法 75.Vuex页面刷新数据丢失咋解决这个bug 76.按钮权限怎么做？ 77.完整的说下从url解析到显示页面过程，结合项目中说 78.vue声明周期都在哪些场景中使用？ 3.html、css1.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？H5新特性有： 处理h5新标签的浏览器兼容性问题： 2.行内元素和块级元素的区别？什么是重绘和回流？两者区别？ 回流： 重绘： 3.CSS 选择符有哪些？优先级算法如何计算？ 优先级算法如何计算？ 4.CSS3有哪些新特性？ 5.解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？ 6.简述flex布局 7.css 隐藏元素有哪几种方法？position定位有哪些？css隐藏元素方法 position定位有哪些？ 8.BFC（Block Formatting Context） 是什么？应用？ 9.解释下浮动和它的遗留问题？清除浮动的方法（4种）浮动为该元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 浮动引起的问题： 清除浮动的方法： 10.哪些外边距不重叠的情况？防止外边距重叠的方法？外边距不重叠的情况： 防止外边距重叠的方法： 11.如何让一个盒子水平垂直居中 12.左右固定中间自适应 三栏布局（圣杯、双飞翼、弹性盒子…）圣杯布局： 缺点：当面板的main部分比两边的子面板宽度小的时候，布局就会乱掉。 双飞翼布局: flex布局 13.静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）静态布局（Static Layout） 自适应布局（Adaptive Layout） 流式布局（Liquid Layout） 响应式布局（Responsive Layout） 弹性布局（rem/em布局） 1.静态布局： 布局特点：宽高固定 2.自适应布局： 布局特点：不同分辨率下，页面元素位置变化，大小不变 **实现方法:**针对不同分辨率创建对应的样式表，使用 @media 媒体查询给不同尺寸的设备切换不同的样式 缺点：IE8及以下不支持媒体查询；只能兼容主流分辨率 3.流式布局（百分比布局）: 布局特点：不同的分辨率下显示相同的排版；高度固定，宽度自适应 **实现方法:**网页中主要区域的尺寸使用百分比； 缺点：大屏幕上元素被拉长，但是文字，高度还是固定大小，不协调 经典流式布局：左侧固定，右侧自适应；两侧固定，中间自适应 4.弹性布局（rem/em布局）： 布局特点：页面元素宽度，高度，字体大小会跟着屏幕大小缩放 **实现方法:**使用js监听当前屏幕大小，设置html的字体大小 缺点：IE678不兼容；需要计算； 5.响应式布局：一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本 布局特点：每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变，响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表等等）都能显示出令人满意的效果 实现方法：媒体查询(css3中的Media Query)+流式布局 媒介查询：通过不同的媒介类型和条件定义样式表规则，媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。 优点：适应pc和移动端 1.面对不同分辨率设备灵活性强 2.能够快捷解决多设备显示适应问题 缺点：要匹配足够多的屏幕大小，工作量大，设计也需要多个版本 1.会出现隐藏无用的元素 2.加载时间加长 14.less、sass、 stylus分别都有哪些优缺点？15.说一下在IE（IE6）中常见的几个兼容性问题一、头文档所引起的怪异盒模型问题 产生条件：不设置文档声明，页面就会陷入怪异盒模型解析模式 解决方法：加入文档声明 二、IE6下双边距BUG 产生条件：在IE6下，块元素有浮动有横向的margin，横向的margin值会被放大成两倍浮动方向与margin方向一致时，该方向会出现双倍边距 解决方法：display:inline 三、图片间隙问题 产生条件：给父容器设置宽度后，图片会在原来基础上把父元素撑大3-5px 解决方法：1.给父元素添加font-size：0；2.给图片添加display：block； 四、li的间距问题 产生条件：IE6浏览器 li标签设置宽高，且li里面的元素发生了浮动解决方法：1. li不设置宽高； 五、块状元素默认高度问题 产生条件：部分块状元素会有默认高度（一般为16px-18px之间）解决方法： 1.给元素添加overflow:hidden; 2.font-size：0； 六、表单行高不一致 产生条件：一行中的文本输入框和按钮不在同一高度解决办法：给表单元素添加float：left；并去掉默认边框border：0； 七、图片元素img下高度超出,出现多余空白 解决方法：1.设置img为display:block; 2.父级设置overflow:hidden; 八、左浮元素margin-bottom失效 解决方法：1.显示设置高度 2.父标签设置_padding-bottom代替子标签的margin-bottom 3.再放个标签让父标签浮动，子标签margin- bottom，即(margin-bottom与float不同时 作用于一个标签) 九、position下的left，bottom错位 解决方法：为父级(relative层)设置宽高或添加*zoom:1 十、子级中有设置position，则父级overflow失效 解决方法：为父级设置position:relative 十一、块元素中有文字及右浮动的行元素，行元素换行 解决方法：将行元素置于块元素内的文字前 十二、透明rgba与opacity 产生条件：IE6不支持此两种透明的设置方法 解决方法：使用IE6当中的滤镜filter替代掉，如：opacity:0.6;filter:alpha(opacity=60)异盒模型问题 16.清空数组的方法1.splice 2.length赋值为0 3.赋值为[] 4.js1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么? 2.你简述盒模型 3.CSS3的新特性 4.CSS选择器及其优先级 5.说说BFC 6.说说定位相关的属性 7.谈谈flex布局 8.你怎么清楚浮动 9.两边宽度固定中间自适应的三栏布局(默写题,手写笔试题)圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。圣杯布局双飞翼布局 10.浏览器渲染机制 11.重绘和回流的区别 12.JS数据类型 13.JS判断数据类型的方法 14.null和undefined区别 15.JS作用域的理解 16.call,apply和bind区别的页面在哪些流览器测 17.深拷贝和浅拷贝 18.谈谈防抖和节流 19.谈谈cookie,sessionStorage和localStorage 20.0.1+0.2!=0.3怎么处理 21.数组的常用方法(至少说出8个) 22.new一个对象的过程中发生了什么吗? 23.JS实现继承(至少会一种) 24.get和post区别 请求方式 GET POST 参数位置 参数拼接到url的后面 参数在请求体中 参数大小 受限于浏览器url大小，一般不超过32K 1G 服务器数据接收 接收1次 根据数据大小，可分多次接收 适用场景 从服务器端获取数据 向服务器提交数据 安全性 参数携带在url中，安全性低 相对于GET请求，安全性更高 25.JSONP原理 26.缓存的理解 27.XSS和CSRF区别 28.HTTP与HTTPS的区别 29.HTTP状态码 30.事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件 31.Js事件循环机制 32.面向对象、原型、原型链、继承 33.什么是闭包，使用场景及优缺点？ 34.this指向 35.箭头函数和普通函数的区别？ 36.什么是promise? 37.什么是ajax？ 5.兼容性1、IE8 下面的 png 图片无法正常显示？原因：打开调试面板，你会发现 IE8 浏览器把 PNG 格式的 img 解析成了 span 标签，导致图无法显示。解决方案：在样式里面对 span 设置宽高和 display:inline-block;即可。 2、rgba 不支持 IE8？解决方案:可以用 opacityopacity:0.7;/FF chrome safari opera/filter:alpha(opacity:70);/用了 ie 滤镜,可以兼容 ie/但是,需要注意的是,opacity 会影响里面元素的透明度 3、Css3 的新属性？当一些 CSS3 样式语法还存在波动时，它们提供针对浏览器的前缀。现在主要流行的浏览器内核主要有：Trident 内核：主要代表为 IE 浏览器Gecko 内核：主要代表为 Firefox FFPresto 内核：主要代表为 OperaWebkit 内核：产要代表为 Chrome 和 Safari而这些不同内核的浏览器，CSS3 属性（部分需要添加前缀的属性）对应需要添加不同的前缀，也将其称之为浏览器的私有前缀，添加上私有前缀之后的 CSS3 属性可以说是对应浏览器的私有属性：Trident 内核：前缀为-msGecko 内核：前缀为-mozPresto 内核：前缀为-oWebkit 内核：前缀为-webkit 4、document.form.item 问题问题：代码中存在 document.formName.item(“itemName”) 这样的语句，不能在 FF 下运行解决方法：改用 document.formName.elements[“elementName”] 5、集合类对象问题问题：代码中许多集合类对象取用时使用()，IE 能接受，FF 不能解决方法：改用 [] 作为下标运算，例：document.getElementsByName(“inputName”)(1) 改 为document.getElementsByName(“inputName”)[1] 6、window.event || event问题：使用 window.event 无法在 FF 上运行解决方法：FF 的 event 只能在事件发生的现场使用，此问题暂无法解决。可以把 event 传到函数里变通解决：onMouseMove = “functionName(event)”function functionName (e) {e = e || window.event;……} 7、HTML 对象的 id 作为对象名的问题问题：在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用，在 FF 中不能解决方法：使用对象变量时全部用标准的 getElementById(“idName”) 通过id取dom节点 8、用 idName 字符串取得对象的问题问题：在 IE 中，利用 eval_r(“idName”) 可以取得 id 为 idName 的 HTML 对象，在 FF 中不能解决方法：用 getElementById(“idName”) 代替 eval_r(“idName”) 9、变量名与某 HTML 对象 id 相同的问题问题：在 FF 中，因为对象 id 不作为 HTML 对象的名称，所以可以使用与 HTML 对象 id 相同的变量名，IE 中不能解决方法：在声明变量时，一律加上 var ，以避免歧义，这样在 IE 中亦可正常运行最好不要取与 HTML 对象 id 相同的变量名，以减少错误 10、event.x 与 event.y 问题问题：在 IE 中，event 对象有 x,y 属性，FF 中没有解决方法：在 FF 中，与 event.x 等效的是 event.pageX ，但 event.pageX IE 中没有故采用 event.clientX 代替 event.x ，在 IE 中也有这个变量event.clientX 与 event.pageX 有微妙的差别，就是滚动条要完全一样，可以这样：mX = event.x ? event.x : event.pageX;然后用 mX 代替 event.x 11、 取得元素的属性在 FF 中，自己定义的属性必须 getAttribute() 取得 在 FF 中没有 parentElement，parement.children 而用 parentNode，parentNode.childNodes 问题：childNodes 的下标的含义在 IE 和 FF 中不同，FF 的 childNodes 中会插入空白文本节点解决方法：可以通过 node.getElementsByTagName_r() 来回避这个问题问题：当 html 中节点缺失时，IE 和 FF 对 parentNode 的解释不同，例如：​ FF 中 input.parentNode 的值为 form，而 IE 中 input.parentNode 的值为空节点​问题：FF 中节点自己没有 removeNode 方法解决方法： 必须使用如下方法 node.parentNode.removeChild(node) 12、const 问题问题：在 IE 中不能使用 const 关键字解决方法：以 var 代替 13、body 对象FF 的 body 在 body 标签没有被浏览器完全读入之前就存在，而 IE 则必须在 body 完全被读入之后才存在这会产生在 IE 下，文档没有载入完时，在 body 上 appendChild 会出现空白页面的问题解决方法：一切在 body 上插入节点的动作，全部在 onload 后进行 14、url encoding问题：一般 FF 无法识别 js 中的&amp; 解决方法：在 js 中如果书写 url 就直接写&amp;不要写&amp; 15、nodeName 和 tagName 问题问题：在 FF 中，所有节点均有 nodeName 值，但 textNode 没有 tagName 值，在 IE 中，nodeName的使用有问题解决方法：使用 tagName，但应检测其是否为空 16.元素属性IE下input.type 属性为只读，但是FF下可以修改 document.getElementsByName() 和document.all[name] 的问题 问题：在IE中，getElementsByName()、document.all[name] 均不能用来取得div 元素是否还有其它不能取的元素还不知道（这个问题还有争议，还在研究中） 17.调用子框架或者其它框架中的元素的问题在IE中，可以用如下方法来取得子元素中的值 document.getElementByIdx_x(“frameName”).(document.)elementName window.frames[“frameName”].elementName 在FF中则需要改成如下形式来执行，与IE兼容：window.frames[“frameName”].contentWindow.document.elementName window.frames[“frameName”].document.elementName 18.对象宽高赋值问题问题：FireFox中类似obj.style.height = imgObj.height 的语句无效 解决方法：统一使用obj.style.height = imgObj.height + “px”; 19.innerText的问题问题：innerText 在IE中能正常工作，但是innerText 在FireFox中却不行 解决方法：在非IE浏览器中使用textContent代替innerText 20.event.srcElement和event.toElement问题问题：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性 解决方法：var source = e.target || e.srcElement;var target = e.relatedTarget || e.toElement; 21.禁止选取网页内容问题：FF需要用CSS禁止，IE用JS禁止 解决方法：IE: obj.onselectstart = function() {return false;} ​ FF: -moz-user-select:none; 22.捕获事件问题：火狐(FF)没有setCapture(),releaseCapture()方法 解决方法： IE：obj.setCapture(); obj.releaseCapture() FF： window.captureEvents(Event.MouseMove|Event.MoouseUp); window.releaseEvents(Event.MouseMove|Event.MouseUp) 移动端常见的兼容性问题1.html5调用安卓或者ios的拨号功能html5提供了自动调用拨号的标签，只要在a标签的href中添加tel：就可以了。如下：&lt; a href=” “&gt;400-810-6999 转 1034&lt;/ a&gt;拨打手机如下：&lt; a href=”tel:15677776767”&gt;点击拨打 15677776767 &lt;/ a&gt; 2.上下拉动滚动条时卡顿、慢 body { -webkit-overflow-scrolling: touch; overflow-scrolling: touch; } Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling。 3.圆角bug某些 Android 手机圆角失效background-clip: padding-box; 4.ios 设置input 按钮样式会被默认样式覆盖解决方式如下： input,textarea {border: 0;-webkit-appearance: none;}设置默认样式为 none 5.IOS键盘字母输入，默认首字母大写解决方案，设置如下属性 &lt;input type=”text”autocapitalize=”off”/&gt; 6.h5底部输入框被键盘遮挡问题h5页面有个问题是，当输入框在最底部，点击软键盘后输入框会被遮挡。可采用如下方式解决 var oHeight = $(document).height(); //浏览器当前的高度 ​ $(window).resize(function(){ ​ if($(document).height() &lt; oHeight){ ​ $(“#footer”).css(“position”,”static”); ​ }else{ ​ $(“#footer”).css(“position”,”absolute”); ​ } ​ }); 7.IOS移动端click事件300ms的延迟响应解决方案： 1、fastclick可以解决在手机上点击事件的300ms延迟 2、zepto的touch模块，tap事件也是为了解决在click的延迟问题 3、触摸事件的响应顺序为touchstart –&gt; touchmove –&gt; touchend –&gt; click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题 8.在ios和andriod中,audio元素和video元素在无法自动播放应对方案：触屏即播$(‘html’).one(‘touchstart’,function(){audio.play()}) 9.CSS动画页面闪白,动画卡顿解决方法: 1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 2.开启硬件加速 -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); 10.fixed定位缺陷1、ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 2、android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 3、ios4下不支持position:fixed解决方案：可用iScroll插件解决这个问题 6.webpack1、如何减少 Webpack 打包时间 2、如何减少 Webpack 打包后的文件体积 3、什么是模块化？ 4、为什么出现模块化？ 5、构建的作用及常见功能是什么？ 6、你了解的构建工具有哪些，各自有什么优缺点？ 7、简单介绍一下webpack 8、Loader机制的作用是什么？ 9、css-loader与style-loader的作用 10、配置 Loader 时需要注意的地方？ 11、Plugin（插件）的作用是什么？ 12、ExtractTextPlugin插件的作用 13、DevServer开发工具 14、实时预览 15、什么是模块热替换？ 16、什么是Source Map 及其使用 17、Webpack的几个核心概念 18、Webpack简单工作原理 19.什么是loader ? 什么是Plugin ? loader和plugin有什么区别？ 20.webpack中都有哪些插件，这些插件有什么作用？ 21.如何利用webpack优化前端性能? 7.vue3.01.Vue3.0和Vue2.0的区别 2.Vue3.0都有哪些重要新特性？ 3.Vue3.0 对比Vue2.0的优势在哪？ 4.Vue3.0和React 16.X都有哪些区别和相似处？ 5.Vue3.0是如何实现代码逻辑复用的？ 8.移动端、小程序1. 移动端兼容适配 2.flexible如何实现自动判断dpr 3.为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？ 4.如何处理异形屏iphone X 5.移动端首屏优化 6.PWA全称Progressive Web App，即渐进式WEB应用 7.离线包方案 8. 自适应和响应式布局的区别 9.简单描述下微信小程序的相关文件类型？ 10.你是怎么封装微信小程序的数据请求的？ 11.小程序有哪些参数传值的方法？ 12.简述微信小程序原理？ 13.小程序的双向绑定和 vue 哪里不一样？ 14.webview 中的页面怎么跳回小程序中？ 15.小程序关联微信公众号如何确定用户的唯一性？ 16.小程序如何实现下拉刷新？ 17.小程序调用后台接口遇到哪些问题？ 18.小程序的 wxss 和 css 有哪些不一样的地方？ 19.分析下微信小程序的优劣势 9.es61、var、let、const之间的区别 var声明变量可以重复声明，而let不可以重复声明var是不受限于块级的，而let是受限于块级var会与window相映射（会挂一个属性），而let不与window相映射var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错const声明之后必须赋值，否则会报错const定义不可变的量，改变了就会报错const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错 2、使用箭头函数应注意什么？ （1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）（2）不能够使用arguments对象（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数 3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能 基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)就能解决类模板字符串的功能 4、介绍下 Set、Map的区别？ 应用场景Set用于数据重组，Map用于数据储存 Set： （1）成员不能重复（2）只有键值没有键名，类似数组（3）可以遍历，方法有add, delete,hasMap:（1）本质上是健值对的集合，类似集合（2）可以遍历，可以跟各种数据格式转换 5、ECMAScript 6 怎么写 class ，为何会出现 class？ ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法 6、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？ promise构造函数是同步执行的，then方法是异步执行的 7、setTimeout、Promise、Async/Await 的区别 事件循环中分为宏任务队列和微任务队列其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行 8、promise有几种状态，什么时候会进入catch？ 三个状态：pending、fulfilled、reject两个过程：padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch 9、下面的输出结果是多少 Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3 10、使用结构赋值，实现两个变量的值的交换 11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key 12、下面Set结构，打印出的size值是多少 答案：2两个数组[1]并不是同一个值，它们分别定义的数组，在内存中分别对应着不同的存储地址，因此并不是相同的值都能存储到Set结构中，所以size为2 13、Promise 中reject 和 catch 处理上有什么区别 reject 是用来抛出异常，catch 是用来处理异常reject 是 Promise 的方法，而 catch 是 Promise 实例的方法reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch网络异常（比如断网），会直接进入catch而不会进入then的第二个回调 14、如何使用Set去重 15、将下面for循环改成for of形式 答案： 16、理解 async/await以及对Generator的优势 async await 是用来解决异步的，async函数是Generator函数的语法糖使用关键字async来表示，在函数内部使用 await 来表示异步async函数返回一个 Promise 对象，可以使用then方法添加回调函数当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句async较Generator的优势：（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化 （3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用 17、forEach、for in、for of三者区别 forEach更多的用来遍历数组for in 一般常用来遍历对象或jsonfor of数组对象都可以遍历，遍历对象需要通过和Object.keys()for in循环出的是key，for of循环出的是value 28、说一下es6的导入导出模块 导入通过import关键字 导出通过export关键字 10.React react组件如何通信 父组件向子组件通信：使用 props 子组件向父组件通信：使用 props 回调 跨级组件间通信：使用 context 对象 非嵌套组件间通信：使用事件订阅 jsx本质是什么 jsx其实是语法糖，开发环境会将jsx编译成js代码，jsx的写法大大降低了学习成本和编码工作量 context是什么，有何用途 在react应用中，数据总是通过 props 自上而下进行传递。 这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题）。Context 可以共享对于一个组件树而言是“全局”的数据。这样就不必显式地通过组件树的逐层传递 props shouldComponentUpdate用途 询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 描述redux单项数据流 当一个页面渲染完后，UI出现，用户其实是触发了UI上的一些Action，Action将会被送到Reducers方法里，Reducers将会更新Store，数据就是React开发中的State，State其实是Store的一部分，所有的视图层的东西，也就是组件，其实是由State来唯一决定的。 ![img](D:\\课件\\课件p4\\day06 React\\img\\Center) setState是同步还是异步？ 既可能是同步的,也可能是异步的。 准确地说,在React内部机制能检测到的地方, setState就是异步的;在React检测不到的地方,例如setInterval,setTimeout里,setState就是同步更新的 什么是纯函数 一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。 react组件生命周期 // 实例化组件，也就是构造DOM元素constructor();// 当DOM元素载入之前调用componentWillMount();// 将构造的元素插入到指定的页面元素中render();// 当DOM元素载入页面之后调用componentDidMount();// 当从页面中卸载时会调用componentWillUnmount() react发起ajax应该在哪个生命周期 componentDidMount生命周期中调用 渲染列表，为何使用key？ key是给每一个虚拟dom的唯一id,可以依靠key,更准确, 更快的拿到旧虚拟dom中对应的新虚拟dom节点。 函数组件和class组件区别 函数组件纯函数，输入props，输出jsx 函数组件没有实例，没有生命周期，没有state 函数组件不能扩展其他方法 class创建的组件,有自己的私有数据(this.state)和生命周期 什么是受控组件 简单的说就是input里面的值受state值控制 何时使用异步组件 加载大组件 路由异步加载 资源异步加载 多个组件有公共逻辑，如何抽离 HOC，高阶组件 高阶组件不是一种功能，而是一种模式 Render Props核心思想：通过一个函数将class组件的state作为props传递给纯函数组件 redux如何进行异步请求 ajax请求 react-router如何配置懒加载 lazyload-loader方式 import Shop from &#39;lazy!./src/view/Shop&#39;; 箭头函数方式 component:resolve =&gt; require([&#39;@/component/Login&#39;],resolve)· PureComponent和Component有何区别 React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。 在PureComponent中，如果包含比较复杂的数据结构，可能会因深层的数据不一致而产生错误的否定判断，导致界面得不到更新。 react事件和dom事件区别 react性能优化 使用shouldComponentUpdate来优化组件 shouldComponentUpdate的实现方式，shouldComponentUpdate在比对prop和上次渲染所用的prop方面，依然用的是尽量简单的方法，做的是所谓的“浅层比较”。简单来说就是用JavaScript的===操作符来比较，如果prop的类型是字符串或者数字，只要值相同，那么“浅层比较”也会认为二者相同，但是，如果prop的类型是复杂对象，那么“浅层比较”的方式只看这两个prop是不是同一个对象的引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是两个不同的prop。 react和vue区别 11.实战1.promise封装ajax？ 2.移动端1像素问题如何解决 3.如何解决vuex刷新之后数据重置的问题 4.git常用命令 5.promise原理 6.router和localhost.href和go(-1)区别 7.css动态效果 8.vue框架搭建（中高级） 9.前端上百万的点，加载会崩溃，有啥性能优化方案？(大数据项目) 10,说下云计算？ 11.ajax和axios的区别 12.在vue中如何监听对象obj.a 13.在vue中如何给属性动态添加新属性 14.简单描述nextTick原理及作用 15.如何解决弹性盒布局div会随内部表格被撑开的问题。 16.兼容pc端移动端响应式页面，pc端左右轮播，移动端上下轮播实现 17.$set作用和$delete作用 18.路由懒加载 19.数组新特性，map和foreach区别 20.promise.all 21.async await 22.图片懒加载的实现原理和方式 23.js和css实现动态效果方式 24.路由传参的方式，query和params各个方式之间的优劣 25.根据接口中的数据进行区别挂载，怎么实现 26.路由跳转之前的钩子函数中是否可以过去例如this这样的值 27.28.父子组件传值，父组件中值改变，子组建如何监听值 29.宏任务和微任务 30.es class类和继承 31.深拷贝实现 32。写出几种会话跟踪用户的方法 33.http的method有几种以及各自含义 34.http请求报文中user-agent和referer含义 35.http底层的原理 36.整个工作流程从产品经理接项目开始描述一遍 37.vuex里module具体有什么作用 38.路由hstory，会报404错误怎样解决 39.当表单提交文件的时候，用什么属性和参数 40.promise并行和串行执行 41.说说数据结构和算法 42.怎样实现数据加密。 43.降幂怎么做 44.less和cass区别 45.去重方法 46.异步请求放在created和munted中有啥区别？ 47.promise的then什么场景？ 48.什么是cookie，什么是持久cookie？ 49.es7新增技术点 50.ajax发送请求之后，中间想停止如何停止 51.axios发送请求之后，中间想停止如何停止 52.vue设计模式 53.vue数据跟新之后，视图没有更新，怎样解决 渐进增强和优雅降级的区别 "},{"title":"vue3","date":"2022-07-14T15:52:06.369Z","url":"/2022/07/14/VUE3/","tags":[["Vue","/tags/Vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Vue3 新特性: 数据响应式，ES6的proxy代替了ES5的object.defineProperty -解决了对象数组更新后的检测，优化了监听响应式的性能-原监听对象属性的变化，需要一个个对属性递归监听，现在是proxy将整个对象劫持2. 虚拟dom新算法，更小，更快3. 提供了组合式api，能更好的逻辑复用4. template 模板可以有多个根元素5. 源码用 typescript 重写, 有更好的类型推导(类型检测更为严格, 更稳定) 生命周期 组合式api的生命周期钩子比配置项的生命周期钩子优先执行 setup 优先于beforeCreate执行 组合式API： setup 函数特点 组合式api的使用，需要配置一个setup 函数 从生命周期来看，setup在beforeCreate之前执行 在template 模板中使用的数据和函数，需要在setup返回 setup 中不能使用 this, this 指向 undefined setup里的数据是普通数据，不是响应式的 注意，从 setup 返回的 refs 在模板中访问时是被自动浅解包的，因此不应在模板中使用 .value reactive 将复杂类型的数据转换成响应式数据（ 返回该对象的响应式代理 ），通常用来定义响应式对象数据 reactive 函数需要按需导入才能使用 ref 基本类型，包裹一层对象, 转换成响应式。 在 setup 函数中, 通过 value 属性,才可以访问到 ref 对象的值 在模板中, ref 可以直接使用, 不需要额外的 .value ref 函数也支持传入复杂类型，传入复杂类型，也会做响应式处理 基本类型的数据，响应式使用object.defineProperty()的get和set完成 对象类型的数据，内部求助reactive，基于proxy实现代理 toRef 使用 toRef函数 , 将 reactive 函数的响应式对象中的指定属性转换为响应式数据 语法 : toRef(参数1, 参数2)参数1 : 目标对象,必须是 响应式对象参数2 : 指定变成响应式对象的属性 toRefs 注意:对一个响应数据, 进行 解构 或者 展开, 会丢失他的响应式特性（原因 : vue3 底层是对 对象 进行监听劫持） 作用:对一个 响应式对象 的所有内部属性, 都做响应式处理, 保证展开或者解构出的数据也是响应式的( 一般配合 reactive 使用) computed函数 计算属性 watch函数 -监视属性,既要指明监视的属性，也要指明监视的回调 watchEffect函数 -监视属性,不指明监视的属性，监视的回调中用到哪个属性，那就监视哪个属性 shallowReactive与shallowRef shallowReactive 只处理对象最外层属性（第一层数据）的响应式（浅响应式） shallowRef 只处理基本类型的响应式，不进行对象的响应式处理 使用场景？ 如果有一个对象的数据，结构比较深，但变化时只是外层属性变化，就选择用 shallowReactive 如果有一个对象的数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换，就选择使用 shallowRef readonly与shallowReadonly readonly 让一个响应式数据变为只读（深只读） shallowReadonly 让一个响应式数据变为只读（浅只读） toRaw与markRaw toRaw 将一个reative生成的响应式对象转化为普通对象 场景：用于读取一个响应式对象对应的普通对象，这个普通对象的修改不会引起页面的更新 markRaw 标记一个对象，使其永远不能成为响应式对象 场景：有些值不应该设置为响应式，如复杂的第三方库，当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能 customRef 创建一个自定义的ref 场景：实现防抖效果 provide与inject 实现祖与后代组件间的通信 父组件使用provide传递数据，子组件使用inject接收数据 祖父 儿子 孙子 其他 响应式数据的判断 isRef 检查一个值是否是ref对象 isReactive 检查一个对象是否是由reactive创建的响应式代理 isReadonly 检查一个对象是否是只读 Teleport 能够将组件html结构移动到指定位置 Suspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验 父 -子 自定义hook hook\\usePoint.js test.vue Fragment vue3中组件可以没有根标签，内部会将多个标签包含在一个Fragment的虚拟元素中 好处: 减少标签层级，减小内存占用 见文档  "},{"title":"尚硅谷react课程笔记","date":"2022-03-19T15:00:15.182Z","url":"/2022/03/19/%E5%B0%9A%E7%A1%85%E8%B0%B7react%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","tags":[["react","/tags/react/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"005 jsx语法规则 009 函数式组件 010 类"},{"title":"随手记","date":"2021-11-01T14:07:34.312Z","url":"/2021/11/01/%E9%9A%8F%E6%89%8B%E8%AE%B0/","tags":[["零零散散","/tags/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/"]],"categories":[["零散知识","/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/"]],"content":" 将json对象转化为json字符串，再判断该字符串是否为”{}” css cursor中鼠标悬停禁用样式 vue el-input 标签只能输入纯数字链接： 可以通过给input 添加onkeyup事件来实现当输入值的键盘抬起时触发这个事件。this.value表示此输入框的值，/\\D/g为正则表达式，用来匹配所有非数字字符；此句功能为：将输入值为非数字的字符替换为空；当输入值的键盘抬起时触发这个事件。this.value表示此输入框的值，/\\D/g为正则表达式，用来匹配所有非数字字符；"},{"title":"正则测试网址","date":"2021-11-01T14:04:11.007Z","url":"/2021/11/01/%E6%AD%A3%E5%88%99/","tags":[["正则校验","/tags/%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C/"]],"categories":[["正则","/categories/%E6%AD%A3%E5%88%99/"]],"content":"正则  0-12的数： ^([0-9]|1[0-2])$ 2~4个汉字：@”^[\\u4E00-\\u9FA5]{2,4}$” 0-12的数字及中文零到十二： ^([0-9]|1[0-2]|[零一二三四五六七八九十]|十[一二])$"},{"title":"js 手机号码和电话号码（座机号）正则校验","date":"2021-11-01T14:01:52.049Z","url":"/2021/11/01/js%20%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E5%92%8C%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%EF%BC%88%E5%BA%A7%E6%9C%BA%E5%8F%B7%EF%BC%89%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C/","tags":[["正则校验","/tags/%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C/"]],"categories":[["正则","/categories/%E6%AD%A3%E5%88%99/"]],"content":"区号+座机号码+分机号码：regExp=”^(0[0-9]{2,3}-)?([2-9][0-9]{6,7})+(-[0-9]{1,6})?$”简化regExp=”^(0\\d{2,3}-)?([2-9]\\d{6,7})+(-\\d{1,6})?$” 手机号：regExp=”^(((+86)|(+86-))|((86)|(86-))|((0086)|(0086-)))?1[3|5|7|8]\\d{9}$”简化regExp=”^((+86|+86-)|(86|86-)|(0086|0086-))?1[3|5|7|8]\\d{9}$”————————————————版权声明：本文为CSDN博主「刺心疯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"浏览器的工作原理","date":"2021-10-18T09:23:50.929Z","url":"/2021/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E6%96%B0%E5%BC%8F%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%95%E5%90%8E%E6%8F%AD%E7%A7%98/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"浏览器的工作原理：新式网络浏览器幕后揭秘  浏览器的主要组件为 (1.1)： 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 多进程浏览器结构 浏览器进程（控制chrome浏览器除标签外的用户界面，包括地址栏、书签、后退、前进按钮以及负责与浏览器的其他进程协调工作）、缓存进程、网络进程（负责发起网络请求）、渲染器进程（控制显示tab标签内的所有内容，每个标签页创建一个渲染进程）、GPU进程（复制整个浏览器界面的渲染）、插件进程（负责控制网站使用的所有插件，如flash） 渲染器进程接收到数据也就是HTML，渲染器主进程解析HTML，构造DOM数据结构。HTML首先经过tokeniser标记化，通过词法分析将输入的HTML内容，解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构造中会创建document对象，然后以document为根节点的DOM树，不断进行修改，将其中添加各种元素（如图片、css、js等）图片和css需要通过网络下载或缓存加载，这些资源不会阻塞html的解析，因为它们不会影响DOM的生成。但解析过程遇到script标签时就会停止HTML解析流程，转而去加载解析并执行js 如果js代码里调用了document.write来修改HTML，那么之前的HTML解析就没有意义了，因此要把script标签放在合适的位置或者使用async或defer属性来异步加载js Layout Tree是根据DOM和计算好的样式来生成，Layout Tree是和展示在页面上的节点是对应的，因此display:none在DOM上，而不在Layout Tree上，div::before{content:”objtube”}伪类中添加的content元素在Layout Tree上而不在在DOM树里 总体流程：浏览器进程中的网络线程请求获取到HTML数据后，通过IPC将数据传给渲染进程的主线程，主线程将HTML解析构造成DOM树，然后进行往事计算，根据DOM树和样式生成Layout Tree，通过遍历Layout Tree生成绘制顺序表（paint），接着遍历Layout Tree生成Layer Tree,然后主线程将Layer Tree和绘制顺序信息一起传给合成器线程，合成器线程按规则进行分图层，并把图层分为更小的图块（tiles）传给栅格进程进行栅格化，栅格化完成合成器线程会获得栅格线程传过来的draw quads图块信息，根据这些信息合成器线上合成一个合成器帧，然后将该合成器帧通过IPC传回给浏览器进程，浏览器进程在传到GPU进行渲染，最后展示在屏幕上。 重排和重绘、js都会占用主进程。反复重排和重绘可能会导致掉帧，因为有可能js执行阻塞了主线程。 优化：requestAnimationFrame()会在每一帧被调用；Transform动画直接运行在合成器线程上。 "},{"title":"egg","date":"2021-09-20T14:35:44.871Z","url":"/2021/09/20/egg.js/","tags":[["egg","/tags/egg/"]],"categories":[["Node","/categories/Node/"]],"content":"egg.js参考教程视频  egg.js 的特性:1、提供基于 Egg 定制上层框架的能力2、高度可扩展的插件机制3、内置多进程管理 4、基于 Koa 开发，性能优异5、框架稳定，测试覆盖率高6、渐进式开发 创建egg的环境npm i egg-init -g(只需要安装一次) 创建项目终端cd 到项目要放置的路径中（注意目录最好是不要用中文 不要有空格） ​ egg-init 项目名称 –type=simple 创建项目 如： egg-init eggdemo01 --type=simple cd到项目目录下，cd eggdemo01 安装依赖 npm install， 安装成功后直接执行npm run dev， 默认端口是7001，然后在浏览器中打开localhost:7001 如果出现如下图所示就说明初始化项目成功了，如果安装依赖失败那么可以强制npm清理一下缓存npm cache clean –force然后再安装，如果还是报错可以翻墙到外面再试下。 vs插件市场eggjs 路由路由不需要引入，可直接使用 egg是一个MVC的框架： view 视图 模板 页面的展示 Controller 控制器 负责处理一些业务逻辑 model 模型（service） 和数据库打交道（查询数据库、操作数据库数据 请求数据）(复杂的业务逻辑 以及数据操作) 结构： Controller 控制器 service 服务 extend 扩展 middleware 中间件 获取get传值 动态路由1、在controller的news.js中添加 2、在view的router.js添加 加载模板引擎 视图（view）egg-view-ejs安装 使用 在view中新建news.html 在controller的news.js中添加 运行即可 在页面添加数据 1、在controller的news.js中添加 2、news.html 解决数据冗余若home.js和news.js有相同数据，则将数据封装到service /service/news.js home.js和news.js使用该数据 调用this.service.news.getNewsList(); 控制器（api）的访问 在config.default.js中配置api 可以在service或控制器中直接使用 服务继承Service为了方便egg在this上面绑定以下的方法 this.ctx: 当前请求的上下文 Context 对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。 this.app: 当前应用 Application 对象的实例，通过它我们可以拿到框架提供的全局对象和方法。 this.service：应用定义的 Service，通过它我们可以访问到其他业务层，等价于 this.ctx.service 。 this.config：应用运行时的配置项。 this.logger：logger 对象，上面有四个方法（debug，info，warn，error），分别代表打印四个不同级别的日志，使用方法和效果与 context logger 中介绍的一样，但是通过这个 logger 对象记录的日志，在日志前面会加上打印该日志的文件路径，以便快速定位日志打印位置。 服务创建user服务返回一个对象 可在控制器被调用 也可在另一个服务被调用 在HTML渲染 总结 控制器可以调用服务，一个服务可被多个控制器调用，一个控制器可以调用不同的服务 服务之间可相互调用 注意：服务不能调用控制器，控制器也不能相互调用 //服务的命名规则Service文件必须放在app/service 目录，可以支持多级目录， 访问的时侯可以通过目录名级联访问。app/service/biz/user.js =&gt; ctx. service .biz .userapp/ service/sync_ user.js =&gt; ctx. service . syncUserapp/ service/HackerNews.js =&gt; ctx . service . hackerNews 爬取api接口数据 控制器访问服务 在服务中通过抓取接口返回数据 使用render将获取的数据显示到界面 配置路由router.js 控制器news.js 服务news.js news.html newscontent.html extend Application Context Request Response Helper 新建extend/helper.js 扩展里面引入第三方模块 1、安装 2、使用 在news.html中调用helper.formatTime() 注意：10位的时间戳在JavaScript中被认为是无效的时间戳 ，解决方法将param*1000 调用extend里面扩展的helper方法： 1、在extend/helper.js中增加getHelperData方法 在app/controller/home.js中调用 中间件中间件：匹配路由前、匹配路由完成做的一系列操作。 1、新建middleware/printdate.js中间件 2、在config.default.js中配置中间件 3、给printdate中间件传入的参数 4、打印options 利用中间件屏蔽id： 要屏蔽的id：1、从数据库获取 新建middleware/forbidip.js中间件 配置中间件 2、从参数传入 在config.default.js中配置要屏蔽的id middleware/forbidip.js中间件 post提交数据新建home.html 增加控制器 home.js 增加路由 router.ja Cookie●cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一一个域名的时候共享数据。心●HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另-一个页面，服务器无法认识到这是同一个浏览器在访问同一一个网站。每-一次的访问，都是没有任何关系的。 cookie: 1.可以实现同一个浏览器访问同一个域的时候不同页面之间的数据共享 2、实现数据的持久化(关子浏览器重新打开以后数据还存在) 需求：同一个浏览器访问同一个域，news页面能访问到主页面的值1、在home.js下设置一个值 2、在news.js获取到这个值 3、再将这个值渲染到页面上 4、在news.html页面中打印这个值 需求:实现数据的持久化默认情况:cookies当浏览器关闭以后就销毁了 注意:默认情况下面egg.js里面的cookie没法设置中文 其他参数： 获取时解密 设置中文cookie (encrypt :true) 清除cookie方法1： 方法2： session基于Cookie session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。 当浏览器访问服务器并发送第一次请求时 ,服务器端会创建一个session对象,生成一个类似于key,value的键值对，然后将key(cookie)返回到浏览器(客户)端,浏览器下次再访问时,携带key(cookie) ,找到对应的session(value)。 1、设置 2、获取 设置session的过期时间5s 基于cookie 不建议使用 在config.default.js中的配置 请求1、get请求 2、post请求 3、接口返回值 "},{"title":"flex弹性布局","date":"2021-09-20T14:35:29.900Z","url":"/2021/09/20/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/","tags":[["flex弹性布局","/tags/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"flex弹性布局 采用 Flex 布局的元素，称为 Flex 容器，简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目，简称”项目”。 以下6个属性设置在容器上 flex-direction 决定项目的排列方向 flex-warp 如果一条轴线排不下，如何换行 flex-flow flex-direction和flex-warp的简写形式 justify-content 定义项目在主轴上的对齐方式 align-items 定义项目在交叉轴上的对齐方式 align-content 定义项目在多根轴线上的对齐方式（多行的交叉轴对齐） 以下6个属性设置在项目上 order 定义项目的排列顺序（数值越小，排列越靠前，默认为0） flex-grow 定义项目的放大比例 flex-shrink 定义项目的缩小比例（负值对该属性无效） flex-basis 定义了在分配多余空间之前，项目占据的主轴空间 （它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。） flex 是flex-grow，flex-shrink，flex-basis的简写，后两个属性可选 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 （表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。） （完） 参考地址"},{"title":"HTTP响应状态码参考","date":"2021-09-20T14:34:49.510Z","url":"/2021/09/20/HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%82%E8%80%83/","tags":[["HTTP","/tags/HTTP/"]],"categories":[["HTTP","/categories/HTTP/"]],"content":"HTTP响应状态码参考1xx:信息 2xx:成功 3xx:重定向 4xx:客户端错误 5xx:服务器错误"},{"title":"Node.js","date":"2021-09-20T14:34:19.363Z","url":"/2021/09/20/nodejs/","tags":[["node","/tags/node/"]],"categories":[["Node","/categories/Node/"]],"content":"nodejs nodejs不是语言不是框架是js的一个运行时环境可以解析执行js代码 运行的时候指的是指令加载到内存并由CPU执行的时候 浏览器中的jsEcmaScript(基本语法、if、var、function、Object、Array)BOMDOM node.js中的jsEcmaScript语法 服务端不操作页面（没有BOM、DOM） 核心模块 第三方模块 用户自定义模块 nodejs特性：事件驱动、非阻塞IO模型 核心模块在node这个js执行环境中为js提供了一些服务器级别的操作API，这些API大多数都包装到核心模块中。 例如文件操作的fs核心模块，http服务构建的http模块，path路径操作模块，os操作系统信息模块。。。 所有核心模块在使用的时候都必须手动的先使用require方法来加载，才可以使用。 核心模块本质也是文件。 fs文件操作模块 http网络服务构建模块 服务器用来提供对数据的服务 1、发送请求 2、接收请求 3、处理请求 4、发送响应 解决文字乱码问题服务器默认发送的数据，是utf8编码的内容但浏览器不知道中文操作系统默认是gbk在http协议中，Content-Type是用来告知对方数据内容是什么类型，plain是普通文本不同的资源对应的Content-Type不同一般只为字符数据才指定编码，图片不需要 os操作系统信息模块path路径处理模块 url：统一资源定位符一个url对应一个资源 根据不同的请求路径发送不同的响应结果 响应内容只能是二进制数或字符串 用户自定义模块语法1、导出成员2、外部引入使用 案例模板a.js b.js 导出exports require方法的两个作用：1、用来加载模块并执行里面的代码2、拿到被加载文件模块导出的接口对象 每个文件模块中都提供一个对象：exportsexports默认是一个空对象 在node中，没有全局作用域，只有模块文件作用域，默认文件中所有成员只在当前文件模块有效 导出多个成员（必须在对象中）： 导出单个成员（拿到的就是：函数、字符串） 以下情况会覆盖 也可以这样来导出多个成员 exports原理解析exports是module.exports的一个引用： 当exports重新赋值时，则不等于module.exports里的值，且module.exports里的值不会被改变。 require方法加载规则模块查找机制 优先从缓存中加载 核心模块 路径形式的文件模块 第三方模块 路径形式的模块 ./当前目录 ../上级目录 核心模块 本质也是文件。 核心模块文件已经编译到二进制文件中，只需按照名字加载就可以了 第三方模块 凡是第三方模块都必须通过npm来下载 使用时可以通过require(‘包名’)的方式加载使用 node_modules/art-template/package.json文件中的main属性就记录了art-template的入口模块 实际上最终加载的还是文件 如果package.json不存在或main指定入口模块也没有 则node会自动找该目录下的index.js（index.js就是个默认备选项） 一个项目仅有一个node_modules 且存放在项目根目录 IP地址和端口号的概念 ip地址用来定位计算机 端口号用来定位具体的应用程序 所有需要联网通信的应用程序都会占用一个端口号 端口号的范围从0~65536之间 在计算机中有些端口号，最好不要去使用，例如http服务默认的80 练习的时候使用简单好记的就可以了，如3000、5000等没有什么含义 在一台计算机中，同一个端口号同一时间只能被一个程序占用 服务端渲染和客户端渲染的区别 服务端渲染说白了就是在服务端使用模板引擎 客户端渲染不利于SEO搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以真正的网站是二者结合来做的 例如：京东的商品列表就是采用服务端渲染，目的是为了SEO搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要SEO搜索引擎优化，所以采用的是客户端渲染 Node.js REPL(Read Eval Print Loop:交互式解释器)这个环境的作用只是用来做一些辅助测试：例如可以直接在里面使用node中的核心模块而不需要require加载。 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 Node 自带了交互式解释器，可以执行以下任务： 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 案例模板 / index.html 开放public目录中的静态资源 当请求 /public/xxx 的时候，读取响应 public 目录中的具体资源 /post post.html /tijiao 4.1接收表单提交数据 4.2存储表单提交数据 4.3让表单重定向到 / npm（安装第三方软件） node package manager （node 包管理器） npm是世界上最大的开源库生态系统 绝大多数js相关的包都放在了npm上，为了方便开发人员下载使用 只要安装了node就已经安装了npm npm网站：npmjs.com npm命令行工具查看版本号可以在命令行输入: 升级npm: 常用命令 npm init -y 可以跳过向导，快速生成package.json npm install 一下子把dependencies中的依赖项全部安装 npm install 包名 只下载 简写 npm i 包名 npm install --save 包名 下载并保存依赖项 简写 npm i -S 包名 npm uninstall 包名 只删除，如果有依赖项会依然保存 简写npm un 包名 npm uninstall --save 包名 删除的同时也会把依赖信息去除 简写npm un -S 包名 npm help 查看使用帮助 npm 命令 --help 查看指定命令的使用帮助 解决npm被墙问题npm存储包文件的服务器在国外，有时候会被墙，速度很慢 淘宝的开发团队把npm在国内做了一个备份 安装淘宝的cnpm: 接下来你安装包的时候把之前的npm换成cnpm 举个例子 package.json 建议每个项目都要有一个package.json文件(包描述文件) 可以通过npm init的方式自动初始化出来 建议执行npm install 包名的时候都加上--save这个选项，目的是用来保存依赖项信息 如果node_modules删除了，只需要npm install就会自动把package.json中的dependencies中所有的依赖项都下载回来 nrm npm自定义脚本命令 日期处理模块 nodemon自动重启工具安装 传送门： Express安装 hello world 修改完成代码自动重启我们可以使用一个第三方命令行工具，nodemon来帮助解决修改代码重启服务器问题。 安装完毕后使用： 它会监视你的文件变化。 检验是否安装成功： 基本路由路由器 请求方法 请求路径 请求处理函数 get： post: 静态服务 在Express中配置使用art-template模板引擎安装： 配置： 使用： 如果希望修改默认的views视图渲染存储目录，可以： 在Express获取表单get请求数据Express内置了一个API，可以直接通过req.query来获取 在Express获取表单post请求数据在Express中没有内置获取表单post请求体的API，需要使用第三方包body-parser 安装： 配置： 使用： MongoDBMongoDB数据库的基本概念 可以有多个数据库 一个数据库中可以有多个集合（表） 一个集合中可以有多个文档（表记录） 文档结构很灵活，没有任何限制 MongoDB非常灵活，不需要像MySQL一样先创建数据库、表、设计表结构 在这里只需要，当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了 建库建表由MongoDB自动帮你完成 关系型数据库和非关系型数据库表就是关系 或者说表与表之间存在关系 所有关系型数据库都需要通过sql语言来操作 所有关系型数据库在操作之前都需要设计表结构 而且数据表还支持约束 唯一的 主键 默认值 非空 非关系型数据库非常灵活 有的非关系型数据库就是key-value对儿 但MongoDB是长的最像关系型数据库的非关系型数据库 数据库-》数据库 数据表-》集合（数组） 表记录-》（文档对象） MongoDB不需要设计表结构 安装 下载 安装 配置环境变量 最后输入mongod --version检测是否安装成功 启动和关闭数据库 启动： 停止： 连接和退出数据库连接: 退出： 基本命令 show dbs 查看显示所有数据库 db 查看当前操作的数据库 use 数据库名称 切换到指定的数据（如果没有会新建） hello word 官方指南官方文档：  设计Scheme 发布Model 增加数据 查询所有 按条件查询所有 按条件查询单个 删除数据 更新数据 使用Node操作MySQL数据库安装： 使用： "},{"title":"Uni app 页面&组件生命周期","date":"2021-09-20T14:33:51.924Z","url":"/2021/09/20/Uni%20app%20%E9%A1%B5%E9%9D%A2&%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Uni app 页面&amp;组件生命周期不论是app还是小程序，生命周期是非常重要的知识点。 uni-app 支持如下生命周期函数： 页面的生命周期onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为object（用于页面传参）onShow 监听页面显示onReady 监听页面初次渲染完成onHide 监听页面隐藏onUnload 监听页面卸载onPullDownRefresh 监听用户下拉动作onReachBottom 页面上拉触底事件的处理函数onShareAppMessage 用户点击右上角分享 微信小程序onPageScroll 监听页面滚动onTabItemTap 当前是 tab 页时，点击 tab 时触发。 组件的生命周期beforeCreate：组件初始化，但数据原生观测、自定义观测(event\\watcher)没生成之前。 未完全创建阶段created：组件创建后，但还未挂载 完全创建阶段beforeMount：组件渲染后，挂载前。 渲染后待挂载mounted： 组件挂载到页面 可用 vm.$el 访问 挂载OKbeforeUpdate： 虚拟 DOM 重新渲染和打补丁之前 再次渲染前updated ： 组件 DOM 已经更新 再次渲染后activated： keep-alive 组件激活时调用。 当前组件被激活：显示deactivated： keep-alive 组件停用时调用。 当前组件隐藏beforeDestroy： 实例销毁之前调用。实例仍然完全可用。 销毁前destroy： Vue 实例销毁后调用补充：1.挂载阶段，先渲染组件，然后挂载组件。"},{"title":"vscode npm 配置cnpm不可用","date":"2021-09-20T14:33:27.451Z","url":"/2021/09/20/vscode%20npm%20%E9%85%8D%E7%BD%AEcnpm%E4%B8%8D%E5%8F%AF%E7%94%A8/","tags":[["npm","/tags/npm/"]],"categories":[["Vue","/categories/Vue/"]],"content":"vscode npm 配置cnpm不可用在powershell 中输入 get-ExecutionPolicy 默认是Restricted(禁用) 输入set-ExecutionPolicy 输入RemoteSigned 即可"},{"title":"vuejs和jquery可以混着用吗","date":"2021-09-20T14:33:15.644Z","url":"/2021/09/20/vuejs%E5%92%8Cjquery%E5%8F%AF%E4%BB%A5%E6%B7%B7%E7%9D%80%E7%94%A8%E5%90%97/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"vuejs和jquery可以混着用吗1、Vue 的官方是不建议直接操作 DOM 的，Vue 的用途在于视图和数据的绑定。如果通过JQuery 直接操作 DOM 的话，势必会造成视图数据和模型数据的不匹配，这样 Vue 就失去它存在的意义了； 2、JQuery 和 VueJS 合理使用并不会造成冲突，因为他们的侧重点不同，VueJS 侧重数据绑定和视图组件，JQuery 侧重异步请求和动画效果。如果使用JQuery + VueJS 开发，一定要在 Vue 渲染完所有的 HTML组件之后再通过 JQuery 处理，而使用 JQuery 时应避免直接操作 DOM ，但是应用动画是允许的； 3、JQuery 与 VueJS 相互配合可以非常高效的完成异步任务，首先通过 JQuery 发出 Ajax 请求，接受到服务端传递的 JSON 数据后，再通过 Vue 将数据绑定到组件上，最后由 JQuery 进行动画处理，整个过程就如行云流水般自然； 4、说句题外话，Vue 的目的不是取代 JQuery，它是为了解决前后端分离而出现的。如果没有数据变化，只是单纯的样式变化，则没有必要去大费周章进行视图模型的绑定，并且还不利于 SEO 优化。"},{"title":"在vue的脚手架中添加bootstrap","date":"2021-09-20T14:33:12.040Z","url":"/2021/09/20/vue%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0bootstrap/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"在vue的脚手架中添加bootstrap参考网址：   一、在项目的根目录下创建vue.config.js 关键代码： 二、在main.js中引入jquery、bootstrap 三、在.eslintrc.js中添加jquery: true 解决有些bootstrap的样式失效问题： 查看bootstrap的版本，添加bootstrap对应的版本代码 "},{"title":"在vue项目/uniapp中使用md5加密","date":"2021-09-20T14:33:02.196Z","url":"/2021/09/20/vue%E9%A1%B9%E7%9B%AEuniapp%E4%B8%AD%E4%BD%BF%E7%94%A8md5%E5%8A%A0%E5%AF%86/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"在vue项目/uniapp中使用md5加密在根目录下安装MD5模块npm install js-md5 -D在项目中引入md5模块 import md5 from &#39;js-md5&#39;; 使用md5();"},{"title":"解决wamp服务器离线的几种方法","date":"2021-09-20T14:32:55.137Z","url":"/2021/09/20/%E8%A7%A3%E5%86%B3wamp%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A6%BB%E7%BA%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","tags":[["wamp","/tags/wamp/"]],"categories":[["其他","/categories/%E5%85%B6%E4%BB%96/"]],"content":"1.文件名不能是中文2.apache里的http.conf的80改成8080端口3.防护墙里的高级设置里的入站规则里的apache HTTP Server改为启用4.切换到在线状态"},{"title":"微信小程序mina","date":"2021-09-20T14:32:30.866Z","url":"/2021/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fmina/","tags":[["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["微信小程序","/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"content":"微信小程序mina参考代码工程mina-show-goods 参考教程视频 在线接口文档 使用阿里icon图标1、建立styles/iconfont.wxss文件复制Font class 生成的代码 2、在app.wxss中全局引用 在微信小程序中 不支持 通配符正确用法 存在 变量这个知识1、定义颜色 2、使用颜色 使用组件1、在components创建组件SearchInput 2、在要使用的页面index.json中引入组件 3、在index.wxml中使用组件 wx:forwx:for 这个是正常的循环，没什么可说的。 wx:for-item=‘变量名（随便起的）’ 它是指定循环数据当前的变量名，可以通过 展示数组的元素。 wx:for-index=‘变量名（随便起）’，它是指向当前元素的下标名，可以在其他事件中定义自定义事件（data-xxx=’‘，，该自定义属性可以在参数e下面打印出来）获取该下标。 web中的本地存储和小程序中的本地存储的区别1:写代码的方式不一样了 web: 小程序中: 2:存的时候有没有做类型转换 web:不管存入的是什么类型的数据，最终都会先调用以下toString(), 把数据变成了字符串再存入进去 小程序:不存在类型转换的这个操作存什么类似的数据进去，获取的时候就是什么类型 onLoad中的options参数小程序页面加载的时候，可以通过options获取到上一个页面标签的属性以及属性值 wx:key=”*this”*this 代表for循环中的 item 本身 性能优化原： 大量的请求没有使用过的数据，会降低小程序的性能,使小程序加载缓慢 改： 足个提取要请求的数据，减少请求数据量 iPhone部分手机 不识别webp图片格式webp图片格式体积小质量高 但iPhone部分手机 不识别webp图片格式。 最好找到后台 让他进行修改； 临时自己改 确保后台存在 1.webp =&gt; 1.jpg； 使用Array map() 方法来过滤数据map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。它的语法是： 因此使用map()方法可以过滤掉一些数据，得到你想要的数据。 如： 点击轮播图放大预览bindtap绑定事件 自定义data-url=”” 接收传递过来的图片url 总js代码 可解构 使用button，但不改变view的样式 蒙版在tool_item里添加button 使用绝对定位，让button和父元素一样大小，覆盖在父元素上 "},{"title":"关于hexo","date":"2021-09-20T14:23:09.103Z","url":"/2021/09/20/%E5%85%B3%E4%BA%8Ehexo/","tags":[["hexo","/tags/hexo/"]],"categories":[["Hexo","/categories/Hexo/"]],"content":"1.官方主题 2.使用hexo+github搭建博客详细教程  3.常用hexo命令常见命令hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传"},{"title":"收录一些醍醐灌顶的知识","date":"2021-09-20T14:18:18.967Z","url":"/2021/09/20/%E6%94%B6%E5%BD%95%E4%B8%80%E4%BA%9B%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6%E7%9A%84%E7%9F%A5%E8%AF%86/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"1.深拷贝和浅拷贝详解 2.对于JavaScript原生的JS 3.Vue 超清晰思维导图 4.原型–面向对象ES6\\1. 面向对象和面向过程 2. ES6 类语法 3. 继承 4. 面向对象案例 5. 原型和原型链 6. 组合继承 7. 严格模式 8. 闭包 9. 递归函数 10. 深拷贝浅拷贝 11. 高阶函数 12. call、apply、bind 13. ES6 14. 对象解构 15. 箭头函数 16. 扩展运算符 17. 模板字符串 5.图片下载跨域问题、图片展示缓存问题 6.添加this.$forceUpdate();进行强制渲染，效果实现。因为数据层次太多，render函数没有自动更新，需手动强制刷新。"},{"title":"Koa框架+MongoDB","date":"2021-09-19T15:23:08.914Z","url":"/2021/09/19/Koa%E6%A1%86%E6%9E%B6+MongoDB/","tags":[["koa","/tags/koa/"]],"categories":[["Node","/categories/Node/"]],"content":"Koa框架+MongoDB教学视频参考 mongodb启动先管理员运行net start MongoDB 再到D:\\MongoDB\\bin中启动mongo.exe 搭建本地服务器先安装node 再项目初始化 ——————–package.json 安装koa 和 koa-router 成功后可在package.json看到 在package.json中更改入口文件 新建app.js 在package.json中配置启动命令 运行npm run server或npm run start启动项目 连接MongoDB数据库首先安装mongoose 在app.js中引入mongoose 再连接数据库 成功后打印Mongodb Connectd… 可进行优化： 1、创建config/key.js 2、引入 3、连接 创建测试接口创建routes/api/users.js 用户信息文件 在app.js中指定路由地址 1、引入 2、配置路由地址 最后访问localhost:5000/api/users/test 可以看到{“msg”:”users works..”} 配置用户模型创建models/Users.js 在routes/api/users.js下引入User 注册接口和调试工具Postman安装koa-bodyparser 1、在app.js中引入 2、使用 在routes/api/users.js中做post请求 可以在Postman中看到返回的json数据 可给密码加密用bcryptjs 1、在routes/api/users.js引入 2、使用 全球公认头像1、安装 2、在routes/api/users.js中使用 同步加密封装因为之前的异步加密使用了两次异步，数据库里的密码还是明文 所以改用同步 创建config/tools.js 在routes/api/users.js中 返回json数据 登录接口在routes/api/users.js中 生成token1、安装jsonwebtoken 2、在routes/api/users.js中引用 优化 在config/keys.js中添加secret 返回json数据 koa-passport验证token安装 在package.json中可看到 在app.js入口文件中使用 创建config/passport.js 安装passport-jwt 在config/passport.js中使用 在routes/api/users.js中填写获取用户信息接口 使用validator验证表单安装 创建validator/register.js 创建validator/is-empty.js 在routes/api/users.js中引入input验证 并在注册接口地址中添加 验证登录和注册的input在validator/register.js中 创建validator/login.js 在routes/api/users.js中引入input验证 并在登录接口地址中添加 "},{"title":"Hello World","date":"2021-09-19T12:17:04.661Z","url":"/2021/09/19/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]