[{"title":"vue","date":"2022-07-18T14:09:42.585Z","url":"/2022/07/18/vue/","tags":[["Vue","/tags/Vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"vue1.v-show和v-if区别 2.为何v-for要用key 3.描述vue组件声明周期 4.vue组件如何通信 5.描述组件渲染和更新的过程 6.双向数据绑定v-model的实现原理 7.对mvvm的理解 8.computed有何特性 9.VUE 中如何封装组件？什么组件，为什么要封装组件？组件中 data 为什么是一个函数？ 10.ajax请求应该放在哪个生命周期？ 11.如何将组件所有props传递给子组件？ 12.如何自定实现v-model? 13.多个组件有相同逻辑，如何抽离？ 14.何时要使用异步组件？ 15.何时使用keep-alive？ 16.何时使用beforeDestroy？ 17.什么是作用域插槽？ 18.vuex中action和mutation有何区别？ 19.vue-router常用路由模式 20.如何配置vue-router异步加载 21.请用vnode描述一个dom结构 22.监听data变化的核心api是什么？ 23.vue如何监听数据变化？ 24.请描述响应式原理？ 25.简述diff算法过程（了解） 26.vue为何是异步渲染，$nextTick何用？ 27.vue常见性能优化方式？ 28、VUEX 是什么？怎么使用？那种场合能用？ 29、vue 的指令用法 30、vue.js的两个核心是什么？ 31.vue中子组件调用父组件的方法? 32.vue中父组件调用子组件的方法? 33.vue页面级组件之间传值? 34.说说vue的动态组件。 35.$route和 $router的区别是什么？ 36.为什么使用vue开发？ 37.vue和react 有什么区别？ 38.Vuex和Redux的区别 39.说一下vue的生命周期/钩子函数都有哪些？ 40.双向数据绑定的理解？ 41.vue组件中data为什么函数返回一个对象 42.vue中哪些数组方法可以直接对数组修改实现视图更新 43.有哪些指令？v-if和v-show区别，v-if、v-for优先级 44.v-for中key 的作用 45.使用过keep-alive吗 46.computed、watch（自动监听、深度监听）、methods区别 47.vue中对象更改检测的注意事项 48.什么是$nextTick？ 49.ref 的作用？ 50.什么是vuex？vuex核心包括？怎么修改state中数据？在项目中哪里使用？ 51.路由模式有哪些？路由传参有哪些方式？路由守卫有哪些，有没有在项目中使用过？ 52.vue过滤器 53.有没有封装过组件，封装过什么，怎么封装？注意点或有哪些原则？ 注意点或有哪些原则？ 54.移动端项目如何适配（rem）？ 55.有没有使用过axios、axios拦截器，跨域如何解决？ 56.vue项目做过哪些优化 57.为什么做首屏优化？ 58.如何做首屏优化？ 59.vue常用的修饰符 60.v-on可以监听多个方法吗？ 61.vue中编写可复用的组件(深度好题，掌握思路,不用背诵) 1.在 Vue 组件中，状态称为 props，事件称为 events，片段称为 slots。 2.组件间通信 3.命名 4.业务数据无关 5.组件职责 6.命名空间 7.上下文无关 8.数据扁平化 9.使用自定义事件实现数据的双向绑定 v-model 10.使用自定义 watch 优化 DOM 操作 11.项目骨架 62.vue如何监听键盘事件中的按键？（大声朗读2遍） 63.解决非工程化项目初始化页面闪动问题(好题,理解) 64.v-for产生的列表，实现active的切换 tab切换 65.v-model语法糖使用 66.十个常用的自定义过滤器 67.vue等单页面应用及其优缺点 68.vue的计算属性，特性，应用 69.vue父组件向子组件通过props传递数据 70.vue-cli生产环境使用全局常量(了解) 71.vue弹窗后如何禁止滚动条滚动？（了解） 72.vue-cli中自定义指令的使用 73.父组件异步获取动态数据传递给子组件(好题) 74.父组件给子组件props传参，子组件接收的6种方法 75.Vuex页面刷新数据丢失咋解决这个bug 76.按钮权限怎么做？ 77.完整的说下从url解析到显示页面过程，结合项目中说 78.vue声明周期都在哪些场景中使用？ 3.html、css1.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？H5新特性有： 处理h5新标签的浏览器兼容性问题： 2.行内元素和块级元素的区别？什么是重绘和回流？两者区别？ 回流： 重绘： 3.CSS 选择符有哪些？优先级算法如何计算？ 优先级算法如何计算？ 4.CSS3有哪些新特性？ 5.解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？ 6.简述flex布局 7.css 隐藏元素有哪几种方法？position定位有哪些？css隐藏元素方法 position定位有哪些？ 8.BFC（Block Formatting Context） 是什么？应用？ 9.解释下浮动和它的遗留问题？清除浮动的方法（4种）浮动为该元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 浮动引起的问题： 清除浮动的方法： 10.哪些外边距不重叠的情况？防止外边距重叠的方法？外边距不重叠的情况： 防止外边距重叠的方法： 11.如何让一个盒子水平垂直居中 12.左右固定中间自适应 三栏布局（圣杯、双飞翼、弹性盒子…）圣杯布局： 缺点：当面板的main部分比两边的子面板宽度小的时候，布局就会乱掉。 双飞翼布局: flex布局 13.静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）静态布局（Static Layout） 自适应布局（Adaptive Layout） 流式布局（Liquid Layout） 响应式布局（Responsive Layout） 弹性布局（rem/em布局） 1.静态布局： 布局特点：宽高固定 2.自适应布局： 布局特点：不同分辨率下，页面元素位置变化，大小不变 **实现方法:**针对不同分辨率创建对应的样式表，使用 @media 媒体查询给不同尺寸的设备切换不同的样式 缺点：IE8及以下不支持媒体查询；只能兼容主流分辨率 3.流式布局（百分比布局）: 布局特点：不同的分辨率下显示相同的排版；高度固定，宽度自适应 **实现方法:**网页中主要区域的尺寸使用百分比； 缺点：大屏幕上元素被拉长，但是文字，高度还是固定大小，不协调 经典流式布局：左侧固定，右侧自适应；两侧固定，中间自适应 4.弹性布局（rem/em布局）： 布局特点：页面元素宽度，高度，字体大小会跟着屏幕大小缩放 **实现方法:**使用js监听当前屏幕大小，设置html的字体大小 缺点：IE678不兼容；需要计算； 5.响应式布局：一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本 布局特点：每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变，响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表等等）都能显示出令人满意的效果 实现方法：媒体查询(css3中的Media Query)+流式布局 媒介查询：通过不同的媒介类型和条件定义样式表规则，媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。 优点：适应pc和移动端 1.面对不同分辨率设备灵活性强 2.能够快捷解决多设备显示适应问题 缺点：要匹配足够多的屏幕大小，工作量大，设计也需要多个版本 1.会出现隐藏无用的元素 2.加载时间加长 14.less、sass、 stylus分别都有哪些优缺点？15.说一下在IE（IE6）中常见的几个兼容性问题一、头文档所引起的怪异盒模型问题 产生条件：不设置文档声明，页面就会陷入怪异盒模型解析模式 解决方法：加入文档声明 二、IE6下双边距BUG 产生条件：在IE6下，块元素有浮动有横向的margin，横向的margin值会被放大成两倍浮动方向与margin方向一致时，该方向会出现双倍边距 解决方法：display:inline 三、图片间隙问题 产生条件：给父容器设置宽度后，图片会在原来基础上把父元素撑大3-5px 解决方法：1.给父元素添加font-size：0；2.给图片添加display：block； 四、li的间距问题 产生条件：IE6浏览器 li标签设置宽高，且li里面的元素发生了浮动解决方法：1. li不设置宽高； 五、块状元素默认高度问题 产生条件：部分块状元素会有默认高度（一般为16px-18px之间）解决方法： 1.给元素添加overflow:hidden; 2.font-size：0； 六、表单行高不一致 产生条件：一行中的文本输入框和按钮不在同一高度解决办法：给表单元素添加float：left；并去掉默认边框border：0； 七、图片元素img下高度超出,出现多余空白 解决方法：1.设置img为display:block; 2.父级设置overflow:hidden; 八、左浮元素margin-bottom失效 解决方法：1.显示设置高度 2.父标签设置_padding-bottom代替子标签的margin-bottom 3.再放个标签让父标签浮动，子标签margin- bottom，即(margin-bottom与float不同时 作用于一个标签) 九、position下的left，bottom错位 解决方法：为父级(relative层)设置宽高或添加*zoom:1 十、子级中有设置position，则父级overflow失效 解决方法：为父级设置position:relative 十一、块元素中有文字及右浮动的行元素，行元素换行 解决方法：将行元素置于块元素内的文字前 十二、透明rgba与opacity 产生条件：IE6不支持此两种透明的设置方法 解决方法：使用IE6当中的滤镜filter替代掉，如：opacity:0.6;filter:alpha(opacity=60)异盒模型问题 16.清空数组的方法1.splice 2.length赋值为0 3.赋值为[] 4.js1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么? 2.你简述盒模型 3.CSS3的新特性 4.CSS选择器及其优先级 5.说说BFC 6.说说定位相关的属性 7.谈谈flex布局 8.你怎么清楚浮动 9.两边宽度固定中间自适应的三栏布局(默写题,手写笔试题)圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。圣杯布局双飞翼布局 10.浏览器渲染机制 11.重绘和回流的区别 12.JS数据类型 13.JS判断数据类型的方法 14.null和undefined区别 15.JS作用域的理解 16.call,apply和bind区别的页面在哪些流览器测 17.深拷贝和浅拷贝 18.谈谈防抖和节流 19.谈谈cookie,sessionStorage和localStorage 20.0.1+0.2!=0.3怎么处理 21.数组的常用方法(至少说出8个) 22.new一个对象的过程中发生了什么吗? 23.JS实现继承(至少会一种) 24.get和post区别 请求方式 GET POST 参数位置 参数拼接到url的后面 参数在请求体中 参数大小 受限于浏览器url大小，一般不超过32K 1G 服务器数据接收 接收1次 根据数据大小，可分多次接收 适用场景 从服务器端获取数据 向服务器提交数据 安全性 参数携带在url中，安全性低 相对于GET请求，安全性更高 25.JSONP原理 26.缓存的理解 27.XSS和CSRF区别 28.HTTP与HTTPS的区别 29.HTTP状态码 30.事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件 31.Js事件循环机制 32.面向对象、原型、原型链、继承 33.什么是闭包，使用场景及优缺点？ 34.this指向 35.箭头函数和普通函数的区别？ 36.什么是promise? 37.什么是ajax？ 5.兼容性1、IE8 下面的 png 图片无法正常显示？原因：打开调试面板，你会发现 IE8 浏览器把 PNG 格式的 img 解析成了 span 标签，导致图无法显示。解决方案：在样式里面对 span 设置宽高和 display:inline-block;即可。 2、rgba 不支持 IE8？解决方案:可以用 opacityopacity:0.7;/FF chrome safari opera/filter:alpha(opacity:70);/用了 ie 滤镜,可以兼容 ie/但是,需要注意的是,opacity 会影响里面元素的透明度 3、Css3 的新属性？当一些 CSS3 样式语法还存在波动时，它们提供针对浏览器的前缀。现在主要流行的浏览器内核主要有：Trident 内核：主要代表为 IE 浏览器Gecko 内核：主要代表为 Firefox FFPresto 内核：主要代表为 OperaWebkit 内核：产要代表为 Chrome 和 Safari而这些不同内核的浏览器，CSS3 属性（部分需要添加前缀的属性）对应需要添加不同的前缀，也将其称之为浏览器的私有前缀，添加上私有前缀之后的 CSS3 属性可以说是对应浏览器的私有属性：Trident 内核：前缀为-msGecko 内核：前缀为-mozPresto 内核：前缀为-oWebkit 内核：前缀为-webkit 4、document.form.item 问题问题：代码中存在 document.formName.item(“itemName”) 这样的语句，不能在 FF 下运行解决方法：改用 document.formName.elements[“elementName”] 5、集合类对象问题问题：代码中许多集合类对象取用时使用()，IE 能接受，FF 不能解决方法：改用 [] 作为下标运算，例：document.getElementsByName(“inputName”)(1) 改 为document.getElementsByName(“inputName”)[1] 6、window.event || event问题：使用 window.event 无法在 FF 上运行解决方法：FF 的 event 只能在事件发生的现场使用，此问题暂无法解决。可以把 event 传到函数里变通解决：onMouseMove = “functionName(event)”function functionName (e) {e = e || window.event;……} 7、HTML 对象的 id 作为对象名的问题问题：在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用，在 FF 中不能解决方法：使用对象变量时全部用标准的 getElementById(“idName”) 通过id取dom节点 8、用 idName 字符串取得对象的问题问题：在 IE 中，利用 eval_r(“idName”) 可以取得 id 为 idName 的 HTML 对象，在 FF 中不能解决方法：用 getElementById(“idName”) 代替 eval_r(“idName”) 9、变量名与某 HTML 对象 id 相同的问题问题：在 FF 中，因为对象 id 不作为 HTML 对象的名称，所以可以使用与 HTML 对象 id 相同的变量名，IE 中不能解决方法：在声明变量时，一律加上 var ，以避免歧义，这样在 IE 中亦可正常运行最好不要取与 HTML 对象 id 相同的变量名，以减少错误 10、event.x 与 event.y 问题问题：在 IE 中，event 对象有 x,y 属性，FF 中没有解决方法：在 FF 中，与 event.x 等效的是 event.pageX ，但 event.pageX IE 中没有故采用 event.clientX 代替 event.x ，在 IE 中也有这个变量event.clientX 与 event.pageX 有微妙的差别，就是滚动条要完全一样，可以这样：mX = event.x ? event.x : event.pageX;然后用 mX 代替 event.x 11、 取得元素的属性在 FF 中，自己定义的属性必须 getAttribute() 取得 在 FF 中没有 parentElement，parement.children 而用 parentNode，parentNode.childNodes 问题：childNodes 的下标的含义在 IE 和 FF 中不同，FF 的 childNodes 中会插入空白文本节点解决方法：可以通过 node.getElementsByTagName_r() 来回避这个问题问题：当 html 中节点缺失时，IE 和 FF 对 parentNode 的解释不同，例如：​ FF 中 input.parentNode 的值为 form，而 IE 中 input.parentNode 的值为空节点​问题：FF 中节点自己没有 removeNode 方法解决方法： 必须使用如下方法 node.parentNode.removeChild(node) 12、const 问题问题：在 IE 中不能使用 const 关键字解决方法：以 var 代替 13、body 对象FF 的 body 在 body 标签没有被浏览器完全读入之前就存在，而 IE 则必须在 body 完全被读入之后才存在这会产生在 IE 下，文档没有载入完时，在 body 上 appendChild 会出现空白页面的问题解决方法：一切在 body 上插入节点的动作，全部在 onload 后进行 14、url encoding问题：一般 FF 无法识别 js 中的&amp; 解决方法：在 js 中如果书写 url 就直接写&amp;不要写&amp; 15、nodeName 和 tagName 问题问题：在 FF 中，所有节点均有 nodeName 值，但 textNode 没有 tagName 值，在 IE 中，nodeName的使用有问题解决方法：使用 tagName，但应检测其是否为空 16.元素属性IE下input.type 属性为只读，但是FF下可以修改 document.getElementsByName() 和document.all[name] 的问题 问题：在IE中，getElementsByName()、document.all[name] 均不能用来取得div 元素是否还有其它不能取的元素还不知道（这个问题还有争议，还在研究中） 17.调用子框架或者其它框架中的元素的问题在IE中，可以用如下方法来取得子元素中的值 document.getElementByIdx_x(“frameName”).(document.)elementName window.frames[“frameName”].elementName 在FF中则需要改成如下形式来执行，与IE兼容：window.frames[“frameName”].contentWindow.document.elementName window.frames[“frameName”].document.elementName 18.对象宽高赋值问题问题：FireFox中类似obj.style.height = imgObj.height 的语句无效 解决方法：统一使用obj.style.height = imgObj.height + “px”; 19.innerText的问题问题：innerText 在IE中能正常工作，但是innerText 在FireFox中却不行 解决方法：在非IE浏览器中使用textContent代替innerText 20.event.srcElement和event.toElement问题问题：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性 解决方法：var source = e.target || e.srcElement;var target = e.relatedTarget || e.toElement; 21.禁止选取网页内容问题：FF需要用CSS禁止，IE用JS禁止 解决方法：IE: obj.onselectstart = function() {return false;} ​ FF: -moz-user-select:none; 22.捕获事件问题：火狐(FF)没有setCapture(),releaseCapture()方法 解决方法： IE：obj.setCapture(); obj.releaseCapture() FF： window.captureEvents(Event.MouseMove|Event.MoouseUp); window.releaseEvents(Event.MouseMove|Event.MouseUp) 移动端常见的兼容性问题1.html5调用安卓或者ios的拨号功能html5提供了自动调用拨号的标签，只要在a标签的href中添加tel：就可以了。如下：&lt; a href=” “&gt;400-810-6999 转 1034&lt;/ a&gt;拨打手机如下：&lt; a href=”tel:15677776767”&gt;点击拨打 15677776767 &lt;/ a&gt; 2.上下拉动滚动条时卡顿、慢 body { -webkit-overflow-scrolling: touch; overflow-scrolling: touch; } Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling。 3.圆角bug某些 Android 手机圆角失效background-clip: padding-box; 4.ios 设置input 按钮样式会被默认样式覆盖解决方式如下： input,textarea {border: 0;-webkit-appearance: none;}设置默认样式为 none 5.IOS键盘字母输入，默认首字母大写解决方案，设置如下属性 &lt;input type=”text”autocapitalize=”off”/&gt; 6.h5底部输入框被键盘遮挡问题h5页面有个问题是，当输入框在最底部，点击软键盘后输入框会被遮挡。可采用如下方式解决 var oHeight = $(document).height(); //浏览器当前的高度 ​ $(window).resize(function(){ ​ if($(document).height() &lt; oHeight){ ​ $(“#footer”).css(“position”,”static”); ​ }else{ ​ $(“#footer”).css(“position”,”absolute”); ​ } ​ }); 7.IOS移动端click事件300ms的延迟响应解决方案： 1、fastclick可以解决在手机上点击事件的300ms延迟 2、zepto的touch模块，tap事件也是为了解决在click的延迟问题 3、触摸事件的响应顺序为touchstart –&gt; touchmove –&gt; touchend –&gt; click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题 8.在ios和andriod中,audio元素和video元素在无法自动播放应对方案：触屏即播$(‘html’).one(‘touchstart’,function(){audio.play()}) 9.CSS动画页面闪白,动画卡顿解决方法: 1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 2.开启硬件加速 -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); 10.fixed定位缺陷1、ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 2、android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 3、ios4下不支持position:fixed解决方案：可用iScroll插件解决这个问题 6.webpack1、如何减少 Webpack 打包时间 2、如何减少 Webpack 打包后的文件体积 3、什么是模块化？ 4、为什么出现模块化？ 5、构建的作用及常见功能是什么？ 6、你了解的构建工具有哪些，各自有什么优缺点？ 7、简单介绍一下webpack 8、Loader机制的作用是什么？ 9、css-loader与style-loader的作用 10、配置 Loader 时需要注意的地方？ 11、Plugin（插件）的作用是什么？ 12、ExtractTextPlugin插件的作用 13、DevServer开发工具 14、实时预览 15、什么是模块热替换？ 16、什么是Source Map 及其使用 17、Webpack的几个核心概念 18、Webpack简单工作原理 19.什么是loader ? 什么是Plugin ? loader和plugin有什么区别？ 20.webpack中都有哪些插件，这些插件有什么作用？ 21.如何利用webpack优化前端性能? 7.vue3.01.Vue3.0和Vue2.0的区别 2.Vue3.0都有哪些重要新特性？ 3.Vue3.0 对比Vue2.0的优势在哪？ 4.Vue3.0和React 16.X都有哪些区别和相似处？ 5.Vue3.0是如何实现代码逻辑复用的？ 8.移动端、小程序1. 移动端兼容适配 2.flexible如何实现自动判断dpr 3.为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？ 4.如何处理异形屏iphone X 5.移动端首屏优化 6.PWA全称Progressive Web App，即渐进式WEB应用 7.离线包方案 8. 自适应和响应式布局的区别 9.简单描述下微信小程序的相关文件类型？ 10.你是怎么封装微信小程序的数据请求的？ 11.小程序有哪些参数传值的方法？ 12.简述微信小程序原理？ 13.小程序的双向绑定和 vue 哪里不一样？ 14.webview 中的页面怎么跳回小程序中？ 15.小程序关联微信公众号如何确定用户的唯一性？ 16.小程序如何实现下拉刷新？ 17.小程序调用后台接口遇到哪些问题？ 18.小程序的 wxss 和 css 有哪些不一样的地方？ 19.分析下微信小程序的优劣势 9.es61、var、let、const之间的区别 var声明变量可以重复声明，而let不可以重复声明var是不受限于块级的，而let是受限于块级var会与window相映射（会挂一个属性），而let不与window相映射var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错const声明之后必须赋值，否则会报错const定义不可变的量，改变了就会报错const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错 2、使用箭头函数应注意什么？ （1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）（2）不能够使用arguments对象（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数 3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能 基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)就能解决类模板字符串的功能 4、介绍下 Set、Map的区别？ 应用场景Set用于数据重组，Map用于数据储存 Set： （1）成员不能重复（2）只有键值没有键名，类似数组（3）可以遍历，方法有add, delete,hasMap:（1）本质上是健值对的集合，类似集合（2）可以遍历，可以跟各种数据格式转换 5、ECMAScript 6 怎么写 class ，为何会出现 class？ ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法 6、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？ promise构造函数是同步执行的，then方法是异步执行的 7、setTimeout、Promise、Async/Await 的区别 事件循环中分为宏任务队列和微任务队列其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行 8、promise有几种状态，什么时候会进入catch？ 三个状态：pending、fulfilled、reject两个过程：padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch 9、下面的输出结果是多少 Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3 10、使用结构赋值，实现两个变量的值的交换 11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key 12、下面Set结构，打印出的size值是多少 答案：2两个数组[1]并不是同一个值，它们分别定义的数组，在内存中分别对应着不同的存储地址，因此并不是相同的值都能存储到Set结构中，所以size为2 13、Promise 中reject 和 catch 处理上有什么区别 reject 是用来抛出异常，catch 是用来处理异常reject 是 Promise 的方法，而 catch 是 Promise 实例的方法reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch网络异常（比如断网），会直接进入catch而不会进入then的第二个回调 14、如何使用Set去重 15、将下面for循环改成for of形式 答案： 16、理解 async/await以及对Generator的优势 async await 是用来解决异步的，async函数是Generator函数的语法糖使用关键字async来表示，在函数内部使用 await 来表示异步async函数返回一个 Promise 对象，可以使用then方法添加回调函数当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句async较Generator的优势：（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化 （3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用 17、forEach、for in、for of三者区别 forEach更多的用来遍历数组for in 一般常用来遍历对象或jsonfor of数组对象都可以遍历，遍历对象需要通过和Object.keys()for in循环出的是key，for of循环出的是value 28、说一下es6的导入导出模块 导入通过import关键字 导出通过export关键字 10.React react组件如何通信 父组件向子组件通信：使用 props 子组件向父组件通信：使用 props 回调 跨级组件间通信：使用 context 对象 非嵌套组件间通信：使用事件订阅 jsx本质是什么 jsx其实是语法糖，开发环境会将jsx编译成js代码，jsx的写法大大降低了学习成本和编码工作量 context是什么，有何用途 在react应用中，数据总是通过 props 自上而下进行传递。 这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题）。Context 可以共享对于一个组件树而言是“全局”的数据。这样就不必显式地通过组件树的逐层传递 props shouldComponentUpdate用途 询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。 描述redux单项数据流 当一个页面渲染完后，UI出现，用户其实是触发了UI上的一些Action，Action将会被送到Reducers方法里，Reducers将会更新Store，数据就是React开发中的State，State其实是Store的一部分，所有的视图层的东西，也就是组件，其实是由State来唯一决定的。 ![img](D:\\课件\\课件p4\\day06 React\\img\\Center) setState是同步还是异步？ 既可能是同步的,也可能是异步的。 准确地说,在React内部机制能检测到的地方, setState就是异步的;在React检测不到的地方,例如setInterval,setTimeout里,setState就是同步更新的 什么是纯函数 一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。 react组件生命周期 // 实例化组件，也就是构造DOM元素constructor();// 当DOM元素载入之前调用componentWillMount();// 将构造的元素插入到指定的页面元素中render();// 当DOM元素载入页面之后调用componentDidMount();// 当从页面中卸载时会调用componentWillUnmount() react发起ajax应该在哪个生命周期 componentDidMount生命周期中调用 渲染列表，为何使用key？ key是给每一个虚拟dom的唯一id,可以依靠key,更准确, 更快的拿到旧虚拟dom中对应的新虚拟dom节点。 函数组件和class组件区别 函数组件纯函数，输入props，输出jsx 函数组件没有实例，没有生命周期，没有state 函数组件不能扩展其他方法 class创建的组件,有自己的私有数据(this.state)和生命周期 什么是受控组件 简单的说就是input里面的值受state值控制 何时使用异步组件 加载大组件 路由异步加载 资源异步加载 多个组件有公共逻辑，如何抽离 HOC，高阶组件 高阶组件不是一种功能，而是一种模式 Render Props核心思想：通过一个函数将class组件的state作为props传递给纯函数组件 redux如何进行异步请求 ajax请求 react-router如何配置懒加载 lazyload-loader方式 import Shop from &#39;lazy!./src/view/Shop&#39;; 箭头函数方式 component:resolve =&gt; require([&#39;@/component/Login&#39;],resolve)· PureComponent和Component有何区别 React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。 在PureComponent中，如果包含比较复杂的数据结构，可能会因深层的数据不一致而产生错误的否定判断，导致界面得不到更新。 react事件和dom事件区别 react性能优化 使用shouldComponentUpdate来优化组件 shouldComponentUpdate的实现方式，shouldComponentUpdate在比对prop和上次渲染所用的prop方面，依然用的是尽量简单的方法，做的是所谓的“浅层比较”。简单来说就是用JavaScript的===操作符来比较，如果prop的类型是字符串或者数字，只要值相同，那么“浅层比较”也会认为二者相同，但是，如果prop的类型是复杂对象，那么“浅层比较”的方式只看这两个prop是不是同一个对象的引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是两个不同的prop。 react和vue区别 11.实战1.promise封装ajax？ 2.移动端1像素问题如何解决 3.如何解决vuex刷新之后数据重置的问题 4.git常用命令 5.promise原理 6.router和localhost.href和go(-1)区别 7.css动态效果 8.vue框架搭建（中高级） 9.前端上百万的点，加载会崩溃，有啥性能优化方案？(大数据项目) 10,说下云计算？ 11.ajax和axios的区别 12.在vue中如何监听对象obj.a 13.在vue中如何给属性动态添加新属性 14.简单描述nextTick原理及作用 15.如何解决弹性盒布局div会随内部表格被撑开的问题。 16.兼容pc端移动端响应式页面，pc端左右轮播，移动端上下轮播实现 17.$set作用和$delete作用 18.路由懒加载 19.数组新特性，map和foreach区别 20.promise.all 21.async await 22.图片懒加载的实现原理和方式 23.js和css实现动态效果方式 24.路由传参的方式，query和params各个方式之间的优劣 25.根据接口中的数据进行区别挂载，怎么实现 26.路由跳转之前的钩子函数中是否可以过去例如this这样的值 27.28.父子组件传值，父组件中值改变，子组建如何监听值 29.宏任务和微任务 30.es class类和继承 31.深拷贝实现 32。写出几种会话跟踪用户的方法 33.http的method有几种以及各自含义 34.http请求报文中user-agent和referer含义 35.http底层的原理 36.整个工作流程从产品经理接项目开始描述一遍 37.vuex里module具体有什么作用 38.路由hstory，会报404错误怎样解决 39.当表单提交文件的时候，用什么属性和参数 40.promise并行和串行执行 41.说说数据结构和算法 42.怎样实现数据加密。 43.降幂怎么做 44.less和cass区别 45.去重方法 46.异步请求放在created和munted中有啥区别？ 47.promise的then什么场景？ 48.什么是cookie，什么是持久cookie？ 49.es7新增技术点 50.ajax发送请求之后，中间想停止如何停止 51.axios发送请求之后，中间想停止如何停止 52.vue设计模式 53.vue数据跟新之后，视图没有更新，怎样解决 渐进增强和优雅降级的区别 "},{"title":"vue3","date":"2022-07-14T15:52:06.369Z","url":"/2022/07/14/VUE3/","tags":[["Vue","/tags/Vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Vue3 新特性: 数据响应式，ES6的proxy代替了ES5的object.defineProperty -解决了对象数组更新后的检测，优化了监听响应式的性能-原监听对象属性的变化，需要一个个对属性递归监听，现在是proxy将整个对象劫持2. 虚拟dom新算法，更小，更快3. 提供了组合式api，能更好的逻辑复用4. template 模板可以有多个根元素5. 源码用 typescript 重写, 有更好的类型推导(类型检测更为严格, 更稳定) 生命周期 组合式api的生命周期钩子比配置项的生命周期钩子优先执行 setup 优先于beforeCreate执行 组合式API： setup 函数特点 组合式api的使用，需要配置一个setup 函数 从生命周期来看，setup在beforeCreate之前执行 在template 模板中使用的数据和函数，需要在setup返回 setup 中不能使用 this, this 指向 undefined setup里的数据是普通数据，不是响应式的 注意，从 setup 返回的 refs 在模板中访问时是被自动浅解包的，因此不应在模板中使用 .value reactive 将复杂类型的数据转换成响应式数据（ 返回该对象的响应式代理 ），通常用来定义响应式对象数据 reactive 函数需要按需导入才能使用 ref 基本类型，包裹一层对象, 转换成响应式。 在 setup 函数中, 通过 value 属性,才可以访问到 ref 对象的值 在模板中, ref 可以直接使用, 不需要额外的 .value ref 函数也支持传入复杂类型，传入复杂类型，也会做响应式处理 基本类型的数据，响应式使用object.defineProperty()的get和set完成 对象类型的数据，内部求助reactive，基于proxy实现代理 toRef 使用 toRef函数 , 将 reactive 函数的响应式对象中的指定属性转换为响应式数据 语法 : toRef(参数1, 参数2)参数1 : 目标对象,必须是 响应式对象参数2 : 指定变成响应式对象的属性 toRefs 注意:对一个响应数据, 进行 解构 或者 展开, 会丢失他的响应式特性（原因 : vue3 底层是对 对象 进行监听劫持） 作用:对一个 响应式对象 的所有内部属性, 都做响应式处理, 保证展开或者解构出的数据也是响应式的( 一般配合 reactive 使用) computed函数 计算属性 watch函数 -监视属性,既要指明监视的属性，也要指明监视的回调 watchEffect函数 -监视属性,不指明监视的属性，监视的回调中用到哪个属性，那就监视哪个属性 shallowReactive与shallowRef shallowReactive 只处理对象最外层属性（第一层数据）的响应式（浅响应式） shallowRef 只处理基本类型的响应式，不进行对象的响应式处理 使用场景？ 如果有一个对象的数据，结构比较深，但变化时只是外层属性变化，就选择用 shallowReactive 如果有一个对象的数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换，就选择使用 shallowRef readonly与shallowReadonly readonly 让一个响应式数据变为只读（深只读） shallowReadonly 让一个响应式数据变为只读（浅只读） toRaw与markRaw toRaw 将一个reative生成的响应式对象转化为普通对象 场景：用于读取一个响应式对象对应的普通对象，这个普通对象的修改不会引起页面的更新 markRaw 标记一个对象，使其永远不能成为响应式对象 场景：有些值不应该设置为响应式，如复杂的第三方库，当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能 customRef 创建一个自定义的ref 场景：实现防抖效果 provide与inject 实现祖与后代组件间的通信 父组件使用provide传递数据，子组件使用inject接收数据 祖父 儿子 孙子 其他 响应式数据的判断 isRef 检查一个值是否是ref对象 isReactive 检查一个对象是否是由reactive创建的响应式代理 isReadonly 检查一个对象是否是只读 Teleport 能够将组件html结构移动到指定位置 Suspense 等待异步组件时渲染一些额外的内容，让应用有更好的用户体验 父 -子 自定义hook hook\\usePoint.js test.vue Fragment vue3中组件可以没有根标签，内部会将多个标签包含在一个Fragment的虚拟元素中 好处: 减少标签层级，减小内存占用 见文档  "},{"title":"尚硅谷react课程笔记","date":"2022-03-19T15:00:15.182Z","url":"/2022/03/19/%E5%B0%9A%E7%A1%85%E8%B0%B7react%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","tags":[["react","/tags/react/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"005 jsx语法规则 009 函数式组件 010 类"},{"title":"随手记","date":"2021-11-01T14:07:34.312Z","url":"/2021/11/01/%E9%9A%8F%E6%89%8B%E8%AE%B0/","tags":[["零零散散","/tags/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/"]],"categories":[["零散知识","/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/"]],"content":" 将json对象转化为json字符串，再判断该字符串是否为”{}” css cursor中鼠标悬停禁用样式 vue el-input 标签只能输入纯数字链接： 可以通过给input 添加onkeyup事件来实现当输入值的键盘抬起时触发这个事件。this.value表示此输入框的值，/\\D/g为正则表达式，用来匹配所有非数字字符；此句功能为：将输入值为非数字的字符替换为空；当输入值的键盘抬起时触发这个事件。this.value表示此输入框的值，/\\D/g为正则表达式，用来匹配所有非数字字符；"},{"title":"正则测试网址","date":"2021-11-01T14:04:11.007Z","url":"/2021/11/01/%E6%AD%A3%E5%88%99/","tags":[["正则校验","/tags/%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C/"]],"categories":[["正则","/categories/%E6%AD%A3%E5%88%99/"]],"content":"正则  0-12的数： ^([0-9]|1[0-2])$ 2~4个汉字：@”^[\\u4E00-\\u9FA5]{2,4}$” 0-12的数字及中文零到十二： ^([0-9]|1[0-2]|[零一二三四五六七八九十]|十[一二])$"},{"title":"js 手机号码和电话号码（座机号）正则校验","date":"2021-11-01T14:01:52.049Z","url":"/2021/11/01/js%20%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E5%92%8C%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%EF%BC%88%E5%BA%A7%E6%9C%BA%E5%8F%B7%EF%BC%89%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C/","tags":[["正则校验","/tags/%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C/"]],"categories":[["正则","/categories/%E6%AD%A3%E5%88%99/"]],"content":"区号+座机号码+分机号码：regExp=”^(0[0-9]{2,3}-)?([2-9][0-9]{6,7})+(-[0-9]{1,6})?$”简化regExp=”^(0\\d{2,3}-)?([2-9]\\d{6,7})+(-\\d{1,6})?$” 手机号：regExp=”^(((+86)|(+86-))|((86)|(86-))|((0086)|(0086-)))?1[3|5|7|8]\\d{9}$”简化regExp=”^((+86|+86-)|(86|86-)|(0086|0086-))?1[3|5|7|8]\\d{9}$”————————————————版权声明：本文为CSDN博主「刺心疯」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接："},{"title":"浏览器的工作原理","date":"2021-10-18T09:23:50.929Z","url":"/2021/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E6%96%B0%E5%BC%8F%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%95%E5%90%8E%E6%8F%AD%E7%A7%98/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"浏览器的工作原理：新式网络浏览器幕后揭秘  浏览器的主要组件为 (1.1)： 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 多进程浏览器结构 浏览器进程（控制chrome浏览器除标签外的用户界面，包括地址栏、书签、后退、前进按钮以及负责与浏览器的其他进程协调工作）、缓存进程、网络进程（负责发起网络请求）、渲染器进程（控制显示tab标签内的所有内容，每个标签页创建一个渲染进程）、GPU进程（复制整个浏览器界面的渲染）、插件进程（负责控制网站使用的所有插件，如flash） 渲染器进程接收到数据也就是HTML，渲染器主进程解析HTML，构造DOM数据结构。HTML首先经过tokeniser标记化，通过词法分析将输入的HTML内容，解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构造中会创建document对象，然后以document为根节点的DOM树，不断进行修改，将其中添加各种元素（如图片、css、js等）图片和css需要通过网络下载或缓存加载，这些资源不会阻塞html的解析，因为它们不会影响DOM的生成。但解析过程遇到script标签时就会停止HTML解析流程，转而去加载解析并执行js 如果js代码里调用了document.write来修改HTML，那么之前的HTML解析就没有意义了，因此要把script标签放在合适的位置或者使用async或defer属性来异步加载js Layout Tree是根据DOM和计算好的样式来生成，Layout Tree是和展示在页面上的节点是对应的，因此display:none在DOM上，而不在Layout Tree上，div::before{content:”objtube”}伪类中添加的content元素在Layout Tree上而不在在DOM树里 总体流程：浏览器进程中的网络线程请求获取到HTML数据后，通过IPC将数据传给渲染进程的主线程，主线程将HTML解析构造成DOM树，然后进行往事计算，根据DOM树和样式生成Layout Tree，通过遍历Layout Tree生成绘制顺序表（paint），接着遍历Layout Tree生成Layer Tree,然后主线程将Layer Tree和绘制顺序信息一起传给合成器线程，合成器线程按规则进行分图层，并把图层分为更小的图块（tiles）传给栅格进程进行栅格化，栅格化完成合成器线程会获得栅格线程传过来的draw quads图块信息，根据这些信息合成器线上合成一个合成器帧，然后将该合成器帧通过IPC传回给浏览器进程，浏览器进程在传到GPU进行渲染，最后展示在屏幕上。 重排和重绘、js都会占用主进程。反复重排和重绘可能会导致掉帧，因为有可能js执行阻塞了主线程。 优化：requestAnimationFrame()会在每一帧被调用；Transform动画直接运行在合成器线程上。 "},{"title":"egg","date":"2021-09-20T14:35:44.871Z","url":"/2021/09/20/egg.js/","tags":[["egg","/tags/egg/"]],"categories":[["Node","/categories/Node/"]],"content":"egg.js参考教程视频  egg.js 的特性:1、提供基于 Egg 定制上层框架的能力2、高度可扩展的插件机制3、内置多进程管理 4、基于 Koa 开发，性能优异5、框架稳定，测试覆盖率高6、渐进式开发 创建egg的环境npm i egg-init -g(只需要安装一次) 创建项目终端cd 到项目要放置的路径中（注意目录最好是不要用中文 不要有空格） ​ egg-init 项目名称 –type=simple 创建项目 如： egg-init eggdemo01 --type=simple cd到项目目录下，cd eggdemo01 安装依赖 npm install， 安装成功后直接执行npm run dev， 默认端口是7001，然后在浏览器中打开localhost:7001 如果出现如下图所示就说明初始化项目成功了，如果安装依赖失败那么可以强制npm清理一下缓存npm cache clean –force然后再安装，如果还是报错可以翻墙到外面再试下。 vs插件市场eggjs 路由路由不需要引入，可直接使用 egg是一个MVC的框架： view 视图 模板 页面的展示 Controller 控制器 负责处理一些业务逻辑 model 模型（service） 和数据库打交道（查询数据库、操作数据库数据 请求数据）(复杂的业务逻辑 以及数据操作) 结构： Controller 控制器 service 服务 extend 扩展 middleware 中间件 获取get传值 动态路由1、在controller的news.js中添加 2、在view的router.js添加 加载模板引擎 视图（view）egg-view-ejs安装 使用 在view中新建news.html 在controller的news.js中添加 运行即可 在页面添加数据 1、在controller的news.js中添加 2、news.html 解决数据冗余若home.js和news.js有相同数据，则将数据封装到service /service/news.js home.js和news.js使用该数据 调用this.service.news.getNewsList(); 控制器（api）的访问 在config.default.js中配置api 可以在service或控制器中直接使用 服务继承Service为了方便egg在this上面绑定以下的方法 this.ctx: 当前请求的上下文 Context 对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。 this.app: 当前应用 Application 对象的实例，通过它我们可以拿到框架提供的全局对象和方法。 this.service：应用定义的 Service，通过它我们可以访问到其他业务层，等价于 this.ctx.service 。 this.config：应用运行时的配置项。 this.logger：logger 对象，上面有四个方法（debug，info，warn，error），分别代表打印四个不同级别的日志，使用方法和效果与 context logger 中介绍的一样，但是通过这个 logger 对象记录的日志，在日志前面会加上打印该日志的文件路径，以便快速定位日志打印位置。 服务创建user服务返回一个对象 可在控制器被调用 也可在另一个服务被调用 在HTML渲染 总结 控制器可以调用服务，一个服务可被多个控制器调用，一个控制器可以调用不同的服务 服务之间可相互调用 注意：服务不能调用控制器，控制器也不能相互调用 //服务的命名规则Service文件必须放在app/service 目录，可以支持多级目录， 访问的时侯可以通过目录名级联访问。app/service/biz/user.js =&gt; ctx. service .biz .userapp/ service/sync_ user.js =&gt; ctx. service . syncUserapp/ service/HackerNews.js =&gt; ctx . service . hackerNews 爬取api接口数据 控制器访问服务 在服务中通过抓取接口返回数据 使用render将获取的数据显示到界面 配置路由router.js 控制器news.js 服务news.js news.html newscontent.html extend Application Context Request Response Helper 新建extend/helper.js 扩展里面引入第三方模块 1、安装 2、使用 在news.html中调用helper.formatTime() 注意：10位的时间戳在JavaScript中被认为是无效的时间戳 ，解决方法将param*1000 调用extend里面扩展的helper方法： 1、在extend/helper.js中增加getHelperData方法 在app/controller/home.js中调用 中间件中间件：匹配路由前、匹配路由完成做的一系列操作。 1、新建middleware/printdate.js中间件 2、在config.default.js中配置中间件 3、给printdate中间件传入的参数 4、打印options 利用中间件屏蔽id： 要屏蔽的id：1、从数据库获取 新建middleware/forbidip.js中间件 配置中间件 2、从参数传入 在config.default.js中配置要屏蔽的id middleware/forbidip.js中间件 post提交数据新建home.html 增加控制器 home.js 增加路由 router.ja Cookie●cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一一个域名的时候共享数据。心●HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另-一个页面，服务器无法认识到这是同一个浏览器在访问同一一个网站。每-一次的访问，都是没有任何关系的。 cookie: 1.可以实现同一个浏览器访问同一个域的时候不同页面之间的数据共享 2、实现数据的持久化(关子浏览器重新打开以后数据还存在) 需求：同一个浏览器访问同一个域，news页面能访问到主页面的值1、在home.js下设置一个值 2、在news.js获取到这个值 3、再将这个值渲染到页面上 4、在news.html页面中打印这个值 需求:实现数据的持久化默认情况:cookies当浏览器关闭以后就销毁了 注意:默认情况下面egg.js里面的cookie没法设置中文 其他参数： 获取时解密 设置中文cookie (encrypt :true) 清除cookie方法1： 方法2： session基于Cookie session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。 当浏览器访问服务器并发送第一次请求时 ,服务器端会创建一个session对象,生成一个类似于key,value的键值对，然后将key(cookie)返回到浏览器(客户)端,浏览器下次再访问时,携带key(cookie) ,找到对应的session(value)。 1、设置 2、获取 设置session的过期时间5s 基于cookie 不建议使用 在config.default.js中的配置 请求1、get请求 2、post请求 3、接口返回值 "},{"title":"flex弹性布局","date":"2021-09-20T14:35:29.900Z","url":"/2021/09/20/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/","tags":[["flex弹性布局","/tags/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"flex弹性布局 采用 Flex 布局的元素，称为 Flex 容器，简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目，简称”项目”。 以下6个属性设置在容器上 flex-direction 决定项目的排列方向 flex-warp 如果一条轴线排不下，如何换行 flex-flow flex-direction和flex-warp的简写形式 justify-content 定义项目在主轴上的对齐方式 align-items 定义项目在交叉轴上的对齐方式 align-content 定义项目在多根轴线上的对齐方式（交叉轴对齐） 以下6个属性设置在项目上 order 定义项目的排列顺序（数值越小，排列越靠前，默认为0） flex-grow 定义项目的放大比例 flex-shrink 定义项目的缩小比例（负值对该属性无效） flex-basis 定义了在分配多余空间之前，项目占据的主轴空间 （它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。） flex 是flex-grow，flex-shrink，flex-basis的简写，后两个属性可选 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 （表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。） （完） 参考地址"},{"title":"HTTP响应状态码参考","date":"2021-09-20T14:34:49.510Z","url":"/2021/09/20/HTTP%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%82%E8%80%83/","tags":[["HTTP","/tags/HTTP/"]],"categories":[["HTTP","/categories/HTTP/"]],"content":"HTTP响应状态码参考1xx:信息 2xx:成功 3xx:重定向 4xx:客户端错误 5xx:服务器错误"},{"title":"Node.js","date":"2021-09-20T14:34:19.363Z","url":"/2021/09/20/nodejs/","tags":[["node","/tags/node/"]],"categories":[["Node","/categories/Node/"]],"content":"nodejs nodejs不是语言不是框架是js的一个运行时环境可以解析执行js代码 运行的时候指的是指令加载到内存并由CPU执行的时候 浏览器中的jsEcmaScript(基本语法、if、var、function、Object、Array)BOMDOM node.js中的jsEcmaScript语法 服务端不操作页面（没有BOM、DOM） 核心模块 第三方模块 用户自定义模块 nodejs特性：事件驱动、非阻塞IO模型 核心模块在node这个js执行环境中为js提供了一些服务器级别的操作API，这些API大多数都包装到核心模块中。 例如文件操作的fs核心模块，http服务构建的http模块，path路径操作模块，os操作系统信息模块。。。 所有核心模块在使用的时候都必须手动的先使用require方法来加载，才可以使用。 核心模块本质也是文件。 fs文件操作模块 http网络服务构建模块 服务器用来提供对数据的服务 1、发送请求 2、接收请求 3、处理请求 4、发送响应 解决文字乱码问题服务器默认发送的数据，是utf8编码的内容但浏览器不知道中文操作系统默认是gbk在http协议中，Content-Type是用来告知对方数据内容是什么类型，plain是普通文本不同的资源对应的Content-Type不同一般只为字符数据才指定编码，图片不需要 os操作系统信息模块path路径处理模块 url：统一资源定位符一个url对应一个资源 根据不同的请求路径发送不同的响应结果 响应内容只能是二进制数或字符串 用户自定义模块语法1、导出成员2、外部引入使用 案例模板a.js b.js 导出exports require方法的两个作用：1、用来加载模块并执行里面的代码2、拿到被加载文件模块导出的接口对象 每个文件模块中都提供一个对象：exportsexports默认是一个空对象 在node中，没有全局作用域，只有模块文件作用域，默认文件中所有成员只在当前文件模块有效 导出多个成员（必须在对象中）： 导出单个成员（拿到的就是：函数、字符串） 以下情况会覆盖 也可以这样来导出多个成员 exports原理解析exports是module.exports的一个引用： 当exports重新赋值时，则不等于module.exports里的值，且module.exports里的值不会被改变。 require方法加载规则模块查找机制 优先从缓存中加载 核心模块 路径形式的文件模块 第三方模块 路径形式的模块 ./当前目录 ../上级目录 核心模块 本质也是文件。 核心模块文件已经编译到二进制文件中，只需按照名字加载就可以了 第三方模块 凡是第三方模块都必须通过npm来下载 使用时可以通过require(‘包名’)的方式加载使用 node_modules/art-template/package.json文件中的main属性就记录了art-template的入口模块 实际上最终加载的还是文件 如果package.json不存在或main指定入口模块也没有 则node会自动找该目录下的index.js（index.js就是个默认备选项） 一个项目仅有一个node_modules 且存放在项目根目录 IP地址和端口号的概念 ip地址用来定位计算机 端口号用来定位具体的应用程序 所有需要联网通信的应用程序都会占用一个端口号 端口号的范围从0~65536之间 在计算机中有些端口号，最好不要去使用，例如http服务默认的80 练习的时候使用简单好记的就可以了，如3000、5000等没有什么含义 在一台计算机中，同一个端口号同一时间只能被一个程序占用 服务端渲染和客户端渲染的区别 服务端渲染说白了就是在服务端使用模板引擎 客户端渲染不利于SEO搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以真正的网站是二者结合来做的 例如：京东的商品列表就是采用服务端渲染，目的是为了SEO搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要SEO搜索引擎优化，所以采用的是客户端渲染 Node.js REPL(Read Eval Print Loop:交互式解释器)这个环境的作用只是用来做一些辅助测试：例如可以直接在里面使用node中的核心模块而不需要require加载。 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 Node 自带了交互式解释器，可以执行以下任务： 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 案例模板 / index.html 开放public目录中的静态资源 当请求 /public/xxx 的时候，读取响应 public 目录中的具体资源 /post post.html /tijiao 4.1接收表单提交数据 4.2存储表单提交数据 4.3让表单重定向到 / npm（安装第三方软件） node package manager （node 包管理器） npm是世界上最大的开源库生态系统 绝大多数js相关的包都放在了npm上，为了方便开发人员下载使用 只要安装了node就已经安装了npm npm网站：npmjs.com npm命令行工具查看版本号可以在命令行输入: 升级npm: 常用命令 npm init -y 可以跳过向导，快速生成package.json npm install 一下子把dependencies中的依赖项全部安装 npm install 包名 只下载 简写 npm i 包名 npm install --save 包名 下载并保存依赖项 简写 npm i -S 包名 npm uninstall 包名 只删除，如果有依赖项会依然保存 简写npm un 包名 npm uninstall --save 包名 删除的同时也会把依赖信息去除 简写npm un -S 包名 npm help 查看使用帮助 npm 命令 --help 查看指定命令的使用帮助 解决npm被墙问题npm存储包文件的服务器在国外，有时候会被墙，速度很慢 淘宝的开发团队把npm在国内做了一个备份 安装淘宝的cnpm: 接下来你安装包的时候把之前的npm换成cnpm 举个例子 package.json 建议每个项目都要有一个package.json文件(包描述文件) 可以通过npm init的方式自动初始化出来 建议执行npm install 包名的时候都加上--save这个选项，目的是用来保存依赖项信息 如果node_modules删除了，只需要npm install就会自动把package.json中的dependencies中所有的依赖项都下载回来 nrm npm自定义脚本命令 日期处理模块 nodemon自动重启工具安装 传送门： Express安装 hello world 修改完成代码自动重启我们可以使用一个第三方命令行工具，nodemon来帮助解决修改代码重启服务器问题。 安装完毕后使用： 它会监视你的文件变化。 检验是否安装成功： 基本路由路由器 请求方法 请求路径 请求处理函数 get： post: 静态服务 在Express中配置使用art-template模板引擎安装： 配置： 使用： 如果希望修改默认的views视图渲染存储目录，可以： 在Express获取表单get请求数据Express内置了一个API，可以直接通过req.query来获取 在Express获取表单post请求数据在Express中没有内置获取表单post请求体的API，需要使用第三方包body-parser 安装： 配置： 使用： MongoDBMongoDB数据库的基本概念 可以有多个数据库 一个数据库中可以有多个集合（表） 一个集合中可以有多个文档（表记录） 文档结构很灵活，没有任何限制 MongoDB非常灵活，不需要像MySQL一样先创建数据库、表、设计表结构 在这里只需要，当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了 建库建表由MongoDB自动帮你完成 关系型数据库和非关系型数据库表就是关系 或者说表与表之间存在关系 所有关系型数据库都需要通过sql语言来操作 所有关系型数据库在操作之前都需要设计表结构 而且数据表还支持约束 唯一的 主键 默认值 非空 非关系型数据库非常灵活 有的非关系型数据库就是key-value对儿 但MongoDB是长的最像关系型数据库的非关系型数据库 数据库-》数据库 数据表-》集合（数组） 表记录-》（文档对象） MongoDB不需要设计表结构 安装 下载 安装 配置环境变量 最后输入mongod --version检测是否安装成功 启动和关闭数据库 启动： 停止： 连接和退出数据库连接: 退出： 基本命令 show dbs 查看显示所有数据库 db 查看当前操作的数据库 use 数据库名称 切换到指定的数据（如果没有会新建） hello word 官方指南官方文档：  设计Scheme 发布Model 增加数据 查询所有 按条件查询所有 按条件查询单个 删除数据 更新数据 使用Node操作MySQL数据库安装： 使用： "},{"title":"Uni app 页面&组件生命周期","date":"2021-09-20T14:33:51.924Z","url":"/2021/09/20/Uni%20app%20%E9%A1%B5%E9%9D%A2&%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"Uni app 页面&amp;组件生命周期不论是app还是小程序，生命周期是非常重要的知识点。 uni-app 支持如下生命周期函数： 页面的生命周期onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为object（用于页面传参）onShow 监听页面显示onReady 监听页面初次渲染完成onHide 监听页面隐藏onUnload 监听页面卸载onPullDownRefresh 监听用户下拉动作onReachBottom 页面上拉触底事件的处理函数onShareAppMessage 用户点击右上角分享 微信小程序onPageScroll 监听页面滚动onTabItemTap 当前是 tab 页时，点击 tab 时触发。 组件的生命周期beforeCreate：组件初始化，但数据原生观测、自定义观测(event\\watcher)没生成之前。 未完全创建阶段created：组件创建后，但还未挂载 完全创建阶段beforeMount：组件渲染后，挂载前。 渲染后待挂载mounted： 组件挂载到页面 可用 vm.$el 访问 挂载OKbeforeUpdate： 虚拟 DOM 重新渲染和打补丁之前 再次渲染前updated ： 组件 DOM 已经更新 再次渲染后activated： keep-alive 组件激活时调用。 当前组件被激活：显示deactivated： keep-alive 组件停用时调用。 当前组件隐藏beforeDestroy： 实例销毁之前调用。实例仍然完全可用。 销毁前destroy： Vue 实例销毁后调用补充：1.挂载阶段，先渲染组件，然后挂载组件。"},{"title":"vscode npm 配置cnpm不可用","date":"2021-09-20T14:33:27.451Z","url":"/2021/09/20/vscode%20npm%20%E9%85%8D%E7%BD%AEcnpm%E4%B8%8D%E5%8F%AF%E7%94%A8/","tags":[["npm","/tags/npm/"]],"categories":[["Vue","/categories/Vue/"]],"content":"vscode npm 配置cnpm不可用在powershell 中输入 get-ExecutionPolicy 默认是Restricted(禁用) 输入set-ExecutionPolicy 输入RemoteSigned 即可"},{"title":"vuejs和jquery可以混着用吗","date":"2021-09-20T14:33:15.644Z","url":"/2021/09/20/vuejs%E5%92%8Cjquery%E5%8F%AF%E4%BB%A5%E6%B7%B7%E7%9D%80%E7%94%A8%E5%90%97/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"vuejs和jquery可以混着用吗1、Vue 的官方是不建议直接操作 DOM 的，Vue 的用途在于视图和数据的绑定。如果通过JQuery 直接操作 DOM 的话，势必会造成视图数据和模型数据的不匹配，这样 Vue 就失去它存在的意义了； 2、JQuery 和 VueJS 合理使用并不会造成冲突，因为他们的侧重点不同，VueJS 侧重数据绑定和视图组件，JQuery 侧重异步请求和动画效果。如果使用JQuery + VueJS 开发，一定要在 Vue 渲染完所有的 HTML组件之后再通过 JQuery 处理，而使用 JQuery 时应避免直接操作 DOM ，但是应用动画是允许的； 3、JQuery 与 VueJS 相互配合可以非常高效的完成异步任务，首先通过 JQuery 发出 Ajax 请求，接受到服务端传递的 JSON 数据后，再通过 Vue 将数据绑定到组件上，最后由 JQuery 进行动画处理，整个过程就如行云流水般自然； 4、说句题外话，Vue 的目的不是取代 JQuery，它是为了解决前后端分离而出现的。如果没有数据变化，只是单纯的样式变化，则没有必要去大费周章进行视图模型的绑定，并且还不利于 SEO 优化。"},{"title":"在vue的脚手架中添加bootstrap","date":"2021-09-20T14:33:12.040Z","url":"/2021/09/20/vue%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0bootstrap/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"在vue的脚手架中添加bootstrap参考网址：   一、在项目的根目录下创建vue.config.js 关键代码： 二、在main.js中引入jquery、bootstrap 三、在.eslintrc.js中添加jquery: true 解决有些bootstrap的样式失效问题： 查看bootstrap的版本，添加bootstrap对应的版本代码 "},{"title":"在vue项目/uniapp中使用md5加密","date":"2021-09-20T14:33:02.196Z","url":"/2021/09/20/vue%E9%A1%B9%E7%9B%AEuniapp%E4%B8%AD%E4%BD%BF%E7%94%A8md5%E5%8A%A0%E5%AF%86/","tags":[["vue","/tags/vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"在vue项目/uniapp中使用md5加密在根目录下安装MD5模块npm install js-md5 -D在项目中引入md5模块 import md5 from &#39;js-md5&#39;; 使用md5();"},{"title":"解决wamp服务器离线的几种方法","date":"2021-09-20T14:32:55.137Z","url":"/2021/09/20/%E8%A7%A3%E5%86%B3wamp%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A6%BB%E7%BA%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","tags":[["wamp","/tags/wamp/"]],"categories":[["其他","/categories/%E5%85%B6%E4%BB%96/"]],"content":"1.文件名不能是中文2.apache里的http.conf的80改成8080端口3.防护墙里的高级设置里的入站规则里的apache HTTP Server改为启用4.切换到在线状态"},{"title":"微信小程序mina","date":"2021-09-20T14:32:30.866Z","url":"/2021/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fmina/","tags":[["微信小程序","/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["微信小程序","/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"content":"微信小程序mina参考代码工程mina-show-goods 参考教程视频 在线接口文档 使用阿里icon图标1、建立styles/iconfont.wxss文件复制Font class 生成的代码 2、在app.wxss中全局引用 在微信小程序中 不支持 通配符正确用法 存在 变量这个知识1、定义颜色 2、使用颜色 使用组件1、在components创建组件SearchInput 2、在要使用的页面index.json中引入组件 3、在index.wxml中使用组件 wx:forwx:for 这个是正常的循环，没什么可说的。 wx:for-item=‘变量名（随便起的）’ 它是指定循环数据当前的变量名，可以通过 展示数组的元素。 wx:for-index=‘变量名（随便起）’，它是指向当前元素的下标名，可以在其他事件中定义自定义事件（data-xxx=’‘，，该自定义属性可以在参数e下面打印出来）获取该下标。 web中的本地存储和小程序中的本地存储的区别1:写代码的方式不一样了 web: 小程序中: 2:存的时候有没有做类型转换 web:不管存入的是什么类型的数据，最终都会先调用以下toString(), 把数据变成了字符串再存入进去 小程序:不存在类型转换的这个操作存什么类似的数据进去，获取的时候就是什么类型 onLoad中的options参数小程序页面加载的时候，可以通过options获取到上一个页面标签的属性以及属性值 wx:key=”*this”*this 代表for循环中的 item 本身 性能优化原： 大量的请求没有使用过的数据，会降低小程序的性能,使小程序加载缓慢 改： 足个提取要请求的数据，减少请求数据量 iPhone部分手机 不识别webp图片格式webp图片格式体积小质量高 但iPhone部分手机 不识别webp图片格式。 最好找到后台 让他进行修改； 临时自己改 确保后台存在 1.webp =&gt; 1.jpg； 使用Array map() 方法来过滤数据map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。它的语法是： 因此使用map()方法可以过滤掉一些数据，得到你想要的数据。 如： 点击轮播图放大预览bindtap绑定事件 自定义data-url=”” 接收传递过来的图片url 总js代码 可解构 使用button，但不改变view的样式 蒙版在tool_item里添加button 使用绝对定位，让button和父元素一样大小，覆盖在父元素上 "},{"title":"关于hexo","date":"2021-09-20T14:23:09.103Z","url":"/2021/09/20/%E5%85%B3%E4%BA%8Ehexo/","tags":[["hexo","/tags/hexo/"]],"categories":[["Hexo","/categories/Hexo/"]],"content":"1.官方主题 2.使用hexo+github搭建博客详细教程  3.常用hexo命令常见命令hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传"},{"title":"收录一些醍醐灌顶的知识","date":"2021-09-20T14:18:18.967Z","url":"/2021/09/20/%E6%94%B6%E5%BD%95%E4%B8%80%E4%BA%9B%E9%86%8D%E9%86%90%E7%81%8C%E9%A1%B6%E7%9A%84%E7%9F%A5%E8%AF%86/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"]],"content":"1.深拷贝和浅拷贝详解 2.对于JavaScript原生的JS 3.Vue 超清晰思维导图 4.原型–面向对象ES6\\1. 面向对象和面向过程 2. ES6 类语法 3. 继承 4. 面向对象案例 5. 原型和原型链 6. 组合继承 7. 严格模式 8. 闭包 9. 递归函数 10. 深拷贝浅拷贝 11. 高阶函数 12. call、apply、bind 13. ES6 14. 对象解构 15. 箭头函数 16. 扩展运算符 17. 模板字符串 5.图片下载跨域问题、图片展示缓存问题 6.添加this.$forceUpdate();进行强制渲染，效果实现。因为数据层次太多，render函数没有自动更新，需手动强制刷新。"},{"title":"css随笔","date":"2021-09-20T14:12:13.712Z","url":"/2021/09/20/css%E9%9A%8F%E7%AC%94/","tags":[["css","/tags/css/"]],"categories":[["CSS","/categories/CSS/"]],"content":"overflow:hidden的作用（溢出隐藏、清除浮动、解决外边距塌陷、margin重叠等等）1.假设一个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0。2.如果加上overflow: hidden，将1个子元素设置高度为400px，另一个设置高度为200px，那么父元素的高度就为400px。3.通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。4.给一个元素中设置overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。5.父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷，因此，给父级元素添加overflow:hidden，就可以解决这个问题了。6.属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠，将其中一个盒子外层加一层父元素div并给父级元素添加overflow:hidden，就可以解决这个问题。 BFC（垂直排列）块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局1.内部的盒子会在垂直方向，一个接一个地放置；2.盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；3.每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；4.BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。5.计算 BFC 的高度时，浮动元素也参与计算。 BFC应用场景1.自适应两栏布局应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。2、清除内部浮动BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。（overflow: hidden;）3、 防止垂直 margin 合并同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。"},{"title":"Koa框架+MongoDB","date":"2021-09-19T15:23:08.914Z","url":"/2021/09/19/Koa%E6%A1%86%E6%9E%B6+MongoDB/","tags":[["koa","/tags/koa/"]],"categories":[["Node","/categories/Node/"]],"content":"Koa框架+MongoDB教学视频参考 mongodb启动先管理员运行net start MongoDB 再到D:\\MongoDB\\bin中启动mongo.exe 搭建本地服务器先安装node 再项目初始化 ——————–package.json 安装koa 和 koa-router 成功后可在package.json看到 在package.json中更改入口文件 新建app.js 在package.json中配置启动命令 运行npm run server或npm run start启动项目 连接MongoDB数据库首先安装mongoose 在app.js中引入mongoose 再连接数据库 成功后打印Mongodb Connectd… 可进行优化： 1、创建config/key.js 2、引入 3、连接 创建测试接口创建routes/api/users.js 用户信息文件 在app.js中指定路由地址 1、引入 2、配置路由地址 最后访问localhost:5000/api/users/test 可以看到{“msg”:”users works..”} 配置用户模型创建models/Users.js 在routes/api/users.js下引入User 注册接口和调试工具Postman安装koa-bodyparser 1、在app.js中引入 2、使用 在routes/api/users.js中做post请求 可以在Postman中看到返回的json数据 可给密码加密用bcryptjs 1、在routes/api/users.js引入 2、使用 全球公认头像1、安装 2、在routes/api/users.js中使用 同步加密封装因为之前的异步加密使用了两次异步，数据库里的密码还是明文 所以改用同步 创建config/tools.js 在routes/api/users.js中 返回json数据 登录接口在routes/api/users.js中 生成token1、安装jsonwebtoken 2、在routes/api/users.js中引用 优化 在config/keys.js中添加secret 返回json数据 koa-passport验证token安装 在package.json中可看到 在app.js入口文件中使用 创建config/passport.js 安装passport-jwt 在config/passport.js中使用 在routes/api/users.js中填写获取用户信息接口 使用validator验证表单安装 创建validator/register.js 创建validator/is-empty.js 在routes/api/users.js中引入input验证 并在注册接口地址中添加 验证登录和注册的input在validator/register.js中 创建validator/login.js 在routes/api/users.js中引入input验证 并在登录接口地址中添加 "},{"title":"Hello World","date":"2021-09-19T12:17:04.661Z","url":"/2021/09/19/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]