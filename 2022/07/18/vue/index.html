<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>vue | 琼喵酱·部落</title>
  <meta name="author" content="zengqm" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Vue" />
  
  <meta name="description" content="vue1.v-show和v-if区别 123456v-show通过css display控制显示和隐藏，v-if组件真正的渲染和销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-ifv-if 常用于一次性改变，如根据权限决定是否显示v-show 用于 tabs 切换v-if 可与 templete块连用 ，v-show 不支持 &lt;template&gt; 元素，也不支持 v-el">
<meta property="og:type" content="article">
<meta property="og:title" content="vue">
<meta property="og:url" content="http://example.com/2022/07/18/vue/index.html">
<meta property="og:site_name" content="琼喵酱·部落">
<meta property="og:description" content="vue1.v-show和v-if区别 123456v-show通过css display控制显示和隐藏，v-if组件真正的渲染和销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-ifv-if 常用于一次性改变，如根据权限决定是否显示v-show 用于 tabs 切换v-if 可与 templete块连用 ，v-show 不支持 &lt;template&gt; 元素，也不支持 v-el">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2022-07-18T14:09:42.585Z">
<meta property="article:modified_time" content="2022-07-18T14:36:27.414Z">
<meta property="article:author" content="zengqm">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/banner.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">琼喵酱·部落</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>琼喵酱·部落</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">vue</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2022-07-18</li>
                <li><i class="fa fa-user"></i> 作者 zengqm</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~97.59K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1658154987414"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vue"><span class="toc-number">1.</span> <span class="toc-text">vue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-html%E3%80%81css"><span class="toc-number">2.</span> <span class="toc-text">3.html、css</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-html5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86HTML5%E6%96%B0%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">1.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%9F%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">2.行内元素和块级元素的区别？什么是重绘和回流？两者区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CSS-%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">3.CSS 选择符有哪些？优先级算法如何计算？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-CSS3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">4.CSS3有哪些新特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%A7%A3%E9%87%8A%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%AE%BD%E9%AB%98%E5%80%BC%E5%BE%97%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BE%B9%E7%95%8C%E5%A1%8C%E9%99%B7%EF%BC%8C%E8%B4%9F%E5%80%BC%E4%BD%9C%E7%94%A8%EF%BC%8Cbox-sizing%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">5.解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%AE%80%E8%BF%B0flex%E5%B8%83%E5%B1%80"><span class="toc-number">2.0.0.6.</span> <span class="toc-text">6.简述flex布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-css-%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9Fposition%E5%AE%9A%E4%BD%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.0.7.</span> <span class="toc-text">7.css 隐藏元素有哪几种方法？position定位有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-BFC%EF%BC%88Block-Formatting-Context%EF%BC%89-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">2.0.0.8.</span> <span class="toc-text">8.BFC（Block Formatting Context） 是什么？应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%A7%A3%E9%87%8A%E4%B8%8B%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%83%E7%9A%84%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98%EF%BC%9F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%884%E7%A7%8D%EF%BC%89"><span class="toc-number">2.0.0.9.</span> <span class="toc-text">9.解释下浮动和它的遗留问题？清除浮动的方法（4种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%93%AA%E4%BA%9B%E5%A4%96%E8%BE%B9%E8%B7%9D%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F%E9%98%B2%E6%AD%A2%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.0.0.10.</span> <span class="toc-text">10.哪些外边距不重叠的情况？防止外边距重叠的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">2.0.0.11.</span> <span class="toc-text">11.如何让一个盒子水平垂直居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%B7%A6%E5%8F%B3%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E5%9C%A3%E6%9D%AF%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E3%80%81%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E2%80%A6%EF%BC%89"><span class="toc-number">2.0.0.12.</span> <span class="toc-text">12.左右固定中间自适应 三栏布局（圣杯、双飞翼、弹性盒子…）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%9D%99%E6%80%81%E5%B8%83%E5%B1%80%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%88rem%E3%80%81em%EF%BC%89"><span class="toc-number">2.0.0.13.</span> <span class="toc-text">13.静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B8%83%E5%B1%80%EF%BC%88Static-Layout%EF%BC%89"><span class="toc-number">2.0.0.13.1.</span> <span class="toc-text">静态布局（Static Layout）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-less%E3%80%81sass%E3%80%81-stylus%E5%88%86%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">2.0.0.14.</span> <span class="toc-text">14.less、sass、 stylus分别都有哪些优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9C%A8IE%EF%BC%88IE6%EF%BC%89%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.0.15.</span> <span class="toc-text">15.说一下在IE（IE6）中常见的几个兼容性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E6%B8%85%E7%A9%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.0.16.</span> <span class="toc-text">16.清空数组的方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-js"><span class="toc-number">3.</span> <span class="toc-text">4.js</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%A0%E5%81%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%B5%81%E8%A7%88%E5%99%A8%E6%B5%8B%E8%AF%95%E8%BF%87%EF%BC%9F%E8%BF%99%E4%BA%9B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.0.0.0.1.</span> <span class="toc-text">1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%A0%E7%AE%80%E8%BF%B0%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.0.0.0.2.</span> <span class="toc-text">2.你简述盒模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-CSS3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.0.0.0.3.</span> <span class="toc-text">3.CSS3的新特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.0.0.0.4.</span> <span class="toc-text">4.CSS选择器及其优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4BFC"><span class="toc-number">3.0.0.0.5.</span> <span class="toc-text">5.说说BFC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4%E5%AE%9A%E4%BD%8D%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.0.0.0.6.</span> <span class="toc-text">6.说说定位相关的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%B0%88%E8%B0%88flex%E5%B8%83%E5%B1%80"><span class="toc-number">3.0.0.0.7.</span> <span class="toc-text">7.谈谈flex布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E4%BD%A0%E6%80%8E%E4%B9%88%E6%B8%85%E6%A5%9A%E6%B5%AE%E5%8A%A8"><span class="toc-number">3.0.0.0.8.</span> <span class="toc-text">8.你怎么清楚浮动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E4%B8%A4%E8%BE%B9%E5%AE%BD%E5%BA%A6%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80-%E9%BB%98%E5%86%99%E9%A2%98-%E6%89%8B%E5%86%99%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">3.0.0.0.9.</span> <span class="toc-text">9.两边宽度固定中间自适应的三栏布局(默写题,手写笔试题)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="toc-number">3.0.0.0.10.</span> <span class="toc-text">10.浏览器渲染机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.0.0.11.</span> <span class="toc-text">11.重绘和回流的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.0.0.12.</span> <span class="toc-text">12.JS数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-JS%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.0.0.13.</span> <span class="toc-text">13.JS判断数据类型的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.0.0.14.</span> <span class="toc-text">14.null和undefined区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.0.0.0.15.</span> <span class="toc-text">15.JS作用域的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-call-apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%B5%81%E8%A7%88%E5%99%A8%E6%B5%8B"><span class="toc-number">3.0.0.0.16.</span> <span class="toc-text">16.call,apply和bind区别的页面在哪些流览器测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.0.0.0.17.</span> <span class="toc-text">17.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-%E8%B0%88%E8%B0%88%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">3.0.0.0.18.</span> <span class="toc-text">18.谈谈防抖和节流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-%E8%B0%88%E8%B0%88cookie-sessionStorage%E5%92%8ClocalStorage"><span class="toc-number">3.0.0.0.19.</span> <span class="toc-text">19.谈谈cookie,sessionStorage和localStorage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-0-1-0-2-0-3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">3.0.0.0.20.</span> <span class="toc-text">20.0.1+0.2!&#x3D;0.3怎么处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA8%E4%B8%AA"><span class="toc-number">3.0.0.0.21.</span> <span class="toc-text">21.数组的常用方法(至少说出8个)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%90%97"><span class="toc-number">3.0.0.0.22.</span> <span class="toc-text">22.new一个对象的过程中发生了什么吗?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.0.0.23.</span> <span class="toc-text">24.get和post区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-JSONP%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.0.0.24.</span> <span class="toc-text">25.JSONP原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-%E7%BC%93%E5%AD%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.0.0.0.25.</span> <span class="toc-text">26.缓存的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27-XSS%E5%92%8CCSRF%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.0.0.26.</span> <span class="toc-text">27.XSS和CSRF区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.0.0.27.</span> <span class="toc-text">28.HTTP与HTTPS的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.0.0.0.28.</span> <span class="toc-text">29.HTTP状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30-%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E3%80%81%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.0.0.0.29.</span> <span class="toc-text">30.事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31-Js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">3.0.0.0.30.</span> <span class="toc-text">31.Js事件循环机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">3.0.0.0.31.</span> <span class="toc-text">32.面向对象、原型、原型链、继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">3.0.0.0.32.</span> <span class="toc-text">33.什么是闭包，使用场景及优缺点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34-this%E6%8C%87%E5%90%91"><span class="toc-number">3.0.0.0.33.</span> <span class="toc-text">34.this指向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.0.0.0.34.</span> <span class="toc-text">35.箭头函数和普通函数的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#36-%E4%BB%80%E4%B9%88%E6%98%AFpromise"><span class="toc-number">3.0.0.0.35.</span> <span class="toc-text">36.什么是promise?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#37-%E4%BB%80%E4%B9%88%E6%98%AFajax%EF%BC%9F"><span class="toc-number">3.0.0.0.36.</span> <span class="toc-text">37.什么是ajax？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">5.兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81IE8-%E4%B8%8B%E9%9D%A2%E7%9A%84-png-%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%EF%BC%9F"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">1、IE8 下面的 png 图片无法正常显示？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81rgba-%E4%B8%8D%E6%94%AF%E6%8C%81-IE8%EF%BC%9F"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">2、rgba 不支持 IE8？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Css3-%E7%9A%84%E6%96%B0%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">3、Css3 的新属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81document-form-item-%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">4、document.form.item 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E9%9B%86%E5%90%88%E7%B1%BB%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.5.</span> <span class="toc-text">5、集合类对象问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81window-event-event"><span class="toc-number">4.0.0.6.</span> <span class="toc-text">6、window.event || event</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81HTML-%E5%AF%B9%E8%B1%A1%E7%9A%84-id-%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.7.</span> <span class="toc-text">7、HTML 对象的 id 作为对象名的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E7%94%A8-idName-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%96%E5%BE%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.8.</span> <span class="toc-text">8、用 idName 字符串取得对象的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%8F%98%E9%87%8F%E5%90%8D%E4%B8%8E%E6%9F%90-HTML-%E5%AF%B9%E8%B1%A1-id-%E7%9B%B8%E5%90%8C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.9.</span> <span class="toc-text">9、变量名与某 HTML 对象 id 相同的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81event-x-%E4%B8%8E-event-y-%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.10.</span> <span class="toc-text">10、event.x 与 event.y 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81-%E5%8F%96%E5%BE%97%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.0.0.11.</span> <span class="toc-text">11、 取得元素的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81const-%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.12.</span> <span class="toc-text">12、const 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81body-%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.0.0.13.</span> <span class="toc-text">13、body 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81url-encoding"><span class="toc-number">4.0.0.14.</span> <span class="toc-text">14、url encoding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81nodeName-%E5%92%8C-tagName-%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.15.</span> <span class="toc-text">15、nodeName 和 tagName 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">4.0.0.16.</span> <span class="toc-text">16.元素属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%B0%83%E7%94%A8%E5%AD%90%E6%A1%86%E6%9E%B6%E6%88%96%E8%80%85%E5%85%B6%E5%AE%83%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.17.</span> <span class="toc-text">17.调用子框架或者其它框架中的元素的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%AF%B9%E8%B1%A1%E5%AE%BD%E9%AB%98%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.18.</span> <span class="toc-text">18.对象宽高赋值问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-innerText%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.19.</span> <span class="toc-text">19.innerText的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-event-srcElement%E5%92%8Cevent-toElement%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.20.</span> <span class="toc-text">20.event.srcElement和event.toElement问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E7%A6%81%E6%AD%A2%E9%80%89%E5%8F%96%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9"><span class="toc-number">4.0.0.21.</span> <span class="toc-text">21.禁止选取网页内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%8D%95%E8%8E%B7%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.0.0.22.</span> <span class="toc-text">22.捕获事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.23.</span> <span class="toc-text">移动端常见的兼容性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-html5%E8%B0%83%E7%94%A8%E5%AE%89%E5%8D%93%E6%88%96%E8%80%85ios%E7%9A%84%E6%8B%A8%E5%8F%B7%E5%8A%9F%E8%83%BD"><span class="toc-number">4.0.0.23.1.</span> <span class="toc-text">1.html5调用安卓或者ios的拨号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%8A%E4%B8%8B%E6%8B%89%E5%8A%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%97%B6%E5%8D%A1%E9%A1%BF%E3%80%81%E6%85%A2"><span class="toc-number">4.0.0.23.2.</span> <span class="toc-text">2.上下拉动滚动条时卡顿、慢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%86%E8%A7%92bug"><span class="toc-number">4.0.0.23.3.</span> <span class="toc-text">3.圆角bug</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-ios-%E8%AE%BE%E7%BD%AEinput-%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F%E4%BC%9A%E8%A2%AB%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96"><span class="toc-number">4.0.0.23.4.</span> <span class="toc-text">4.ios 设置input 按钮样式会被默认样式覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-IOS%E9%94%AE%E7%9B%98%E5%AD%97%E6%AF%8D%E8%BE%93%E5%85%A5%EF%BC%8C%E9%BB%98%E8%AE%A4%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99"><span class="toc-number">4.0.0.23.5.</span> <span class="toc-text">5.IOS键盘字母输入，默认首字母大写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-h5%E5%BA%95%E9%83%A8%E8%BE%93%E5%85%A5%E6%A1%86%E8%A2%AB%E9%94%AE%E7%9B%98%E9%81%AE%E6%8C%A1%E9%97%AE%E9%A2%98"><span class="toc-number">4.0.0.23.6.</span> <span class="toc-text">6.h5底部输入框被键盘遮挡问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-IOS%E7%A7%BB%E5%8A%A8%E7%AB%AFclick%E4%BA%8B%E4%BB%B6300ms%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94"><span class="toc-number">4.0.0.23.7.</span> <span class="toc-text">7.IOS移动端click事件300ms的延迟响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%9C%A8ios%E5%92%8Candriod%E4%B8%AD-audio%E5%85%83%E7%B4%A0%E5%92%8Cvideo%E5%85%83%E7%B4%A0%E5%9C%A8%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE"><span class="toc-number">4.0.0.23.8.</span> <span class="toc-text">8.在ios和andriod中,audio元素和video元素在无法自动播放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-CSS%E5%8A%A8%E7%94%BB%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%99%BD-%E5%8A%A8%E7%94%BB%E5%8D%A1%E9%A1%BF"><span class="toc-number">4.0.0.23.9.</span> <span class="toc-text">9.CSS动画页面闪白,动画卡顿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-fixed%E5%AE%9A%E4%BD%8D%E7%BC%BA%E9%99%B7"><span class="toc-number">4.0.0.23.10.</span> <span class="toc-text">10.fixed定位缺陷</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-webpack"><span class="toc-number">5.</span> <span class="toc-text">6.webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-Webpack-%E6%89%93%E5%8C%85%E6%97%B6%E9%97%B4"><span class="toc-number">5.0.0.0.1.</span> <span class="toc-text">1、如何减少 Webpack 打包时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-Webpack-%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF"><span class="toc-number">5.0.0.0.2.</span> <span class="toc-text">2、如何减少 Webpack 打包后的文件体积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="toc-number">5.0.0.0.3.</span> <span class="toc-text">3、什么是模块化？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="toc-number">5.0.0.0.4.</span> <span class="toc-text">4、为什么出现模块化？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%9E%84%E5%BB%BA%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.0.0.5.</span> <span class="toc-text">5、构建的作用及常见功能是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">5.0.0.0.6.</span> <span class="toc-text">6、你了解的构建工具有哪些，各自有什么优缺点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bwebpack"><span class="toc-number">5.0.0.0.7.</span> <span class="toc-text">7、简单介绍一下webpack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81Loader%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.0.0.8.</span> <span class="toc-text">8、Loader机制的作用是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81css-loader%E4%B8%8Estyle-loader%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.0.0.0.9.</span> <span class="toc-text">9、css-loader与style-loader的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E9%85%8D%E7%BD%AE-Loader-%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">5.0.0.0.10.</span> <span class="toc-text">10、配置 Loader 时需要注意的地方？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81Plugin%EF%BC%88%E6%8F%92%E4%BB%B6%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.0.0.11.</span> <span class="toc-text">11、Plugin（插件）的作用是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81ExtractTextPlugin%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.0.0.0.12.</span> <span class="toc-text">12、ExtractTextPlugin插件的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81DevServer%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">5.0.0.0.13.</span> <span class="toc-text">13、DevServer开发工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88"><span class="toc-number">5.0.0.0.14.</span> <span class="toc-text">14、实时预览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2%EF%BC%9F"><span class="toc-number">5.0.0.0.15.</span> <span class="toc-text">15、什么是模块热替换？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSource-Map-%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">5.0.0.0.16.</span> <span class="toc-text">16、什么是Source Map 及其使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81Webpack%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">5.0.0.0.17.</span> <span class="toc-text">17、Webpack的几个核心概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81Webpack%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.0.0.0.18.</span> <span class="toc-text">18、Webpack简单工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-%E4%BB%80%E4%B9%88%E6%98%AFloader-%E4%BB%80%E4%B9%88%E6%98%AFPlugin-loader%E5%92%8Cplugin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.0.0.0.19.</span> <span class="toc-text">19.什么是loader ? 什么是Plugin ? loader和plugin有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-webpack%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">5.0.0.0.20.</span> <span class="toc-text">20.webpack中都有哪些插件，这些插件有什么作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD"><span class="toc-number">5.0.0.0.21.</span> <span class="toc-text">21.如何利用webpack优化前端性能?</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-vue3-0"><span class="toc-number">6.</span> <span class="toc-text">7.vue3.0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Vue3-0%E5%92%8CVue2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.0.0.0.1.</span> <span class="toc-text">1.Vue3.0和Vue2.0的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Vue3-0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">6.0.0.0.2.</span> <span class="toc-text">2.Vue3.0都有哪些重要新特性？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Vue3-0-%E5%AF%B9%E6%AF%94Vue2-0%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-number">6.0.0.0.3.</span> <span class="toc-text">3.Vue3.0 对比Vue2.0的优势在哪？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Vue3-0%E5%92%8CReact-16-X%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%E5%92%8C%E7%9B%B8%E4%BC%BC%E5%A4%84%EF%BC%9F"><span class="toc-number">6.0.0.0.4.</span> <span class="toc-text">4.Vue3.0和React 16.X都有哪些区别和相似处？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Vue3-0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">6.0.0.0.5.</span> <span class="toc-text">5.Vue3.0是如何实现代码逻辑复用的？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">8.移动端、小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">1. 移动端兼容适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-flexible%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%ADdpr"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">2.flexible如何实现自动判断dpr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A5iPhone6%E4%B8%BA%E6%A0%87%E5%87%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%A8%BF%E7%9A%84%E5%B0%BA%E5%AF%B8%E6%98%AF%E4%BB%A5750px%E5%AE%BD%E5%BA%A6%E6%9D%A5%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">7.0.0.3.</span> <span class="toc-text">3.为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%BD%A2%E5%B1%8Fiphone-X"><span class="toc-number">7.0.0.4.</span> <span class="toc-text">4.如何处理异形屏iphone X</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96"><span class="toc-number">7.0.0.5.</span> <span class="toc-text">5.移动端首屏优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-PWA%E5%85%A8%E7%A7%B0Progressive-Web-App%EF%BC%8C%E5%8D%B3%E6%B8%90%E8%BF%9B%E5%BC%8FWEB%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.0.6.</span> <span class="toc-text">6.PWA全称Progressive Web App，即渐进式WEB应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%A6%BB%E7%BA%BF%E5%8C%85%E6%96%B9%E6%A1%88"><span class="toc-number">7.0.0.7.</span> <span class="toc-text">7.离线包方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.0.8.</span> <span class="toc-text">8. 自适应和响应式布局的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">7.0.0.9.</span> <span class="toc-text">9.简单描述下微信小程序的相关文件类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="toc-number">7.0.0.10.</span> <span class="toc-text">10.你是怎么封装微信小程序的数据请求的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">7.0.0.11.</span> <span class="toc-text">11.小程序有哪些参数传值的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E7%AE%80%E8%BF%B0%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">7.0.0.12.</span> <span class="toc-text">12.简述微信小程序原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C-vue-%E5%93%AA%E9%87%8C%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F"><span class="toc-number">7.0.0.13.</span> <span class="toc-text">13.小程序的双向绑定和 vue 哪里不一样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-webview-%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%80%8E%E4%B9%88%E8%B7%B3%E5%9B%9E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%EF%BC%9F"><span class="toc-number">7.0.0.14.</span> <span class="toc-text">14.webview 中的页面怎么跳回小程序中？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%94%A8%E6%88%B7%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F"><span class="toc-number">7.0.0.15.</span> <span class="toc-text">15.小程序关联微信公众号如何确定用户的唯一性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-number">7.0.0.16.</span> <span class="toc-text">16.小程序如何实现下拉刷新？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">7.0.0.17.</span> <span class="toc-text">17.小程序调用后台接口遇到哪些问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84-wxss-%E5%92%8C-css-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">7.0.0.18.</span> <span class="toc-text">18.小程序的 wxss 和 css 有哪些不一样的地方？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E5%88%86%E6%9E%90%E4%B8%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="toc-number">7.0.0.19.</span> <span class="toc-text">19.分析下微信小程序的优劣势</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-es6"><span class="toc-number">8.</span> <span class="toc-text">9.es6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">1、var、let、const之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">2、使用箭头函数应注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ES6%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">8.3.</span> <span class="toc-text">3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%8B-Set%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">4、介绍下 Set、Map的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81ECMAScript-6-%E6%80%8E%E4%B9%88%E5%86%99-class-%EF%BC%8C%E4%B8%BA%E4%BD%95%E4%BC%9A%E5%87%BA%E7%8E%B0-class%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">5、ECMAScript 6 怎么写 class ，为何会出现 class？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%82%A3%E4%B9%88-then-%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">6、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81setTimeout%E3%80%81Promise%E3%80%81Async-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.7.</span> <span class="toc-text">7、setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81promise%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5catch%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">8、promise有几种状态，什么时候会进入catch？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%B8%8B%E9%9D%A2%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">8.9.</span> <span class="toc-text">9、下面的输出结果是多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E7%9A%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">8.10.</span> <span class="toc-text">10、使用结构赋值，实现两个变量的值的交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%94%AE%E5%90%8D%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%87%B3%E5%B0%91%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AAsymbol%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89key"><span class="toc-number">8.11.</span> <span class="toc-text">11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E4%B8%8B%E9%9D%A2Set%E7%BB%93%E6%9E%84%EF%BC%8C%E6%89%93%E5%8D%B0%E5%87%BA%E7%9A%84size%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">8.12.</span> <span class="toc-text">12、下面Set结构，打印出的size值是多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Promise-%E4%B8%ADreject-%E5%92%8C-catch-%E5%A4%84%E7%90%86%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.13.</span> <span class="toc-text">13、Promise 中reject 和 catch 处理上有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Set%E5%8E%BB%E9%87%8D"><span class="toc-number">8.14.</span> <span class="toc-text">14、如何使用Set去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%B0%86%E4%B8%8B%E9%9D%A2for%E5%BE%AA%E7%8E%AF%E6%94%B9%E6%88%90for-of%E5%BD%A2%E5%BC%8F"><span class="toc-number">8.15.</span> <span class="toc-text">15、将下面for循环改成for of形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E7%90%86%E8%A7%A3-async-await%E4%BB%A5%E5%8F%8A%E5%AF%B9Generator%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">8.16.</span> <span class="toc-text">16、理解 async&#x2F;await以及对Generator的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81forEach%E3%80%81for-in%E3%80%81for-of%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">8.17.</span> <span class="toc-text">17、forEach、for in、for of三者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Bes6%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%A8%A1%E5%9D%97"><span class="toc-number">8.18.</span> <span class="toc-text">28、说一下es6的导入导出模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-React"><span class="toc-number">9.</span> <span class="toc-text">10.React</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%AE%9E%E6%88%98"><span class="toc-number">10.</span> <span class="toc-text">11.实战</span></a></li></ol>
                </div>
            
            <hr />
            <h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><p>1.v-show和v-if区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v-show通过css display控制显示和隐藏，v-if组件真正的渲染和销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-if</span><br><span class="line">v-if 常用于一次性改变，如根据权限决定是否显示</span><br><span class="line">v-show 用于 tabs 切换</span><br><span class="line">v-if 可与 templete块连用 ，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else</span><br><span class="line">v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗</span><br><span class="line">v-if 是控制元素的添加与删除，而 v-show 只是控制元素的 display 属性。</span><br></pre></td></tr></table></figure>

<p>2.为何v-for要用key</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快速查找到节点，减少渲染次数，提升渲染性能</span><br></pre></td></tr></table></figure>

<p>3.描述vue组件声明周期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">单组件声明周期图</span><br><span class="line">挂载： beforeCreate =&gt; created =&gt; beforeMount =&gt; mounted</span><br><span class="line">更新： beforeUpdate =&gt; updated</span><br><span class="line">销毁： beforeDestroy =&gt; destroyed</span><br><span class="line"></span><br><span class="line">父子组件生命周期图</span><br><span class="line">挂载： parent beforeCreate =&gt; parent created =&gt; parent beforeMount =&gt; child beforeCreate =&gt; child created =&gt; child beforeMount =&gt; child mounted =&gt; parent mounted</span><br><span class="line">更新： parent beforeUpdate =&gt; child beforeUpdate =&gt; child updated =&gt; parent updated</span><br><span class="line">销毁： parent beforeDestroy =&gt; child beforeDestroy =&gt; child destroyed =&gt; parent destroyed</span><br><span class="line">从以上能够看出：</span><br><span class="line">挂载时，子组件是在父组件before mount后开始挂载，并且子组件先mounted，父组件随后</span><br><span class="line">更新时，子组件是在父组件before update后开始更新，子组件先于父组件更新</span><br><span class="line">销毁时，子组件是在父组件before destroy后开始销毁，并且是子组件先销毁，父组件随后。</span><br></pre></td></tr></table></figure>

<p>4.vue组件如何通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.父子组件props和this.$emit</span><br><span class="line">2.ref 链：父组件要给子组件传值，在子组件上定义一个 ref 属性，这样通过父组件的 $refs 属性就可以获取子组件的值了，也可以进行父子，兄弟之间的传值($parent / $children与 ref类似)</span><br><span class="line">3.事件总线bus：使用一个 空的 VUE 实例作为事件总线，自定义事件event.$on   event.$off  event.$emit</span><br><span class="line">4 provide  inject组件通信</span><br><span class="line">5.vuex</span><br><span class="line">6.$attrs和$listeners 仅仅是传递数据，而不做中间处理，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。</span><br><span class="line"></span><br><span class="line">常见使用场景可以分为三类：</span><br><span class="line">父子通信：</span><br><span class="line">	父向子传递数据是通过 props，子向父是通过 events（$emit）；</span><br><span class="line">	通过父链 / 子链也可以通信（$parent / $children）；</span><br><span class="line">	ref 也可以访问组件实例；</span><br><span class="line">	provide / inject API；</span><br><span class="line">	$attrs/$listeners</span><br><span class="line">	vuex</span><br><span class="line">兄弟通信：</span><br><span class="line">	事件总线Bus；</span><br><span class="line">	Vuex</span><br><span class="line">跨级通信：</span><br><span class="line">	事件总线Bus；</span><br><span class="line">	Vuex；</span><br><span class="line">	provide / inject API</span><br><span class="line">	$attrs/$listeners</span><br></pre></td></tr></table></figure>

<p>5.描述组件渲染和更新的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、vue 组件初次渲染过程</span><br><span class="line">解析模板为 render 函数</span><br><span class="line">触发响应式，监听 data 属性的 getter 和 setter</span><br><span class="line">执行 render 函数， 生成 vnode，patch(elem,vnode)</span><br><span class="line">2、vue 组件更新过程</span><br><span class="line">修改 data， 触发 setter （此前在getter中已被监听）</span><br><span class="line">重新执行 render 函数，生成 newVnode，patch(vnode, newVnode)</span><br></pre></td></tr></table></figure>

<p>6.双向数据绑定v-model的实现原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">双向数据绑定最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的.</span><br><span class="line"></span><br><span class="line">先是从data里面的数据msg通过绑定到input控件和p标签上。然后input上通过v-on:input监听控件，触发change()。</span><br><span class="line">调用方法都可以默认获取e事件，e.target.value是获取调用该方法的DOM对象的value值。把value值在赋给data里的msg，就是实现了双向数据绑定的原理了。</span><br><span class="line"></span><br><span class="line">采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。</span><br></pre></td></tr></table></figure>

<p>7.对mvvm的理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m-&gt;model,v-&gt;view,vm-&gt;viewModel。dom通过监听事件操作vue里的data，反之vue中的data通过指令操作dom，这就是所说数据驱动视图，这就是mvvm的理解。</span><br></pre></td></tr></table></figure>

<p>8.computed有何特性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存，data不变不会重新计算，提高性能</span><br></pre></td></tr></table></figure>

<p>9.VUE 中如何封装组件？什么组件，为什么要封装组件？组件中 data 为什么是一个函数？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">为什么要封装组件？</span><br><span class="line">　　主要就是为了解耦，提高代码复用率。</span><br><span class="line">　　什么是组件？</span><br><span class="line">　　页面上可以复用的都称之为组件 它是 HTML、CSS、JS 的聚合体。</span><br><span class="line">　　组件就相当于库，把一些能在项目里或者不同项目里可以复用的代码进行需求性的封装。</span><br><span class="line">　　组件中的 data 为什么是一个函数？</span><br><span class="line">　　让每个返回的实例都可以维护一份被返回对象的独立的拷贝。</span><br></pre></td></tr></table></figure>

<p>10.ajax请求应该放在哪个生命周期？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mounted，因为js是单线程，ajax异步获取数据</span><br></pre></td></tr></table></figure>

<p>11.如何将组件所有props传递给子组件？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父组件绑定一个自定义属性变量，然后子组件通过props使用这个变量即可。</span><br></pre></td></tr></table></figure>

<p>12.如何自定实现v-model?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们定义了model对象。model对象包含两个属性，一个是prop，一个是event。prop值text1，event的值change1，我们这里写model是为了改变默认的东西，使用我们自己定义的变量。</span><br><span class="line">&lt;input type=&quot;text&quot;  :value=&quot;text1&quot;   @input=&quot;$emit(&#x27;change1&#x27;, $event.target.value)&quot; &gt;</span><br></pre></td></tr></table></figure>

<p>13.多个组件有相同逻辑，如何抽离？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用mixin 对公共部分的逻辑进行抽离</span><br></pre></td></tr></table></figure>

<p>14.何时要使用异步组件？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载大组件，路由异步加载</span><br></pre></td></tr></table></figure>

<p>15.何时使用keep-alive？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存组件不需要重复渲染，多个静态tab页切换，优化性能</span><br></pre></td></tr></table></figure>

<p>16.何时使用beforeDestroy？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.解绑自定义事件event.$off</span><br><span class="line">2.清除定时器</span><br><span class="line">3.解绑自定义dom事件，如windom.scroll等</span><br></pre></td></tr></table></figure>

<p>17.什么是作用域插槽？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在solt组件中有自己的data，把它传给使用的地方</span><br></pre></td></tr></table></figure>

<p>18.vuex中action和mutation有何区别？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action中处理异步，mutation不可以</span><br><span class="line">mutation做原子操作，action2可以整合多个mutation</span><br></pre></td></tr></table></figure>

<p>19.vue-router常用路由模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash默认，h5 histroy需要服务端支持</span><br></pre></td></tr></table></figure>

<p>20.如何配置vue-router异步加载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component:() =&gt; import(&#x27;./component&#x27;)</span><br></pre></td></tr></table></figure>

<p>21.请用vnode描述一个dom结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&#x27;test&#x27;&gt;</span><br><span class="line">	&lt;p class=&#x27;hehe&#x27;&gt;这里是p标签&lt;/p&gt;</span><br><span class="line">	&lt;li&gt;&#123;&#123;1+1&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">let vdom=&#123;</span><br><span class="line">    tag:&#x27;ul&#x27;,</span><br><span class="line">    props:&#123;</span><br><span class="line">    	id:&#x27;test&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    children:[</span><br><span class="line">    	&#123;</span><br><span class="line">    		tag:&#x27;p&#x27;,</span><br><span class="line">    		props:&#123;</span><br><span class="line">    			class:&#x27;hehe&#x27;</span><br><span class="line">    		&#125;,</span><br><span class="line">    		children:&#x27;这里是p标签&#x27;</span><br><span class="line">    	&#125;,</span><br><span class="line">    	&#123;</span><br><span class="line">    		tag:&#x27;li&#x27;,</span><br><span class="line">    		children:1</span><br><span class="line">    	&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>22.监听data变化的核心api是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue2.0核心api是Object.defineProperty，vue3.0是启用proxy实现响应式</span><br></pre></td></tr></table></figure>

<p>23.vue如何监听数据变化？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue中的watch监听数据变化</span><br></pre></td></tr></table></figure>

<p>24.请描述响应式原理？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.描述监听data变化</span><br><span class="line">监听对象变化：vue2.0核心api是Object.defineProperty，vue3.0是启用proxy实现响应式</span><br><span class="line">监听数组变化：重写数组的push.pop.shift.unshift.splice.sort.reverse方法</span><br><span class="line">2.组件渲染和更新的过程(面试题5)</span><br></pre></td></tr></table></figure>

<p>25.简述diff算法过程（了解）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在执行Diff算法的过程就是调用名为 patch 的函数，比较新旧节点。一边比较一边给真实的 DOM 打补丁。patch 函数接收两个参数 oldVnode 和 Vnode，它们分别代表新的节点和之前的旧节点。这个patch函数会比较 oldVnode 和 vnode 是否是相同的, 即函数 sameVnode(oldVnode, vnode), 根据这个函数的返回结果分如下两种情况：</span><br><span class="line">true：则执行 patchVnode</span><br><span class="line">false：则用 vnode 替换 oldVnode</span><br><span class="line">//对比过程</span><br><span class="line">找到对应的真实 dom，称为 el</span><br><span class="line">判断 vnode 和 oldVnode 是否指向同一个对象。</span><br><span class="line">如果是，那么直接 return。</span><br><span class="line">如果他们都有文本节点并且不相等，那么将 el 的文本节点设置为 vnode 的文本节点。</span><br><span class="line">如果 oldVnode 有子节点而 vnode 没有，则删除 el 的子节点。</span><br><span class="line">如果 oldVnode 没有子节点而 vnode 有，则将 vnode 的子节点真实化之后添加到 el</span><br><span class="line">如果两者都有子节点，则执行 updateChildren 函数比较子节点。</span><br></pre></td></tr></table></figure>

<p>26.vue为何是异步渲染，$nextTick何用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以考虑性能问题，Vue会在本轮数据更新之后，再去异步更新视图</span><br><span class="line">$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM</span><br></pre></td></tr></table></figure>

<p>27.vue常见性能优化方式？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.合理使用v-if和v-show，</span><br><span class="line">2.合理使用computed，</span><br><span class="line">3.v-for加key，</span><br><span class="line">4.自定义事件，dom事件及时销毁，</span><br><span class="line">5.合理使用异步组件，</span><br><span class="line">6.合理使用keepalive，</span><br><span class="line">7.data层级不要太深，</span><br><span class="line">8.使用vue-loader在开发环境做模板编译，</span><br><span class="line">9.前端通用性能优化（如图片懒加载/减少 HTTP请求数/合理设置 HTTP缓存/资源合并与压缩/合并 CSS图片/将 CSS放在 head中/避免重复的资源请求/切分到多个域名），</span><br><span class="line">10.使用ssr</span><br></pre></td></tr></table></figure>

<p> 28、VUEX 是什么？怎么使用？那种场合能用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vuex 是一个专门为 vue 构建的状态管理工具，主要是为了解决 多组间之间状态共享问题。强调的是集中式管理，（组件与组件之间的关系变成了组件与仓库之间的关系）</span><br><span class="line">　　vuex 的核心包括：state（存放状态）、mutations（同步的更改状态）、actions（发送异步请求，拿到数据）、getters（根据之前的状态派发新的状态）、modules（模块划分）</span><br><span class="line">　　state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据</span><br><span class="line">　　应用场合：购物车的数据共享、登入注册</span><br></pre></td></tr></table></figure>

<p>29、vue 的指令用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-html   //html</span><br><span class="line">v-text   //元素里要显示的内容</span><br><span class="line">v-bind：data    //绑定动态数据   ：data</span><br><span class="line">v-on：click      //绑定事件       @click</span><br><span class="line">v-for</span><br><span class="line">v-if　　 //条件渲染指令</span><br><span class="line">v-model    //双向绑定，用于表单</span><br></pre></td></tr></table></figure>

<p>30、vue.js的两个核心是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据驱动和组件化</span><br></pre></td></tr></table></figure>

<p>31.vue中子组件调用父组件的方法?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.直接在子组件中通过this.$parent.event来调用父组件的方法。</span><br><span class="line">2.在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。</span><br><span class="line">3.父组件把方法传入子组件中，在子组件里直接调用这个方法。</span><br></pre></td></tr></table></figure>

<p>32.vue中父组件调用子组件的方法?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">父组件利用ref属性操作子组件方法。</span><br><span class="line">父：</span><br><span class="line">&lt;child ref=&quot;childMethod&quot;&gt;&lt;/child&gt;</span><br><span class="line">子：</span><br><span class="line">method: &#123;</span><br><span class="line">  test() &#123;</span><br><span class="line">     alert(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">在父组件里调用test即 this.$refs.childMethod.test()</span><br></pre></td></tr></table></figure>

<p>33.vue页面级组件之间传值?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.使用vue-router通过跳转链接带参数传参。</span><br><span class="line">2.使用本地缓存localStorge。</span><br><span class="line">3.使用vuex数据管理传值</span><br></pre></td></tr></table></figure>

<p>34.说说vue的动态组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个组件通过同一个挂载点进行组件的切换，is的值是哪个组件的名称，那么页面就会显示哪个组件。</span><br></pre></td></tr></table></figure>

<p>35.$route和 $router的区别是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。</span><br><span class="line">$route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。</span><br></pre></td></tr></table></figure>

<p>36.为什么使用vue开发？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件化开发 单页面路由 丰富的Api方法 双向的数据绑定 单向数据流 易于结合其他第三库</span><br></pre></td></tr></table></figure>

<p>37.vue和react 有什么区别？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、监听数据变化的实现原理不同**</span><br><span class="line">2、数据流的不同**</span><br><span class="line">3、HoC和mixins**</span><br><span class="line">4、组件通信的区别**</span><br><span class="line">5、模板渲染方式的不同**</span><br><span class="line">6、渲染过程不同**</span><br><span class="line">7、框架本质不同**</span><br></pre></td></tr></table></figure>

<p>38.Vuex和Redux的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mvvm和mvc理解 与区别？</span><br><span class="line">View 将请求转交---&gt; Controlle  处理 ---&gt;Model数据更新保存 -----&gt;View视图显示</span><br><span class="line">View 接受用户交互请求</span><br><span class="line">View 将请求转交给Controller处理</span><br><span class="line">Controller 操作Model进行数据更新保存</span><br><span class="line">数据更新保存之后，Model会通知View更新</span><br><span class="line">View 更新变化数据使用户得到反馈 </span><br><span class="line">MVVM即Model-View-ViewModel，将其中的 View 的状态和行为抽象化，让我们可以将UI和业务逻辑分开。MVVM的优点是低耦合、可重用性、独立开发。 </span><br><span class="line">View 接收用户交互请求</span><br><span class="line">View 将请求转交给ViewModel</span><br><span class="line">ViewModel 操作Model数据更新</span><br><span class="line">Model 更新完数据，通知ViewModel数据发生变化</span><br><span class="line">ViewModel 更新View数据 </span><br></pre></td></tr></table></figure>

<p>39.说一下vue的生命周期/钩子函数都有哪些？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">单组件声明周期图</span><br><span class="line">挂载： beforeCreate =&gt; created =&gt; beforeMount =&gt; mounted</span><br><span class="line">更新： beforeUpdate =&gt; updated</span><br><span class="line">销毁： beforeDestroy =&gt; destroyed</span><br><span class="line"></span><br><span class="line">父子组件生命周期图</span><br><span class="line">挂载： parent beforeCreate =&gt; parent created =&gt; parent beforeMount =&gt; child beforeCreate =&gt; child created =&gt; child beforeMount =&gt; child mounted =&gt; parent mounted</span><br><span class="line">更新： parent beforeUpdate =&gt; child beforeUpdate =&gt; child updated =&gt; parent updated</span><br><span class="line">销毁： parent beforeDestroy =&gt; child beforeDestroy =&gt; child destroyed =&gt; parent destroyed</span><br><span class="line">从以上能够看出：</span><br><span class="line">挂载时，子组件是在父组件before mount后开始挂载，并且子组件先mounted，父组件随后</span><br><span class="line">更新时，子组件是在父组件before update后开始更新，子组件先于父组件更新</span><br><span class="line">销毁时，子组件是在父组件before destroy后开始销毁，并且是子组件先销毁，父组件随后。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">钩子函数有三种 ,也叫路由守卫</span><br><span class="line">全局导航钩子（跳转前进行判断拦截）  全局路由守卫</span><br><span class="line">router.beforeEach(to, from, next),全局前置守卫</span><br><span class="line">router.beforeResolve(to, from, next),全局的解析守卫</span><br><span class="line">router.afterEach(to, from ,next) 全局的后置守卫</span><br><span class="line">组件内钩子    路由独享的守卫</span><br><span class="line">beforeRouteEnter</span><br><span class="line">beforeRouteUpdate</span><br><span class="line">beforeRouteLeave </span><br><span class="line">单独路由独享组件</span><br><span class="line">beforeEnter   组件内的守卫</span><br></pre></td></tr></table></figure>

<p>40.双向数据绑定的理解？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty劫持data属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</span><br></pre></td></tr></table></figure>

<p>41.vue组件中data为什么函数返回一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data。如果单纯的写成对象形式，就使得所有组件实例共用了一份data，造成了数据污染。</span><br></pre></td></tr></table></figure>

<p>42.vue中哪些数组方法可以直接对数组修改实现视图更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push() pop() shift() unshift() splice() sort() reverse() vue数组对象修改触发视图更新</span><br></pre></td></tr></table></figure>

<p>43.有哪些指令？v-if和v-show区别，v-if、v-for优先级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v-html   //html</span><br><span class="line">v-text   //元素里要显示的内容</span><br><span class="line">v-bind：data    //绑定动态数据   ：data</span><br><span class="line">v-on：click      //绑定事件       @click</span><br><span class="line">v-for</span><br><span class="line">v-if　　 //条件渲染指令</span><br><span class="line">v-model    //双向绑定，用于表单</span><br><span class="line"></span><br><span class="line">v-show通过css display控制显示和隐藏，v-if组件真正的渲染好饿销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-if</span><br><span class="line">v-for和v-if不应该一起使用，必要情况下应该替换成computed属性。原因：v-for比v-if优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。</span><br></pre></td></tr></table></figure>

<p>44.v-for中key 的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快速查找到节点，减少渲染次数，提升渲染性能</span><br></pre></td></tr></table></figure>

<p>45.使用过keep-alive吗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keep-alive缓存vue实例，提高性能是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，</span><br><span class="line">提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； </span><br><span class="line">对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</span><br></pre></td></tr></table></figure>

<p>46.computed、watch（自动监听、深度监听）、methods区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的。</span><br><span class="line">不同点：</span><br><span class="line">computed：计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值。</span><br><span class="line">methods：只要发生重新渲染， method 调用总会执行该函数。</span><br><span class="line">watch监听对象需要深度监听，默认是浅监听</span><br><span class="line">当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed。 </span><br><span class="line">watch用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。</span><br></pre></td></tr></table></figure>

<p>47.vue中对象更改检测的注意事项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</span><br><span class="line">对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)`方法向嵌套对象`添加响应式属性`。为已有对象赋予多个新属性，比如使用 `Object.assign()`或 `_.extend()`。在这种情况下，你应该用两个对象的属性创建一个新的对象。</span><br></pre></td></tr></table></figure>

<p>48.什么是$nextTick？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">场景：vue是异步渲染的框架，react也是，data改变之后，dom不会立刻渲染，$nextTick会在dom渲染之后被触发，以获取最新dom节点</span><br></pre></td></tr></table></figure>

<p>49.ref 的作用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取dom元素 this.$refs.box</span><br><span class="line">获取子组件中的data this.$refs.box.msg</span><br><span class="line">调用子组件中的方法 this.$refs.box.open()</span><br></pre></td></tr></table></figure>

<p>50.什么是vuex？vuex核心包括？怎么修改state中数据？在项目中哪里使用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vuex 是一个专门为 vue 构建的状态管理工具，主要是为了解决 多组间之间状态共享问题。强调的是集中式管理，（组件与组件之间的关系变成了组件与仓库之间的关系）</span><br><span class="line">　　vuex 的核心包括：state（存放状态）、mutations（同步的更改状态）、actions（发送异步请求，拿到数据）、getters（根据之前的状态派发新的状态）、modules（模块划分）</span><br><span class="line">　　state 发布一条新的数据，在 getters 里面根据状态派发新的状态，actions 发送异步请求获取数据，然后在 mutations 里面同步的更改数据</span><br><span class="line">　　应用场合：购物车的数据共享、登入注册</span><br></pre></td></tr></table></figure>

<p>51.路由模式有哪些？路由传参有哪些方式？路由守卫有哪些，有没有在项目中使用过？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash模式（默认） 例如：http://abc.com/#/user/10</span><br><span class="line">h5 history模式  例如：http://abc.com/user/20 需要server端支持</span><br><span class="line">注意：history有如下问题 404</span><br><span class="line"></span><br><span class="line">路由传参方法？</span><br><span class="line">query传参和params传参</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、声明式导航</span><br><span class="line">不带参跳转 对应的地址为/foo</span><br><span class="line">url字符串拼接传参 对应的地址为/foo?id=123</span><br><span class="line">query方式对象形式传参 对应的地址为/foo?id=123</span><br><span class="line">params方式对象形式传参 对应地址为 /path/123 , 注意params和query一起使用params会失效，params与name一起使用</span><br><span class="line">2、编程式导航(路由实例对象router=new VueRouter())</span><br><span class="line">字符串router.push(&#x27;home&#x27;)</span><br><span class="line">对象router.push(&#123; path: &#x27;home&#x27; &#125;)</span><br><span class="line">命名的路由 对应路径为/path/123</span><br><span class="line">router.push(&#123; name: &#x27;user&#x27;, params: &#123; userId: &#x27;123&#x27; &#125;&#125;)</span><br><span class="line">带查询参数，变成 /register?plan=123</span><br><span class="line">router.push(&#123; path: &#x27;register&#x27;, query: &#123; plan: &#x27;123&#x27; &#125;&#125;)</span><br><span class="line"></span><br><span class="line">接收参数</span><br><span class="line">this.$route.params.id</span><br><span class="line">this.$route.query.xxx</span><br></pre></td></tr></table></figure>

<p>52.vue过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">过滤器是将后台返回的数据换一种形式输出，不改变原来的数据 应用场景:后台返回的状态码（性别，支付状态），商品价格</span><br><span class="line">1. 全局过滤器                                                         </span><br><span class="line">Vue.filter(&#x27;过滤器&#x27;,对应的过滤器函数)</span><br><span class="line">2.局部过滤器</span><br><span class="line">通过在Vue实例上挂载filers添加过滤器，只能在当前组件内部使用</span><br></pre></td></tr></table></figure>

<p>53.有没有封装过组件，封装过什么，怎么封装？注意点或有哪些原则？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">怎么封装：</span><br><span class="line">● 首先，使用Vue.extend()创建一个组件</span><br><span class="line">● 然后，使用Vue.component()方法注册组件</span><br><span class="line">● 接着，如果子组件需要数据，可以在props中接受定义</span><br><span class="line">● 最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法</span><br></pre></td></tr></table></figure>

<p>注意点或有哪些原则？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data数据结构设计，或者问有哪些原则</span><br><span class="line">原则：</span><br><span class="line">1.用数据描述所有的内容</span><br><span class="line">2.数据要结构化，易于程序操作，遍历，查找</span><br><span class="line">3.数据要可扩展，以便增加新的功能</span><br><span class="line">组件如何设计，有什么原则</span><br><span class="line">原则：</span><br><span class="line">1.从功能上拆分层次</span><br><span class="line">2.尽量让组件原子化，一个组件只做一件事情</span><br><span class="line">3.容器组件（只管数据，一般是顶级组件）和展示组件（只管显示视图）</span><br></pre></td></tr></table></figure>

<p>54.移动端项目如何适配（rem）？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css3规定：1rem的大小就是根元素&lt;html&gt;的font-size的值。</span><br><span class="line">   通过设置 根元素&lt;html&gt;的font-size的大小，来控制整个html文档内的字体大小、元素宽高、内外边距等，</span><br><span class="line">   根据移动设备的宽度大小来实现自适应，不同的设备都展示一致的页面效果。</span><br><span class="line">rem布局简单分析 分三步：</span><br><span class="line">第一步：前端开发者首先拿到UI设计原型稿的宽度，750宽度，如 320px 或者640px或者750px;</span><br><span class="line">第二步：增加脚本（设置根元素&lt;html&gt;字体大小）</span><br><span class="line">第三步：css中使用rem单位；关键点：字体大小，元素宽高，内外边距一定是根据设计稿测量得来的。</span><br></pre></td></tr></table></figure>

<p>55.有没有使用过axios、axios拦截器，跨域如何解决？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios拦截器：</span><br><span class="line">// 添加请求拦截器</span><br><span class="line">axios.interceptors.request.use</span><br><span class="line">// 添加响应拦截器</span><br><span class="line">axios.interceptors.response.use</span><br><span class="line"></span><br><span class="line">跨域特别注意两点：</span><br><span class="line">第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，</span><br><span class="line">第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</span><br><span class="line">vue如何解决跨域：</span><br><span class="line">proxyTable   这里vue脚手架生成的标准项目为准。一般在项目config目录下面有个index文件</span><br><span class="line">CORS   CORS即跨源资源共享，它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。</span><br><span class="line">Nginx  当我们明白跨越的含义之后。只要解决了&#x27;源&#x27;的问题。那么跨越也就不存在了</span><br></pre></td></tr></table></figure>

<p>56.vue项目做过哪些优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">（1）代码层面的优化 </span><br><span class="line">v-if 和 v-show 区分使用场景</span><br><span class="line">computed 和 watch  区分使用场景</span><br><span class="line">v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</span><br><span class="line">长列表性能优化</span><br><span class="line">事件的销毁 addEventlisenter 事件监听</span><br><span class="line">图片资源懒加载</span><br><span class="line">路由懒加载</span><br><span class="line">第三方插件的按需引入</span><br><span class="line">优化无限列表性能</span><br><span class="line">服务端渲染 SSR or 预渲染</span><br><span class="line">（2）Webpack 层面的优化</span><br><span class="line">Webpack 对图片进行压缩</span><br><span class="line">减少 ES6 转为 ES5 的冗余代码</span><br><span class="line">提取公共代码</span><br><span class="line">模板预编译</span><br><span class="line">提取组件的 CSS</span><br><span class="line">优化 SourceMap</span><br><span class="line">构建结果输出分析</span><br><span class="line">Vue 项目的编译优化 </span><br><span class="line">（3）基础的 Web 技术的优化</span><br><span class="line">开启 gzip 压缩</span><br><span class="line">浏览器缓存</span><br><span class="line">CDN 的使用</span><br><span class="line">使用 Chrome Performance 查找性能瓶颈</span><br></pre></td></tr></table></figure>

<p>57.为什么做首屏优化？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首屏时间的快与慢，直接影响到了用户对网站的认知度。所以首屏时间的长短对于用户的滞留时间的长短、用户转化率都尤为重要。</span><br></pre></td></tr></table></figure>

<p>58.如何做首屏优化？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">css模块化加载，对应模块下的css交给js或jsonp请求返回</span><br><span class="line">js懒执行，有交互才执行</span><br><span class="line">图片在其他屏（非首屏）都采用懒加载的模式，这样既能节省流量，也能减少请求数或延迟请求数。</span><br><span class="line">服务器方面：</span><br><span class="line"></span><br><span class="line">1. 少量静态文件的域名，图片与iconfont均是放在同一个域下，减少DNS的解析事件，最好做到域名收敛。</span><br><span class="line">2. 模块化接口的支持。</span><br><span class="line">3. 首屏内容最好做到静态缓存</span><br><span class="line">4. 对于vue和react做ssr</span><br></pre></td></tr></table></figure>

<p>59.vue常用的修饰符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.stop - 调用 event.stopPropagation()，禁止事件冒泡。</span><br><span class="line">.prevent - 调用 event.preventDefault()，阻止事件默认行为。</span><br><span class="line">.capture - 添加事件侦听器时使用 capture 模式。</span><br><span class="line">.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</span><br><span class="line">.native - 监听组件根元素的原生事件。</span><br><span class="line">.once - 只触发一次回调。</span><br><span class="line"></span><br><span class="line">v-model 指令常用修饰符：</span><br><span class="line">.number - 输入字符串转为数字</span><br><span class="line">.trim - 输入首尾空格过滤</span><br><span class="line">.lazy</span><br></pre></td></tr></table></figure>

<p>60.v-on可以监听多个方法吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-on可以监听多个方法，但是同一种事件类型的方法，vue-cli工程会报错</span><br></pre></td></tr></table></figure>

<p>61.vue中编写可复用的组件(深度好题，掌握思路,不用背诵)</p>
<p>1.在 Vue 组件中，状态称为 props，事件称为 events，片段称为 slots。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Props 允许外部环境传递数据给组件</span><br><span class="line">Events 允许组件触发外部环境的副作用 $emit</span><br><span class="line">Slots 允许外部环境将额外的内容组合在组件中。</span><br><span class="line">组件的构成部分也可以理解为组件对外的接口。良好的可复用组件应当定义一个清晰的公开接口。</span><br></pre></td></tr></table></figure>

<p>2.组件间通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。</span><br></pre></td></tr></table></figure>

<p>3.命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件的命名应该跟业务无关。应该依据组件的功能为组件命名。</span><br></pre></td></tr></table></figure>

<p>4.业务数据无关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可复用组件只负责 UI 上的展示和一些交互以及动画，如何获取数据跟它无关，因此不要在组件内部去获取数据，以及任何与服务端打交道的操作。可复用组件只实现 UI 相关的功能。</span><br></pre></td></tr></table></figure>

<p> 5.组件职责</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">约束好组件的职责，能让组件更好地解耦，知道什么功能是组件实现的，什么功能不需要实现。</span><br><span class="line">组件可以分为通用组件（可复用组件）和业务组件（一次性组件）。</span><br><span class="line">可复用组件实现通用的功能（不会因组件使用的位置、场景而变化）：</span><br><span class="line">UI 的展示</span><br><span class="line">与用户的交互（事件）</span><br><span class="line">动画效果</span><br><span class="line">业务组件实现偏业务化的功能：</span><br><span class="line">获取数据</span><br><span class="line">和 vuex 相关的操作</span><br><span class="line">埋点</span><br><span class="line">引用可复用组件</span><br><span class="line">可复用组件应尽量减少对外部条件的依赖，所有与 vuex 相关的操作都不应在可复用组件中出现。</span><br><span class="line">组件应当避免对其父组件的依赖，不要通过 this.$parent 来操作父组件的示例。父组件也不要通过 this.$children 来引用子组件的示例，而是通过子组件的接口与之交互。</span><br></pre></td></tr></table></figure>

<p>6.命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可复用组件除了定义一个清晰的公开接口外，还需要有命名空间。 modules</span><br><span class="line">命名空间可以避免与浏览器保留标签和其他组件的冲突。特别是当项目引用外部 UI 组件或组件迁移到其他项目时，命名空间可以避免很多命名冲突的问题。</span><br></pre></td></tr></table></figure>

<p>7.上下文无关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还是上面那句话，可复用组件应尽量减少对外部条件的依赖。没有特别需求且单个组件不至于过重的的前提下，不要把一个有独立功能的组件拆分成若干个小组件。</span><br></pre></td></tr></table></figure>

<p>8.数据扁平化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个 prop 应该是一个简单类型的数据。这样做有下列几点好处：</span><br><span class="line">组件接口清晰</span><br><span class="line">props 校验方便</span><br><span class="line">当服务端返回的对象中的 key 名称与组件接口不一样时，不需要重新构造一个对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>9.使用自定义事件实现数据的双向绑定  v-model</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有时候，对于一个状态，需要同时从组件内部和组件外部去改变它。</span><br><span class="line">:value   oninput</span><br><span class="line">例如，模态框的显示和隐藏，父组件可以初始化模态框的显示，模态框组件内部的关闭按钮可以让其隐藏。一个好的办法是，使用自定义事件改变父组件中的值  </span><br></pre></td></tr></table></figure>

<p>10.使用自定义 watch 优化 DOM 操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在开发中，有些逻辑无法使用数据绑定，无法避免需要对 DOM 的操作。例如，视频的播放需要同步 Video 对象的播放操作及组件内的播放状态。可以使用自定义 watch 来优化 DOM 的操作。</span><br></pre></td></tr></table></figure>

<p>11.项目骨架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单组件不异过重，组件在功能独立的前提下应该尽量简单，越简单的组件可复用性越强。当你实现组件的代码，不包括CSS，有好几百行了（这个大小视业务而定），那么就要考虑拆分成更小的组件。</span><br></pre></td></tr></table></figure>

<p>62.vue如何监听键盘事件中的按键？（大声朗读2遍）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在我们的项目经常需要监听一些键盘事件来触发程序的执行，而Vue中允许在监听的时候添加关键修饰符：</span><br><span class="line">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br><span class="line">对于一些常用键，还提供了按键别名：</span><br><span class="line">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</span><br><span class="line">全部的按键别名：</span><br><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line">修饰键：</span><br><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br><span class="line">与按键别名不同的是，修饰键和 keyup 事件一起用时，事件引发时必须按下正常的按键。换一种说法：如果要引发 keyup.ctrl，必须按下 ctrl 时释放其他的按键；单单释放 ctrl 不会引发事件</span><br><span class="line">&lt;!-- 按下Alt + 释放C触发 --&gt;</span><br><span class="line">&lt;input @keyup.alt.67=&quot;clear&quot;&gt; </span><br><span class="line">&lt;!-- 按下Alt + 释放任意键触发 --&gt;</span><br><span class="line">&lt;input @keyup.alt=&quot;other&quot;&gt;</span><br><span class="line">&lt;!-- 按下Ctrl + enter时触发 --&gt;</span><br><span class="line">&lt;input @keydown.ctrl.13=&quot;submit&quot;&gt;</span><br><span class="line">对于elementUI的input，我们需要在后面加上.native, 因为elementUI对input进行了封装，原生的事件不起作用。</span><br><span class="line">&lt;input v-model=&quot;form.name&quot; placeholder=&quot;昵称&quot; @keyup.enter=&quot;submit&quot;&gt;</span><br><span class="line">&lt;el-input v-model=&quot;form.name&quot; placeholder=&quot;昵称&quot; @keyup.enter.native=&quot;submit&quot;&gt;&lt;/el-input&gt;</span><br></pre></td></tr></table></figure>

<p>63.解决非工程化项目初始化页面闪动问题(好题,理解)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vue页面在加载的时候闪烁花括号&#123;&#125;，v-cloak指令和css规则如[v-cloak]&#123;display:none&#125;一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。&#123;&#123;name&#125;&#125;    data:  name:&#x27;&#x27;</span><br><span class="line">/*css样式*/</span><br><span class="line">[v-cloak] &#123;</span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;!--html代码--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot; v-cloak&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in tabs&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>64.v-for产生的列表，实现active的切换 tab切换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">v-for生成序列</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(info,index) in list&quot; :key=&quot;info.id&quot; @click=&quot;select(index)&quot; v-bind:class=&quot;&#123;&#x27;active&#x27;:info.active&#125;&quot;&gt;&#123;&#123;info.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">data数据</span><br><span class="line">list:[</span><br><span class="line">        &#123;</span><br><span class="line">          name:&#x27;a&#x27;,</span><br><span class="line">          id:1,</span><br><span class="line">          active:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name:&#x27;b&#x27;,</span><br><span class="line">          id:2,</span><br><span class="line">          active:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name:&#x27;c&#x27;,</span><br><span class="line">          id:3,</span><br><span class="line">          active:false</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name:&#x27;d&#x27;,</span><br><span class="line">          id:4,</span><br><span class="line">          active:false</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">点击事件</span><br><span class="line">select(d)&#123;</span><br><span class="line">      this.list.map(s=&gt;s.active=false); //for  forEach  map  filter some</span><br><span class="line">      this.list[d].active=true;</span><br><span class="line">    &#125;,</span><br><span class="line">CSS样式</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">li.active&#123;</span><br><span class="line">  background-color: red;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>65.v-model语法糖使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">v-model语法糖  v-model其实是一种简写方式，我们常见的有两种v-model，分别是input元素上的v-model 和非input元素上v-model</span><br><span class="line">input元素上的：</span><br><span class="line">      &lt;input v-model=&quot;price&quot;&gt;&lt;!-- 下行的语法糖 --&gt;</span><br><span class="line">      &lt;input :value=&quot;price&quot; @input=&quot;price = $event.target.value&quot;&gt;</span><br><span class="line">     </span><br><span class="line">      data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          price: 20</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> 非input元素上的：</span><br><span class="line"> Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;checked&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;checkbox&quot;</span><br><span class="line">      v-bind:checked=&quot;checked&quot;</span><br><span class="line">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line">父组件：&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>

<p>66.十个常用的自定义过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（1）去除空格  </span><br><span class="line">	type:1-所有空格  2-前后空格  3-前空格 4-后空格。</span><br><span class="line">（2）任意格式日期处理</span><br><span class="line">（3）字母大小写切换</span><br><span class="line">	type:1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写</span><br><span class="line">（4）字符串循环复制,count-&gt;次数.</span><br><span class="line">（5）字符串替换</span><br><span class="line">（6）字符替换*，隐藏手机号或者身份证号等</span><br><span class="line">（7）格式化处理字符串</span><br><span class="line">（8）现金额大写转换函数</span><br><span class="line">（9）保留2位小数   0.3 + 0.9 ！= 1.2  </span><br><span class="line">（10）补零</span><br></pre></td></tr></table></figure>

<p>67.vue等单页面应用及其优缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">单页面应用（SPA），通俗一点说就是指只有一个主页面的应用</span><br><span class="line">单页面的优点：</span><br><span class="line">   用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小。</span><br><span class="line">   前后端分离。</span><br><span class="line">   效果会比较炫酷（比如切换页面内容时的专场动画）。</span><br><span class="line">单页面缺点：</span><br><span class="line">  不利于seo。</span><br><span class="line">  导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）。</span><br><span class="line">  初次加载时耗时多。</span><br><span class="line">  页面复杂度提高很多。</span><br></pre></td></tr></table></figure>

<p>68.vue的计算属性，特性，应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">含义：computed  是计算属性，把模板中的一些稍微复杂的逻辑计算放回到js代码中，解决在模板中放入太多的逻辑会让模板过重且难以维护的问题。</span><br><span class="line">computed特性：</span><br><span class="line">    （1）computed 是基于它们的依赖进行缓存的</span><br><span class="line">    （2）只有在它的相关依赖发生改变时才会重新求值</span><br><span class="line">computed应用：就是简化tempalte里面&#123;&#123;&#125;&#125;计算和处理props或$emit的传值</span><br></pre></td></tr></table></figure>

<p>69.vue父组件向子组件通过props传递数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">父组件传递：</span><br><span class="line">    &lt;子组件调用  v-bind:自定义属性名=&quot;要传递的数据&quot;&gt;&lt;/子组件调用&gt;</span><br><span class="line">子组件接收：</span><br><span class="line">    props:[&#x27;自定义属性名&#x27;]</span><br><span class="line">    props:&#123;</span><br><span class="line">    	type:String,</span><br><span class="line">    	default&#123;</span><br><span class="line">    	  return &#x27;&#x27;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>70.vue-cli生产环境使用全局常量(了解)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一步，在 static 下新建 config.js：</span><br><span class="line">第二步，在 config.js 里面设置全局变量：</span><br><span class="line">第三步，在 index.html 里面引入：</span><br><span class="line">第四步，在其他 .js 文件中即可使用：</span><br><span class="line">第五步，打包后修改：通过 `npm run build` 命令打包后，此 config.js 文件会被打包到 `dist/static`文件夹下，此时如果需要修改 `PUBLIC_IP`，打开`config.js`即可修改，无需重新打包！</span><br></pre></td></tr></table></figure>

<p>71.vue弹窗后如何禁止滚动条滚动？（了解）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.在有弹出框的页面中，加上以下方法，弹出框出现时调用禁止滚动方法stopScroll()，弹出框去掉是调取允许滚动方法canScroll()即可，代码如下</span><br><span class="line"></span><br><span class="line">methods : &#123;</span><br><span class="line">  //禁止滚动</span><br><span class="line">  stopScroll()&#123;</span><br><span class="line">    var mo=function(e)&#123;e.preventDefault();&#125;;</span><br><span class="line">    document.body.style.overflow=&#x27;hidden&#x27;;</span><br><span class="line">    document.addEventListener(&quot;touchmove&quot;,mo,false);//禁止页面滑动</span><br><span class="line">  &#125;,</span><br><span class="line">  /***取消滑动限制***/</span><br><span class="line">  canScroll()&#123;</span><br><span class="line">    var mo=function(e)&#123;e.preventDefault();&#125;;</span><br><span class="line">    document.body.style.overflow=&#x27;&#x27;;//出现滚动条</span><br><span class="line">    document.removeEventListener(&quot;touchmove&quot;,mo,false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.在全局js即main.js中，设置全局函数，在使用到的页面分别调用即可，代码如下：</span><br><span class="line"></span><br><span class="line">//弹出框禁止滑动</span><br><span class="line">Vue.prototype.stopScroll = function () &#123;</span><br><span class="line"> var mo = function (e) &#123; e.preventDefault() &#125;</span><br><span class="line"> document.body.style.overflow = &#x27;hidden&#x27;</span><br><span class="line"> document.addEventListener(&#x27;touchmove&#x27;, mo, false)// 禁止页面滑动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//弹出框可以滑动</span><br><span class="line">Vue.prototype.canScroll = function () &#123;</span><br><span class="line"> var mo = function (e) &#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line"> &#125;</span><br><span class="line"> document.body.style.overflow = &#x27;&#x27;// 出现滚动条</span><br><span class="line"> document.removeEventListener(&#x27;touchmove&#x27;, mo, false)</span><br><span class="line">&#125;</span><br><span class="line">具体页面的调用方法如下：</span><br><span class="line"> //当需要禁止弹出框底部内容滑动时调用：</span><br><span class="line"> this.stopScroll()</span><br><span class="line"> //当需要页面恢复滑动功能时调用：</span><br><span class="line"> this.canScroll()</span><br></pre></td></tr></table></figure>

<p>72.vue-cli中自定义指令的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.全局注册</span><br><span class="line">Vue.directive(‘name’, &#123;&#125;)</span><br><span class="line">2.局部注册</span><br><span class="line">directives: &#123;</span><br><span class="line">  name: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">然后在模版中直接使用即可。</span><br></pre></td></tr></table></figure>

<p>73.父组件异步获取动态数据传递给子组件(好题)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">问题：由于父组件中的数据是异步获取的，而子组件在一开始便会渲染，所以会造成子组件渲染完成后，数据还未获取到的情况</span><br><span class="line">解决方案：在子组件渲染前，判断父组件数据是否获取完成，数据获取完成后再渲染子组件.</span><br><span class="line">//tab-weekly(v-if=&quot;userId&quot;, :userId=&quot;userId&quot;)</span><br><span class="line">//tab-weekly是子组件，userId是在父组件中异步获取、需要传递给子组件tab-weekly的数据，在其中加一个判断，//当userId存在后，再渲染子组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>74.父组件给子组件props传参，子组件接收的6种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. data中  变量  = this.props里面的数据</span><br><span class="line">2. watch监听  赋值</span><br><span class="line">3. mounted  渲染完成后调用一个函数 进行赋值</span><br><span class="line">4. vuex</span><br><span class="line">5. computed 计算属性，用法和watch类似，computed是同步，watch可以异步</span><br><span class="line">6. 父组件v-if 触发渲染和销毁，子组件触发传参</span><br></pre></td></tr></table></figure>

<p>75.Vuex页面刷新数据丢失咋解决这个bug</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">问题：F5页面刷新，页面销毁之前的资源，重新请求，因此写在生命周期里的vuex数据是重新初始化，无法获取的，这也就是为什么会打印出空的原因。</span><br><span class="line">解决思路1：</span><br><span class="line">使用Localstorage sessionStorage 或cookie</span><br><span class="line">实际使用时当vuex值变化时，F5刷新页面，vuex数据重置为初始状态，所以还是要用到localStorage, </span><br><span class="line">解决方法2:</span><br><span class="line">插件vuex-persistedstate</span><br><span class="line">vuex-persistedstate默认持久化所有state，可以指定需要持久化的state</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>76.按钮权限怎么做？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在点击左侧菜单，存储全部权限，每次点击单个时候，去计算获取当前页面的按钮权限，封装一个button组件，然后在需要的地方引用</span><br></pre></td></tr></table></figure>

<p>77.完整的说下从url解析到显示页面过程，结合项目中说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 首先浏览器主进程接管，开了一个下载线程。</span><br><span class="line">2. 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</span><br><span class="line">3. 将下载完的内容转交给Renderer进程管理。</span><br><span class="line">4. Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。</span><br><span class="line">5. 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</span><br><span class="line">6. css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</span><br><span class="line">7. 绘制结束后，关闭TCP连接，过程有四次挥手</span><br></pre></td></tr></table></figure>

<p>78.vue声明周期都在哪些场景中使用？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.beforeCreate()&#123;&#125;</span><br><span class="line">　　创建前，访问不到data当中的属性以及methods当中的属性和方法，可以在当前生命周期创建一个loading，在页面加载完成之后将loading移除</span><br><span class="line">2.created()&#123;&#125;</span><br><span class="line">　　创建后，当前生命周期执行的时候会遍历data中所有的属性，给每一个属性都添加一个getter、setter方法,将data中的属性变成一个响应式属性</span><br><span class="line">3. beforeMount()&#123;&#125;</span><br><span class="line">　　 模板与数据进行结合，但是还没有挂载到页面上。因此我们可以在当前生命周期中进行数据最后的修改</span><br><span class="line">4.mounted()&#123;&#125;</span><br><span class="line">　　当前生命周期数据和模板进行相结合，并且已经挂载到页面上了，因此我们可以在当前生命周期中获取到真实的DOM元素</span><br><span class="line">5. beforeUpdate()&#123;&#125;</span><br><span class="line">　　当数据发生改变的时候当前生命周期就会执行，因此我们可以通过当前生命周期来检测数据的变化</span><br><span class="line">　　当前生命周期执行的时候会将更新的数据与模板进行相结合，但是并没有挂载到页面上，因此我们可以在当前生命周期中做更新数据的最后修改</span><br><span class="line">6.updated()&#123;&#125;</span><br><span class="line">　　数据与模板进行相结合，并且将更新后的数据挂载到了页面上。因此我们可以在当前生命周期中获取到最新的DOM结构</span><br><span class="line">7. beforeDestroy()&#123;&#125;</span><br><span class="line">　　当前生命周期中我们需要做事件的解绑  监听的移除  定时器的清除等操作</span><br><span class="line">8. destroyed()&#123;&#125;</span><br><span class="line">　　当前生命周期执行完毕后会将vue与页面之间的关联进行断开</span><br><span class="line">当&lt;keep-alive&gt;包裹动态组件的时候会触发两个新的生命周期</span><br><span class="line">9.　　activated     当组件为活跃状态的时候触发(活跃状态：进入页面的时候)</span><br><span class="line">10.  deactivated     缓存状态的时候触发</span><br></pre></td></tr></table></figure>



<h1 id="3-html、css"><a href="#3-html、css" class="headerlink" title="3.html、css"></a>3.html、css</h1><h4 id="1-html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？"><a href="#1-html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="1.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？"></a>1.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？</h4><p>H5新特性有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语义标签、增强型表单、Canvas绘图、地理定位、SVG绘图、拖放API、WebWorker、WebStorage、WebSocket</span><br></pre></td></tr></table></figure>

<p>处理h5新标签的浏览器兼容性问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法一:</span><br><span class="line"><span class="number">1</span>、使用静态资源的html5shiv包</span><br><span class="line">&lt;!--[<span class="keyword">if</span> lt IE9]&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;![endif]--&gt;</span><br><span class="line">方法二：</span><br><span class="line">IE6/IE7/IE8支持通过<span class="built_in">document</span>方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签</span><br></pre></td></tr></table></figure>

<h4 id="2-行内元素和块级元素的区别？什么是重绘和回流？两者区别？"><a href="#2-行内元素和块级元素的区别？什么是重绘和回流？两者区别？" class="headerlink" title="2.行内元素和块级元素的区别？什么是重绘和回流？两者区别？"></a>2.行内元素和块级元素的区别？什么是重绘和回流？两者区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">行内元素：</span><br><span class="line">共占一行，与其他行内元素并排，不能设置宽高，默认的宽度就是文字的宽度，行内元素只能嵌套包括自己在内的所有行内元素；a/b/i/u/em/strong/font/del/strike/span</span><br><span class="line">块级元素：</span><br><span class="line">独占一行，不能与其他任何元素并列，可以设置宽h/p/ul/ol/li/dl/dd/dt/table/caption/tr/th/td/tbody/tfoot/thead/div</span><br></pre></td></tr></table></figure>

<p>回流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。</span><br></pre></td></tr></table></figure>

<p>重绘：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，则就称为重绘。</span><br><span class="line">两者区别：</span><br><span class="line">回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流</span><br><span class="line">当页面布局和几何属性改变时就需要回流</span><br></pre></td></tr></table></figure>

<h4 id="3-CSS-选择符有哪些？优先级算法如何计算？"><a href="#3-CSS-选择符有哪些？优先级算法如何计算？" class="headerlink" title="3.CSS 选择符有哪些？优先级算法如何计算？"></a>3.CSS 选择符有哪些？优先级算法如何计算？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.id选择器（#id）</span><br><span class="line">2.类选择器（.class）</span><br><span class="line">3.标签选择器（div，h1，p）</span><br><span class="line">4.相邻选择器（h1 + p）</span><br><span class="line">5.子选择器（ul &gt; li）</span><br><span class="line">6.后代选择器（li a）</span><br><span class="line">7.通配符选择器（ * ）</span><br><span class="line">8.属性选择器（a[title]）</span><br><span class="line">9.伪类选择器（a:hover，li:nth-child）</span><br></pre></td></tr></table></figure>

<p><strong>优先级算法如何计算？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.优先级就近原则，同权重情况下样式定义最近者为准；</span><br><span class="line">2.载入样式以最后载入的定位为准；</span><br><span class="line">3.!important &gt; id &gt; class &gt; tag；</span><br><span class="line">4.important 比 内联优先级高，但内联比id要高；</span><br><span class="line">1、第一等：代表内联样式，如: style=””，权值为1000。</span><br><span class="line">2、第二等：代表ID选择器，如：#content，权值为0100。</span><br><span class="line">3、第三等：代表类，伪类和属性选择器，如.content，权值为0010。</span><br><span class="line">4、第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。</span><br><span class="line">5、通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。</span><br><span class="line">6、继承的样式没有权值。</span><br></pre></td></tr></table></figure>

<h4 id="4-CSS3有哪些新特性？"><a href="#4-CSS3有哪些新特性？" class="headerlink" title="4.CSS3有哪些新特性？"></a>4.CSS3有哪些新特性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word-wrap 文字换行</span><br><span class="line">text-overflow 超过指定容器的边界时如何显示</span><br><span class="line">text-decoration 文字渲染</span><br><span class="line">text-shadow文字阴影</span><br><span class="line">gradient渐变效果</span><br><span class="line">transition过渡效果 transition-duration：过渡的持续时间</span><br><span class="line">transform拉伸，压缩，旋转，偏移等变换</span><br><span class="line">animation动画</span><br></pre></td></tr></table></figure>

<h4 id="5-解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？"><a href="#5-解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？" class="headerlink" title="5.解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？"></a>5.解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在盒模型中，有个问题免不了存在，边界塌陷。两个盒子垂直方向设置外边距，会造成便捷塌陷，只保留一个，哪个值大保留哪个。</span><br><span class="line"> 注意： </span><br><span class="line">   浮动元素和绝对定位元素不会发生边界坍塌</span><br><span class="line">   只有块级元素的垂直方向才存在margin合并的问题，再说一下margin负值向内部缩减，正值向外。</span><br></pre></td></tr></table></figure>

<h4 id="6-简述flex布局"><a href="#6-简述flex布局" class="headerlink" title="6.简述flex布局"></a>6.简述flex布局</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">flex弹性布局，可以简便、完整、响应式地实现各种页面布局, 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）</span><br><span class="line">flex-direction：决定主轴的方向</span><br><span class="line">row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line">row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line">column：主轴为垂直方向，起点在上沿。</span><br><span class="line">column-reverse：主轴为垂直方向，起点在下沿。</span><br><span class="line">flex-wrap：换行</span><br><span class="line">nowrap（默认）：不换行。</span><br><span class="line">wrap：换行，第一行在上方。</span><br><span class="line">wrap-reverse：换行，第一行在下方。</span><br><span class="line">flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span><br><span class="line">justify-content：水平对齐方式</span><br><span class="line">flex-start（默认值）：左对齐</span><br><span class="line">flex-end：右对齐</span><br><span class="line">center： 居中</span><br><span class="line">space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br><span class="line">align-items：垂直对齐方式</span><br><span class="line">flex-start：交叉轴的起点对齐。</span><br><span class="line">flex-end：交叉轴的终点对齐。</span><br><span class="line">center：交叉轴的中点对齐。</span><br><span class="line">baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure>

<h4 id="7-css-隐藏元素有哪几种方法？position定位有哪些？"><a href="#7-css-隐藏元素有哪几种方法？position定位有哪些？" class="headerlink" title="7.css 隐藏元素有哪几种方法？position定位有哪些？"></a>7.css 隐藏元素有哪几种方法？position定位有哪些？</h4><p>css隐藏元素方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.display:none</span><br><span class="line">2.Jquery：show(),hide(),toggle()方法就是通过改变display的值来实现变化效果的。 </span><br><span class="line">3.visibility:hidden：</span><br><span class="line">和display:none的区别在于，元素在页面消失后，占据的空间依旧会保留着，但是display:none不会，所以它只会导致浏览器重绘而不会回流，因此，visibility:hidden适用于那些元素隐藏后不希望页面布局发生变化的场景；</span><br><span class="line">4.opacity:0  (透明度，元素本身不会隐藏，会引起重绘)</span><br><span class="line">5.overflow:hidden</span><br><span class="line">6.position: absolute： 把元素脱离文档流移出视觉区域，既不会影响布局，又能让元素保持可以操作。应用该属性后，主要就是通过控制方向（top,left,right,bottom），达到一定的值，离开当前页面。</span><br><span class="line">clip-path（不常用）</span><br></pre></td></tr></table></figure>

<p>position定位有哪些？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、static（静态定位，不脱流）</span><br><span class="line">2、fiexd（固定定位，脱流）</span><br><span class="line">3、relative （相对定位，不脱流）</span><br><span class="line">4、absolute（绝对定位，脱流）</span><br><span class="line">5、sticky（粘性定位）</span><br></pre></td></tr></table></figure>

<h4 id="8-BFC（Block-Formatting-Context）-是什么？应用？"><a href="#8-BFC（Block-Formatting-Context）-是什么？应用？" class="headerlink" title="8.BFC（Block Formatting Context） 是什么？应用？"></a>8.BFC（Block Formatting Context） 是什么？应用？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">是一个独立的渲染区域，通俗点BFC就是页面上的一个隔离的独立容器，容器里面的元素布局不受外界影响，同时也不会影响到外面的元素。</span><br><span class="line">那么我们可以通过CSS为元素设置一些属性，来触发BFC,常用的方式有：</span><br><span class="line">Float值不为none</span><br><span class="line">Postion值不为relative和static</span><br><span class="line">Overflow值为auto scroll和hidden</span><br><span class="line">display值为inline-block</span><br><span class="line">通过这几种方式，我们可以使用BFC来：</span><br><span class="line">1、防止margin重叠2、清楚内部浮动3、消除文本环绕做出自适应两栏布局：</span><br></pre></td></tr></table></figure>

<h4 id="9-解释下浮动和它的遗留问题？清除浮动的方法（4种）"><a href="#9-解释下浮动和它的遗留问题？清除浮动的方法（4种）" class="headerlink" title="9.解释下浮动和它的遗留问题？清除浮动的方法（4种）"></a>9.解释下浮动和它的遗留问题？清除浮动的方法（4种）</h4><p>浮动为该元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p>浮动引起的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父元素的高度无法被撑开，影响与父元素同级的元素</span><br><span class="line">与浮动元素同级的非浮动元素（内联元素）会紧跟其后</span><br><span class="line">若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</span><br></pre></td></tr></table></figure>

<p>清除浮动的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, 添加额外标签</span><br><span class="line">  在浮动元素末尾添加一个空的标签，</span><br><span class="line">&lt;div style=<span class="string">&quot;clear:both&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">优点：通俗易懂，容易掌握 </span><br><span class="line">缺点：可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦。 </span><br><span class="line"><span class="number">2</span>, 使用 br标签和其自身的 html属性 </span><br><span class="line">&lt;br clear=<span class="string">&quot;all&quot;</span> /&gt; </span><br><span class="line">优点：比空标签方式语义稍强，代码量较少 </span><br><span class="line">缺点：同样有违结构与表现的分离，不推荐使用 </span><br><span class="line"><span class="number">3</span>, 父元素设置 overflow：hidden</span><br><span class="line">优点：不存在结构和语义化问题，代码量极少 </span><br><span class="line">缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；overflow:hidden会导致中键失效。 </span><br><span class="line"><span class="number">4</span>、父元素设置 overflow：auto 属性。同样IE6需要触发hasLayout，演示和<span class="number">3</span>差不多 </span><br><span class="line">优点：不存在结构和语义化问题，代码量极少 </span><br><span class="line">缺点：多个嵌套后，firefox某些情况会造成内容全选；IE中 mouseover 造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生focus等。</span><br><span class="line"><span class="number">5</span>,使用:after 伪元素 </span><br><span class="line">需要注意的是 :after是伪元素（Pseudo-Element），不是伪类（某些CSS手册里面称之为“伪对象”），很多清除浮动大全之类的文章都称之为伪类，不过csser要严谨一点，这是一种态度。由于IE6-<span class="number">7</span>不支持:after，使用 zoom:<span class="number">1</span>触发 hasLayout。 </span><br><span class="line">.clearfix:after &#123;<span class="attr">content</span>:<span class="string">&quot; &quot;</span>; display:block; visibility:hidden; clear:both; &#125; </span><br><span class="line">.clearfix &#123; *zoom:<span class="number">1</span>; &#125;</span><br><span class="line">优点：结构和语义化完全正确,代码量居中 </span><br><span class="line">缺点：复用方式不当会造成代码量增加 </span><br></pre></td></tr></table></figure>

<h4 id="10-哪些外边距不重叠的情况？防止外边距重叠的方法？"><a href="#10-哪些外边距不重叠的情况？防止外边距重叠的方法？" class="headerlink" title="10.哪些外边距不重叠的情况？防止外边距重叠的方法？"></a>10.<strong>哪些外边距不重叠的情况？防止外边距重叠的方法？</strong></h4><p>外边距不重叠的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）水平margin永远不会重合</span><br><span class="line">2）设置了overflow属性(visible除外)的元素和它的子元素之间的margin不会重叠</span><br><span class="line">3）设置了绝对定位（position:absolute）的盒模型，垂直margin不会被重叠，和子元素之间也不重叠</span><br><span class="line">4）设置了display:inline-block的元素，垂直margin不会重叠，和子元素之间也不重叠</span><br><span class="line">5）根元素(如HTML)与body的margin不会重叠</span><br></pre></td></tr></table></figure>

<p>防止外边距重叠的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）元素绝对定位position:absolute;一般用在内层元素</span><br><span class="line">2）内层元素加float:left;或display:inline-block;</span><br><span class="line">3）外层元素用padding增加边距</span><br><span class="line">4）外层元素设置overflow:hidden;</span><br><span class="line">5）内层元素透明边框border:1px solid transparent;</span><br></pre></td></tr></table></figure>

<h4 id="11-如何让一个盒子水平垂直居中"><a href="#11-如何让一个盒子水平垂直居中" class="headerlink" title="11.如何让一个盒子水平垂直居中"></a>11.如何让一个盒子水平垂直居中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">①定位：（常用方法,推荐）</span><br><span class="line">position:absolute;</span><br><span class="line">position:relative;</span><br><span class="line">left:值;</span><br><span class="line">top:值;</span><br><span class="line">②display:table-cell;</span><br><span class="line">③外边距：margin-left:值;</span><br><span class="line">margin-top:值;</span><br><span class="line">④margin:auto;（不兼容低版本的IE浏览器）</span><br><span class="line">⑤弹性盒模型：display:flex;</span><br><span class="line">justify-content:conter;</span><br><span class="line">align-itens:center;</span><br><span class="line">⑥用transform的属性translate平移，不仅能实现绝对居中同样的效果，也支持联合可变高度方式使用。</span><br><span class="line">使用top:50%; left:50%;时，是以盒子的左上角为原点定位，是左上角的原点居中，但是元素本身并不居中。</span><br><span class="line">transform：translate(-50%，-50%):分别向左向上移动自身长宽的50%，使其位于中心。</span><br><span class="line">transform: translate(-50%,-50%)导致的像素模糊问题解决办法：</span><br><span class="line">  /** 这 0.5px加或者减都可以 */</span><br><span class="line">transform: translat(calc(-50% + 0.5 px), calc(-50% + 0.5 px))；</span><br><span class="line">⑦用calc计算</span><br></pre></td></tr></table></figure>

<h4 id="12-左右固定中间自适应-三栏布局（圣杯、双飞翼、弹性盒子…）"><a href="#12-左右固定中间自适应-三栏布局（圣杯、双飞翼、弹性盒子…）" class="headerlink" title="12.左右固定中间自适应 三栏布局（圣杯、双飞翼、弹性盒子…）"></a>12.左右固定中间自适应 三栏布局（圣杯、双飞翼、弹性盒子…）</h4><p><strong>圣杯布局：</strong></p>
<p>缺点：当面板的main部分比两边的子面板宽度小的时候，布局就会乱掉。</p>
<p><strong>双飞翼布局:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">与圣杯布局很像，也是全部往左浮动，但是在内容div里再嵌套一个div，设置子div的margin为左右div预留位置，左右div只设置margin负值即可实现。</span><br><span class="line"> 相似点：</span><br><span class="line">1.给main设置width: 100%，占满窗口，从而自适应。</span><br><span class="line">2.为了形成在一行三栏布局，给三个方块都加上浮动float: left;（注意清除浮动，因为浮动会导致父元素高度塌陷）</span><br><span class="line">3.利用负margin-left把三个方块拉到一行，margin-left负多少就是往左移动多少，左边需要相对父元素的-100%，移到父元素的最左边，右边只需要移动本身宽度的负值，即可在最右边。</span><br><span class="line"> 区别：</span><br><span class="line">1.双飞翼布局给主面板添加了一个父标签用来通过margin给子面板腾出空间。</span><br><span class="line">2.圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局的问题。</span><br><span class="line">3.双飞翼布局不用设置相对布局，以及对应的left和right值。</span><br></pre></td></tr></table></figure>

<p><strong>flex布局</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：顺着主轴依次放3列，内容在最前，通过order控制显示顺序，通过flex-grow让中间占据全部剩余空间，通过flex-basis设置左、右div的宽度。</span><br><span class="line">缺点：兼容性。</span><br></pre></td></tr></table></figure>

<h4 id="13-静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）"><a href="#13-静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）" class="headerlink" title="13.静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）"></a>13.静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）</h4><h5 id="静态布局（Static-Layout）"><a href="#静态布局（Static-Layout）" class="headerlink" title="静态布局（Static Layout）"></a>静态布局（Static Layout）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即传统Web设计，对于PC设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；</span><br><span class="line">对于移动设备，单独设计一个布局，使用不同的域名如wap.或m.。</span><br></pre></td></tr></table></figure>

<p>自适应布局（Adaptive Layout）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自适应布局（Adaptive）的特点是分别为不同的屏幕分辨率定义布局。布局切换时页面元素发生改变，但在每个布局中，页面元素不随窗口大小的调整发生变化。</span><br><span class="line">你可以把自适应布局看作是静态布局的一个系列。</span><br></pre></td></tr></table></figure>

<p>流式布局（Liquid Layout）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流式布局（Liquid）的特点（也叫&quot;Fluid&quot;) 是页面元素的宽度按照屏幕进行适配调整，主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。</span><br></pre></td></tr></table></figure>

<p>响应式布局（Responsive Layout）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。</span><br><span class="line">可以把响应式布局看作是流式布局和自适应布局设计理念的融合</span><br></pre></td></tr></table></figure>

<p>弹性布局（rem/em布局）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">包裹文字的各元素的尺寸采用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放；而页面的主要划分区域的尺寸仍使用百分数或px做单位。</span><br><span class="line">css 中的 px 是css设置自己大小，元素长宽的单位</span><br><span class="line">浏览器中em和px关系是 **16px** = **1em** </span><br><span class="line">rem是根据根节点，也就是html默认字体大小来设置大小的。所以改变了html根节点字体大小，em的默认值也会改变。向上面html设置为12px，那么**1rem=12px**了</span><br><span class="line">rem不是子节点继承父节点大小，而是所有的节点都继承html节点，所有当html节点设置成10px时候，所有整个页面1rem就等于10px了</span><br></pre></td></tr></table></figure>

<p>1.<strong>静态布局：</strong></p>
<p> <strong>布局特点：</strong>宽高固定</p>
<p>2.<strong>自适应布局</strong>：</p>
<p> <strong>布局特点：</strong>不同分辨率下，页面元素位置变化，大小不变</p>
<p> **实现方法:**针对不同分辨率创建对应的样式表，使用 @media 媒体查询给不同尺寸的设备切换不同的样式</p>
<p> <strong>缺点：</strong>IE8及以下不支持媒体查询；只能兼容主流分辨率</p>
<p> 3.<strong>流式布局（百分比布局）</strong>:</p>
<p><strong>布局特点：</strong>不同的分辨率下显示相同的排版；高度固定，宽度自适应</p>
<p> **实现方法:**网页中主要区域的尺寸使用百分比；</p>
<p> <strong>缺点：</strong>大屏幕上元素被拉长，但是文字，高度还是固定大小，不协调</p>
<p> 经典流式布局：左侧固定，右侧自适应；两侧固定，中间自适应</p>
<p>4.<strong>弹性布局（rem/em布局）</strong>：</p>
<p> <strong>布局特点：</strong>页面元素宽度，高度，字体大小会跟着屏幕大小缩放</p>
<p> **实现方法:**使用js监听当前屏幕大小，设置html的字体大小</p>
<p> <strong>缺点：</strong>IE678不兼容；需要计算；</p>
<p>5.<strong>响应式布局</strong>：一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本</p>
<p><strong>布局特点：</strong>每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变，响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表等等）都能显示出令人满意的效果</p>
<p> <strong>实现方法：</strong>媒体查询(css3中的Media Query)+流式布局</p>
<p>  媒介查询：通过不同的媒介类型和条件定义样式表规则，媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。</p>
<p> <strong>优点：</strong>适应pc和移动端 </p>
<p> 1.面对不同分辨率设备灵活性强</p>
<p>  2.能够快捷解决多设备显示适应问题</p>
<p> <strong>缺点：</strong>要匹配足够多的屏幕大小，工作量大，设计也需要多个版本</p>
<p> 1.会出现隐藏无用的元素</p>
<p>  2.加载时间加长</p>
<h4 id="14-less、sass、-stylus分别都有哪些优缺点？"><a href="#14-less、sass、-stylus分别都有哪些优缺点？" class="headerlink" title="14.less、sass、 stylus分别都有哪些优缺点？"></a>14.<strong>less、sass、 stylus分别都有哪些优缺点？</strong></h4><h4 id="15-说一下在IE（IE6）中常见的几个兼容性问题"><a href="#15-说一下在IE（IE6）中常见的几个兼容性问题" class="headerlink" title="15.说一下在IE（IE6）中常见的几个兼容性问题"></a>15.<strong>说一下在IE（IE6）中常见的几个兼容性问题</strong></h4><p>一、头文档所引起的怪异盒模型问题</p>
<p>产生条件：不设置文档声明，页面就会陷入怪异盒模型解析模式</p>
<p>解决方法：加入文档声明<!DOCTYPE html></p>
<p>二、IE6下双边距BUG</p>
<p>产生条件：在IE6下，块元素有浮动有横向的margin，横向的margin值<br>会被放大成两倍浮动方向与margin方向一致时，该方向会出现双倍边距</p>
<p>解决方法：display:inline</p>
<p>三、图片间隙问题</p>
<p>产生条件：给父容器设置宽度后，图片会在原来基础上把父元素撑大3-5px</p>
<p>解决方法：1.给父元素添加font-size：0；<br>2.给图片添加display：block；</p>
<p>四、li的间距问题</p>
<p>产生条件：IE6浏览器 li标签设置宽高，且li里面的元素发生了浮动<br>解决方法：1. li不设置宽高； </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. li内部的标签不进行浮动</span><br></pre></td></tr></table></figure>

<p>五、块状元素默认高度问题</p>
<p>产生条件：部分块状元素会有默认高度（一般为16px-18px之间）<br>解决方法： 1.给元素添加overflow:hidden;<br>                    2.font-size：0；</p>
<p>六、表单行高不一致</p>
<p>产生条件：一行中的文本输入框和按钮不在同一高度<br>解决办法：给表单元素添加float：left；并去掉默认边框border：0；</p>
<p>七、图片元素img下高度超出,出现多余空白  </p>
<p>解决方法：1.设置img为display:block;<br>                    2.父级设置overflow:hidden;</p>
<p>八、左浮元素margin-bottom失效</p>
<p>解决方法：1.显示设置高度<br>                    2.父标签设置_padding-bottom代替子标签的margin-bottom<br>                    3.再放个标签让父标签浮动，子标签margin- bottom，即(margin-bottom与float不同时                        作用于一个标签)</p>
<p>九、position下的left，bottom错位</p>
<p>解决方法：为父级(relative层)设置宽高或添加*zoom:1</p>
<p>十、子级中有设置position，则父级overflow失效</p>
<p>解决方法：为父级设置position:relative</p>
<p>十一、块元素中有文字及右浮动的行元素，行元素换行</p>
<p>解决方法：将行元素置于块元素内的文字前</p>
<p>十二、透明rgba与opacity</p>
<p>产生条件：IE6不支持此两种透明的设置方法<br> 解决方法：使用IE6当中的滤镜filter替代掉，<br>如：opacity:0.6;filter:alpha(opacity=60)异盒模型问题</p>
<h4 id="16-清空数组的方法"><a href="#16-清空数组的方法" class="headerlink" title="16.清空数组的方法"></a>16.清空数组的方法</h4><p>1.splice</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">ary.splice(<span class="number">0</span>,ary.length);</span><br><span class="line"><span class="built_in">console</span>.log(ary); <span class="comment">// 输出 []，空数组，即被清空了</span></span><br></pre></td></tr></table></figure>

<p>2.<strong>length赋值为0</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">ary.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ary); <span class="comment">// 输出 []，空数组，即被清空了</span></span><br></pre></td></tr></table></figure>

<p>3.<strong>赋值为[]</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">ary = []; <span class="comment">// 赋值为一个空数组以达到清空原数组</span></span><br></pre></td></tr></table></figure>



<h1 id="4-js"><a href="#4-js" class="headerlink" title="4.js"></a>4.js</h1><h5 id="1-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么"><a href="#1-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么" class="headerlink" title="1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?"></a>1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IE: trident内核</span><br><span class="line">Firefox：gecko内核</span><br><span class="line">Safari:webkit内核</span><br><span class="line">Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核</span><br><span class="line">Chrome:基于webkit</span><br><span class="line">只要能分清浏览器使用什么内核就得满分（safari和chrome使用webkit内核，Firefox使用gecko内核）</span><br></pre></td></tr></table></figure>

<h5 id="2-你简述盒模型"><a href="#2-你简述盒模型" class="headerlink" title="2.你简述盒模型"></a>2.你简述盒模型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing:content-box（W3C盒模型，又名标准盒模型）：元素的宽高大小表现为内容的大小。 </span><br><span class="line">box-sizing:border-box（IE盒模型，又名怪异盒模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。</span><br></pre></td></tr></table></figure>

<h5 id="3-CSS3的新特性"><a href="#3-CSS3的新特性" class="headerlink" title="3.CSS3的新特性"></a>3.CSS3的新特性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">word-wrap 文字换行</span><br><span class="line">text-overflow 超过指定容器的边界时如何显示</span><br><span class="line">text-decoration 文字渲染</span><br><span class="line">text-shadow文字阴影</span><br><span class="line">gradient渐变效果</span><br><span class="line">transition过渡效果 transition-duration：过渡的持续时间</span><br><span class="line">transform拉伸，压缩，旋转，偏移等变换</span><br><span class="line">animation动画</span><br><span class="line">transition和animation的区别： </span><br><span class="line"></span><br><span class="line">Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，  。</span><br></pre></td></tr></table></figure>

<h5 id="4-CSS选择器及其优先级"><a href="#4-CSS选择器及其优先级" class="headerlink" title="4.CSS选择器及其优先级"></a>4.CSS选择器及其优先级</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!important</span><br><span class="line">内联样式style=&quot;&quot;</span><br><span class="line">ID选择器#id</span><br><span class="line">类选择器/属性选择器/伪类选择器.class.active[href=&quot;&quot;]</span><br><span class="line">元素选择器/关系选择器/伪元素选择器html+div&gt;span::after</span><br><span class="line">通配符选择器*</span><br></pre></td></tr></table></figure>

<h5 id="5-说说BFC"><a href="#5-说说BFC" class="headerlink" title="5.说说BFC"></a>5.说说BFC</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 </span><br><span class="line">BFC应用</span><br><span class="line">防止margin重叠</span><br><span class="line">清除内部浮动</span><br><span class="line">自适应两（多）栏布局</span><br><span class="line">防止字体环绕</span><br><span class="line"></span><br><span class="line">触发BFC条件</span><br><span class="line">根元素</span><br><span class="line">float的值不为none</span><br><span class="line">overflow的值不为visible</span><br><span class="line">display的值为inline-block、table-cell、table-caption</span><br><span class="line">position的值为absolute、fixed</span><br><span class="line"></span><br><span class="line">BFC的特性</span><br><span class="line">内部的Box会在垂直方向上一个接一个的放置。</span><br><span class="line">垂直方向上的距离由margin决定</span><br><span class="line">bfc的区域不会与float的元素区域重叠。</span><br><span class="line">计算bfc的高度时，浮动元素也参与计算</span><br><span class="line">bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</span><br></pre></td></tr></table></figure>

<h5 id="6-说说定位相关的属性"><a href="#6-说说定位相关的属性" class="headerlink" title="6.说说定位相关的属性"></a>6.说说定位相关的属性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">position 属性的五个值：</span><br><span class="line">| **值**   | **描述**                                                     |</span><br><span class="line">| -------- | ------------------------------------------------------------ |</span><br><span class="line">| static   | 默认。位置设置为 static 的元素，   它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。HTML 元素的默认值，即没有定位，遵循正常的文档流对象。从上到下,从左到右   静态定位的元素不会受到 top, bottom, left, right影响。 |</span><br><span class="line">| absolute | 位置设置为 absolute 的元素，可定位于相对于第一个已定位（非静态的）的包含它的元素的指定坐标。   绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;   此元素的位置可通过 &quot;left&quot;、&quot;top&quot;、&quot;right&quot; 以及 &quot;bottom&quot; 属性来规定。   absolute 定位使元素的位置与文档流无关，因此不占据空间。   absolute 定位的元素和其他元素重叠。   会将原来的块元素变成行内块元素 |</span><br><span class="line">| fixed    | 位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动   此元素的位置可通过 &quot;left&quot;、&quot;top&quot;、&quot;right&quot; 以及 &quot;bottom&quot; 属性来规定。   不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。   会将原来的块元素变成行内块元素 |</span><br><span class="line">| relative | 位置被设置为 relative 的元素，可将其定位于相对于其正常位置的地方，   因此 &quot;left:20&quot; 会将元素移至元素正常位置左边 20 个像素的位置。   相对定位元素的定位是相对其自身正常位置。   移动相对定位元素，但它原本所占的空间不会改变。 |</span><br><span class="line">| sticky   | sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。   position:   sticky; 基于用户的滚动位置来定位。   粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。   它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。   元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。   这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top,   right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 |</span><br><span class="line">| inherit  | position 属性的值从父元素继承。                              |</span><br></pre></td></tr></table></figure>

<h5 id="7-谈谈flex布局"><a href="#7-谈谈flex布局" class="headerlink" title="7.谈谈flex布局"></a>7.谈谈flex布局</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">采用 Flex 布局的元素，称为 Flex容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex项目（flex item），简称“项目”。</span><br><span class="line">1.父元素属性</span><br><span class="line">| **属性名**      | **属性值**      | **备注** </span><br><span class="line">| display        | flex          | 定义了一个flex容器，它的直接子元素会接受这个flex环境         |</span><br><span class="line">| flex-direction | row,   row-reverse,   column,   column-reverse  | 决定主轴的方向         </span><br><span class="line">| flex-wrap       | nowrap,   wrap,   wrap-reverse   | 如果一条轴线排不下，如何换行           </span><br><span class="line">| flex-flow       | [flex-direction] , [flex-wrap] | 是 flex-direction属性和    flex-wrap属性的简写形式，   默认值为 row nowrap |</span><br><span class="line">| justify-content | flex-start,   flex-end,   center,   space-between,   space-around | 设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式         |</span><br><span class="line">| align-items     | flex-start,   flex-end,   center,   baseline,   stretch      | 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式         |                                 |</span><br><span class="line">2.子元素属性      |                                                              |         </span><br><span class="line">| 属性名          | 属性值           | 备注     </span><br><span class="line">| order           | [int]    | 默认情况下flex order会按照书写顺训呈现，   可以通过order属性改变，   数值小的在前面，还可以是负数。 |</span><br><span class="line">| flex-grow       | [number]  | 设置或检索弹性盒的扩展比率,   根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间 |</span><br><span class="line">| flex-shrink     | [number]  | 设置或检索弹性盒的收缩比率,   根据弹性盒子元素所设置的收缩因子作为比率来收缩空间 |</span><br><span class="line">| flex-basis      | [length], auto  | 设置或检索弹性盒伸缩基准值                               </span><br><span class="line">| align-self      | auto,flex-start,flex-end,center,baseline,stretch   | 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，   可以覆盖父容器align-items的设置 |</span><br></pre></td></tr></table></figure>

<h5 id="8-你怎么清楚浮动"><a href="#8-你怎么清楚浮动" class="headerlink" title="8.你怎么清楚浮动"></a>8.你怎么清楚浮动</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1、在浮动元素后面添加 clear:both 的空 div 元素</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">2、给父元素添加 overflow:hidden 或者 auto 样式，触发BFC。</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">​    width: 300px;</span><br><span class="line">​    background-color: #aaa;</span><br><span class="line">​    overflow:hidden;</span><br><span class="line">​    zoom:1;   /*IE6*/</span><br><span class="line">&#125;</span><br><span class="line">3、使用伪元素，也是在元素末尾添加一个点并带有 clear: both 属性的元素实现的。</span><br><span class="line">&lt;div class=&quot;container  clearfix&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">​    zoom: 1; /*IE6*/</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">​    content: &quot;.&quot;;</span><br><span class="line">​    height: 0;</span><br><span class="line">​    clear: both;</span><br><span class="line">​    display: block;</span><br><span class="line">​    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">推荐使用第三种方法，不会在页面新增div，文档结构更加清晰。</span><br></pre></td></tr></table></figure>

<h5 id="9-两边宽度固定中间自适应的三栏布局-默写题-手写笔试题"><a href="#9-两边宽度固定中间自适应的三栏布局-默写题-手写笔试题" class="headerlink" title="9.两边宽度固定中间自适应的三栏布局(默写题,手写笔试题)"></a>9.两边宽度固定中间自适应的三栏布局(默写题,手写笔试题)</h5><p>圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。<br>圣杯布局<br>双飞翼布局</p>
<h5 id="10-浏览器渲染机制"><a href="#10-浏览器渲染机制" class="headerlink" title="10.浏览器渲染机制"></a>10.浏览器渲染机制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node</span><br><span class="line">构建渲染树（construct）：解析对应的CSS样式文件信息</span><br><span class="line">布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；</span><br><span class="line">绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点</span><br></pre></td></tr></table></figure>

<h5 id="11-重绘和回流的区别"><a href="#11-重绘和回流的区别" class="headerlink" title="11.重绘和回流的区别"></a>11.重绘和回流的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</span><br><span class="line">重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局）</span><br><span class="line"></span><br><span class="line">回流（重构/重排/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。</span><br><span class="line">触发回流的条件：任何页面布局和几何属性的改变都会触发回流：</span><br><span class="line">页面渲染初始化(无法避免)</span><br><span class="line">添加或删除可见的DOM元素</span><br><span class="line">元素位置的改变，或者使用动画</span><br><span class="line">元素尺寸的改变——大小，外边距，边框</span><br><span class="line">浏览器窗口尺寸的变化</span><br><span class="line">填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变</span><br><span class="line"></span><br><span class="line">回流必定会引发重绘，但重绘不一定会引发回流。</span><br></pre></td></tr></table></figure>

<h5 id="12-JS数据类型"><a href="#12-JS数据类型" class="headerlink" title="12.JS数据类型"></a>12.JS数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1基本数据类型:string,number,Boolean,null,undefined;</span><br><span class="line">2引用数据类型object(Object,Array),function</span><br><span class="line">3 ES6新增 symbol</span><br></pre></td></tr></table></figure>

<h5 id="13-JS判断数据类型的方法"><a href="#13-JS判断数据类型的方法" class="headerlink" title="13.JS判断数据类型的方法"></a>13.JS判断数据类型的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typeof</span><br><span class="line">console.log(typeof 2);               // number</span><br><span class="line">console.log(typeof true);            // boolean</span><br><span class="line">console.log(typeof &#x27;str&#x27;);           // string</span><br><span class="line">console.log(typeof undefined);       // undefined</span><br><span class="line">console.log(typeof []);              // object </span><br><span class="line">console.log(typeof &#123;&#125;);              // object</span><br><span class="line">console.log(typeof function()&#123;&#125;);    // function</span><br><span class="line">console.log(typeof null);            // object</span><br><span class="line">优点：能够快速区分基本数据类型 </span><br><span class="line">缺点：不能将Object、Array和Null区分，都返回object</span><br><span class="line"></span><br><span class="line">instanceof</span><br><span class="line">console.log(2 instanceof Number);                    // false</span><br><span class="line">console.log(true instanceof Boolean);                // false </span><br><span class="line">console.log(&#x27;str&#x27; instanceof String);                // false  </span><br><span class="line">console.log([] instanceof Array);                    // true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class="line">console.log(&#123;&#125; instanceof Object);                   // true</span><br><span class="line">优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 </span><br><span class="line">缺点：Number，Boolean，String基本数据类型不能判断</span><br><span class="line"> </span><br><span class="line">Object.prototype.toString.call()</span><br><span class="line">console.log(toString.call(2));                      //[object Number]</span><br><span class="line">console.log(toString.call(true));                   //[object Boolean]</span><br><span class="line">console.log(toString.call(&#x27;str&#x27;));                  //[object String]</span><br><span class="line">console.log(toString.call([]));                     //[object Array]</span><br><span class="line">console.log(toString.call(function()&#123;&#125;));           //[object Function]</span><br><span class="line">console.log(toString.call(&#123;&#125;));                     //[object Object]</span><br><span class="line">console.log(toString.call(undefined));              //[object Undefined]</span><br><span class="line">console.log(toString.call(null));                   //[object Null]</span><br><span class="line">优点：精准判断数据类型 </span><br><span class="line">缺点：写法繁琐不容易记，推荐进行封装后使用</span><br></pre></td></tr></table></figure>

<h5 id="14-null和undefined区别"><a href="#14-null和undefined区别" class="headerlink" title="14.null和undefined区别"></a>14.null和undefined区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法：</span><br><span class="line">变量被声明了，但没有赋值时，就等于undefined。</span><br><span class="line">调用函数时，应该提供的参数没有提供，该参数等于undefined。</span><br><span class="line">对象没有赋值的属性，该属性的值为undefined。</span><br><span class="line">函数没有返回值时，默认返回undefined。</span><br><span class="line">Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法</span><br><span class="line">作为函数的参数，表示该函数的参数不是对象。</span><br><span class="line">作为对象原型链的终点。</span><br></pre></td></tr></table></figure>

<h5 id="15-JS作用域的理解"><a href="#15-JS作用域的理解" class="headerlink" title="15.JS作用域的理解"></a>15.JS作用域的理解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS中的作用域分为两种：全局作用域和函数作用域。函数作用域中定义的变量，只能在函数中调用，外界无法访问。没有块级作用域导致了if或for这样的逻辑语句中定义的变量可以被外界访问，因此ES6中新增了let和const命令来进行块级作用域的声明。</span><br></pre></td></tr></table></figure>

<h5 id="16-call-apply和bind区别的页面在哪些流览器测"><a href="#16-call-apply和bind区别的页面在哪些流览器测" class="headerlink" title="16.call,apply和bind区别的页面在哪些流览器测"></a>16.call,apply和bind区别的页面在哪些流览器测</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">三个函数的作用都是将函数绑定到上下文中，用来改变函数中this的指向；三者的不同点在于语法的不同。</span><br><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">fun.apply(thisArg, [argsArray])</span><br><span class="line">所以 apply和 call的区别是 call方法接受的是若干个参数列表，而 apply接收的是一个包含多个参数的数组。</span><br><span class="line">而bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</span><br><span class="line">var bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">bindFn()</span><br></pre></td></tr></table></figure>

<h5 id="17-深拷贝和浅拷贝"><a href="#17-深拷贝和浅拷贝" class="headerlink" title="17.深拷贝和浅拷贝"></a>17.深拷贝和浅拷贝</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。</span><br><span class="line">浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</span><br><span class="line">深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</span><br></pre></td></tr></table></figure>

<h5 id="18-谈谈防抖和节流"><a href="#18-谈谈防抖和节流" class="headerlink" title="18.谈谈防抖和节流"></a>18.谈谈防抖和节流</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">说白了，防抖节流就是使用定时器来实现我们的目的。</span><br><span class="line">防抖(debounce)：</span><br><span class="line">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</span><br><span class="line">典型的案例就是输入框搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时。</span><br><span class="line">节流(throttle)：</span><br><span class="line">规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。</span><br><span class="line">典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只生效一次。</span><br><span class="line">为什么要掌握防抖和节流</span><br><span class="line">函数节流（throttle）与函数防抖（debounce）都是可以限制函数的执行频次，根据不同的场景来对执行频率进行限制，避免了函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。</span><br></pre></td></tr></table></figure>

<h5 id="19-谈谈cookie-sessionStorage和localStorage"><a href="#19-谈谈cookie-sessionStorage和localStorage" class="headerlink" title="19.谈谈cookie,sessionStorage和localStorage"></a>19.谈谈cookie,sessionStorage和localStorage</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cookie用来保存登录信息，大小限制为4KB左右</span><br><span class="line">localStorage是Html5新增的，用于本地数据存储，保存的数据没有过期时间，一般浏览器大小限制在5MB</span><br><span class="line">sessionStorage接口方法和localStorage类似，但保存的数据的只会在当前会话中保存下来，页面关闭后会被清空。</span><br><span class="line">| **名称**       | **生命期**       | **大小** | **与服务器通信**                             </span><br><span class="line">| cookie       | 一般由服务器生成，可设置失效时间。   如果在浏览器端生成Cookie，   默认是关闭浏览器后失效 | 4KB      | 每次都会携带在HTTP头中，   如果使用cookie保存过多数据会带来性能问题 |</span><br><span class="line">| localStorage   | 除非被清除，   否则永久保存                                  | 5MB      | 仅在浏览器中保存，不与服务器通信                             |</span><br><span class="line">| sessionStorage | 仅在当前会话下有效，   关闭页面或浏览器后被清除              | 5MB      | 仅在浏览器中保存，不与服务器通信                             |</span><br></pre></td></tr></table></figure>

<h5 id="20-0-1-0-2-0-3怎么处理"><a href="#20-0-1-0-2-0-3怎么处理" class="headerlink" title="20.0.1+0.2!=0.3怎么处理"></a>20.0.1+0.2!=0.3怎么处理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在计算机中数字无论是定点数还是浮点数都是以多位二进制的方式进行存储的,计算机天生只能存储整数，它只能用某种方法来表示小数</span><br><span class="line">解决方法：</span><br><span class="line">1.把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。N&gt;1.</span><br><span class="line">(0.1*10+ 0.2*10)/10== 0.3//true</span><br><span class="line">2.四舍五入  Match.</span><br></pre></td></tr></table></figure>

<h5 id="21-数组的常用方法-至少说出8个"><a href="#21-数组的常用方法-至少说出8个" class="headerlink" title="21.数组的常用方法(至少说出8个)"></a>21.数组的常用方法(至少说出8个)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.shift 删除数组中的第一个元素</span><br><span class="line">2.pop 删除数组中的最后一个元素</span><br><span class="line">3.unshift 增加元素在数组的前面</span><br><span class="line">4.push 增加元素在数组的后面</span><br><span class="line">5.map 循环，并且返回新的数组</span><br><span class="line">6.forEach 循环，遍历</span><br><span class="line">7.filter 过滤，筛选出数组中的满足条件的，并且返回新的数组</span><br><span class="line">8.concnt 合并数组</span><br><span class="line">9.find 查找出第一个符合条件中的数组元素</span><br><span class="line">10.findIndex 查找出第一个符合条件中的数组元素，所在的索引位置</span><br><span class="line">11.flat 将多维数组转为一维数组</span><br><span class="line">12.join将数组转为字符串</span><br><span class="line">13.reverse 颠倒数组中的顺序</span><br><span class="line">14.every检测数组中元素是否都是符合条件 === bollean</span><br><span class="line">15.some检测数组中元素是否有满足条件的元素 === bollean</span><br><span class="line">16.splice(start,n,添加元素) 开始位置 删除个数，添加元素</span><br><span class="line">17.sort 排序</span><br><span class="line">18.slice(start,end) 选中[start.end)之间的元素</span><br><span class="line">19.indexOf 查找值所在的位置</span><br><span class="line">20.includes 查看数组中是否存在此元素</span><br></pre></td></tr></table></figure>

<h5 id="22-new一个对象的过程中发生了什么吗"><a href="#22-new一个对象的过程中发生了什么吗" class="headerlink" title="22.new一个对象的过程中发生了什么吗?"></a>22.new一个对象的过程中发生了什么吗?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\1. 创建空对象；</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">\2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；</span><br><span class="line">obj.__proto__ = ClassA.prototype;</span><br><span class="line">\3. 使用新对象调用函数，函数中的this被指向新实例对象：</span><br><span class="line">ClassA.call(obj);//&#123;&#125;.构造函数();</span><br><span class="line">\4. 将初始化完毕的新对象地址，保存到等号左边的变量中</span><br></pre></td></tr></table></figure>

<p>23.JS实现继承(至少会一种)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 原型链</span><br><span class="line">2. 借用构造函数</span><br><span class="line">3. 组合继承</span><br><span class="line">4. 寄生式继承</span><br><span class="line">6. 原型式继承　　</span><br></pre></td></tr></table></figure>

<h5 id="24-get和post区别"><a href="#24-get和post区别" class="headerlink" title="24.get和post区别"></a>24.get和post区别</h5><table>
<thead>
<tr>
<th><strong>请求方式</strong></th>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td>参数位置</td>
<td>参数拼接到url的后面</td>
<td>参数在请求体中</td>
</tr>
<tr>
<td>参数大小</td>
<td>受限于浏览器url大小，一般不超过32K</td>
<td>1G</td>
</tr>
<tr>
<td>服务器数据接收</td>
<td>接收1次</td>
<td>根据数据大小，可分多次接收</td>
</tr>
<tr>
<td>适用场景</td>
<td>从服务器端获取数据</td>
<td>向服务器提交数据</td>
</tr>
<tr>
<td>安全性</td>
<td>参数携带在url中，安全性低</td>
<td>相对于GET请求，安全性更高</td>
</tr>
</tbody></table>
<h5 id="25-JSONP原理"><a href="#25-JSONP原理" class="headerlink" title="25.JSONP原理"></a>25.JSONP原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由于浏览器的同源策略限制，不允许跨域请求；但是页面中的 script、img、iframe标签是例外，不受同源策略限制。</span><br><span class="line">Jsonp 就是利用 script标签跨域特性进行请求。</span><br><span class="line">JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好一个同名回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数。</span><br><span class="line">JSONP缺点：它只支持 GET请求，而不支持 POST请求等其他类型的HTTP请求。</span><br></pre></td></tr></table></figure>

<h5 id="26-缓存的理解"><a href="#26-缓存的理解" class="headerlink" title="26.缓存的理解"></a>26.缓存的理解</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。</span><br><span class="line">强缓存:</span><br><span class="line">Expires</span><br><span class="line">cache-control</span><br><span class="line">协商缓存:</span><br><span class="line">Last-Modified 和 If-Modified-Since</span><br><span class="line">Etag 和 If-None-Match</span><br></pre></td></tr></table></figure>

<h5 id="27-XSS和CSRF区别"><a href="#27-XSS和CSRF区别" class="headerlink" title="27.XSS和CSRF区别"></a>27.XSS和CSRF区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表 CSS 混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</span><br><span class="line">跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。</span><br><span class="line">区别：</span><br><span class="line">原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注入JS代码，然后执行JS里的代码。</span><br><span class="line">CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录</span><br><span class="line">CSRF的目标是用户，XSS的目标是服务器</span><br><span class="line">XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求</span><br></pre></td></tr></table></figure>

<h5 id="28-HTTP与HTTPS的区别"><a href="#28-HTTP与HTTPS的区别" class="headerlink" title="28.HTTP与HTTPS的区别"></a>28.HTTP与HTTPS的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP的URL由 http://起始且默认使用端口80，而HTTPS的URL由 https://起始且默认使用端口443</span><br><span class="line">HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的 SSL 加密传输协议</span><br><span class="line">HTTP的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全</span><br></pre></td></tr></table></figure>

<h5 id="29-HTTP状态码"><a href="#29-HTTP状态码" class="headerlink" title="29.HTTP状态码"></a>29.HTTP状态码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1XX 信息性状态码</span><br><span class="line">2XX 成功状态码</span><br><span class="line">3XX 重定向状态码</span><br><span class="line">4XX客户端错误状态码</span><br><span class="line">5XX服务器错误状态码</span><br><span class="line">我们常见的状态码有200--表示客户端请求成功，400--表示客户端请求有语法错误，403--表示服务器收到请求，但是没有权限，404--表示请求资源不存在，500--表示服务器端错误</span><br></pre></td></tr></table></figure>

<h5 id="30-事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件"><a href="#30-事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件" class="headerlink" title="30.事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件"></a>30.事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">事件捕获</span><br><span class="line">捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)</span><br><span class="line">事件冒泡</span><br><span class="line">冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。</span><br><span class="line">阻止事件的传播,阻止事件冒泡：</span><br><span class="line">• 在W3c中，使用stopPropagation（）方法</span><br><span class="line">• 在IE下设置cancelBubble = true；</span><br><span class="line">阻止事件的默认行为，例如click &lt;a&gt;后的跳转~</span><br><span class="line">• 在W3c中，使用preventDefault（）方法；</span><br><span class="line">• 在IE下设置window.event.returnValue = false;</span><br></pre></td></tr></table></figure>

<h5 id="31-Js事件循环机制"><a href="#31-Js事件循环机制" class="headerlink" title="31.Js事件循环机制"></a>31.Js事件循环机制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在线程之内，又被分为了两个队列：同步任务队列,异步任务队列</span><br><span class="line">同步环境执行(step1) -&gt; 事件循环1(step4) -&gt; 事件循环2(step4的重复)…</span><br><span class="line">　　其中的异步进程有：</span><br><span class="line">　　　　a、类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中；</span><br><span class="line">　　　　b、setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中；</span><br><span class="line">　　　　c、Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中。</span><br><span class="line">异步执行的运行机制</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure>

<h5 id="32-面向对象、原型、原型链、继承"><a href="#32-面向对象、原型、原型链、继承" class="headerlink" title="32.面向对象、原型、原型链、继承"></a>32.面向对象、原型、原型链、继承</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="33-什么是闭包，使用场景及优缺点？"><a href="#33-什么是闭包，使用场景及优缺点？" class="headerlink" title="33.什么是闭包，使用场景及优缺点？"></a>33.什么是闭包，使用场景及优缺点？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">闭包的概念</span><br><span class="line">   当一个函数内部嵌套另一个函数，子函数可以访问到父级函数中的变量，就是闭包。严格来说，闭包产生的三个条件</span><br><span class="line">  1.必须是嵌套关系 2.内部函数访问其所在的作用域 3.在所在作用域外被调用**</span><br><span class="line">**闭包的作用与应用场景**</span><br><span class="line">作用一 使变量在内存中保存不被销毁。</span><br><span class="line">作用二，延长了函数内局部变量的作用范围。</span><br></pre></td></tr></table></figure>

<h5 id="34-this指向"><a href="#34-this指向" class="headerlink" title="34.this指向"></a>34.this指向</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通函数调用，此时 this 指向 window</span><br><span class="line">构造函数调用， 此时 this 指向 实例对象</span><br><span class="line">对象方法调用， 此时 this 指向 该方法所属的对象</span><br><span class="line">通过事件绑定的方法， 此时 this 指向 绑定事件的对象</span><br><span class="line">定时器函数， 此时 this 指向 window</span><br><span class="line">箭头函数中的this指向，箭头函数中没有自己的this，它的this是继承而来，默认指向在定义它时所处的对象(宿主对象)。</span><br><span class="line">当函数被当作监听事件处理函数时，其this指向触发该事件的元素（针对于addEventListener 事件）</span><br><span class="line">更改this指向的三个方法</span><br><span class="line">call() 方法 （.call(obj,2,3)）</span><br><span class="line">apply() 方法（.apply(obj.[2,3])）</span><br><span class="line">call接受的参数为一个一个的，但是apply接受的参数只能为一个严格的数组</span><br><span class="line">bind()方法 (.bind(obj))</span><br></pre></td></tr></table></figure>

<h5 id="35-箭头函数和普通函数的区别？"><a href="#35-箭头函数和普通函数的区别？" class="headerlink" title="35.箭头函数和普通函数的区别？"></a>35.箭头函数和普通函数的区别？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</span><br><span class="line">（2）箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</span><br><span class="line">（3）箭头函数不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</span><br><span class="line">（4）箭头函数不可以使用yield命令，因此箭头函数不能用作 Generator 函数</span><br><span class="line">（5）箭头函数使用call()和apply()调用</span><br></pre></td></tr></table></figure>

<h5 id="36-什么是promise"><a href="#36-什么是promise" class="headerlink" title="36.什么是promise?"></a>36.什么是promise?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单来说可以把promise当作一个装着异步操作结果的容器。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。它将异步函数以同步的方式书写，也解决了回调地狱问题</span><br><span class="line">特点：（1）对象状态不受外界影响  </span><br><span class="line">     （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果</span><br><span class="line">缺点：（1），无法取消promise，一旦新建它就会立即执行，无法中途取消  </span><br><span class="line">     （2），如果不设置回调函数，promise内部抛出的错误，不会反应到外部 </span><br><span class="line">     （3）无法得知目前进展到哪一个阶段（刚刚开始还是即将结束）</span><br><span class="line">三个状态：进行中、已成功、以失败。 </span><br></pre></td></tr></table></figure>

<h5 id="37-什么是ajax？"><a href="#37-什么是ajax？" class="headerlink" title="37.什么是ajax？"></a>37.什么是ajax？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即异步的 JavaScript 和 XML，是一种用于创建快速动态网页的技术；传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。使用AJAX则不需要加载更新整个网页，实现部分内容更新。</span><br></pre></td></tr></table></figure>

<h1 id="5-兼容性"><a href="#5-兼容性" class="headerlink" title="5.兼容性"></a>5.兼容性</h1><h4 id="1、IE8-下面的-png-图片无法正常显示？"><a href="#1、IE8-下面的-png-图片无法正常显示？" class="headerlink" title="1、IE8 下面的 png 图片无法正常显示？"></a>1、IE8 下面的 png 图片无法正常显示？</h4><p>原因：打开调试面板，你会发现 IE8 浏览器把 PNG 格式的 img 解析成了 span 标签，导致图无法显<br>示。<br>解决方案：在样式里面对 span 设置宽高和 display:inline-block;即可。</p>
<h4 id="2、rgba-不支持-IE8？"><a href="#2、rgba-不支持-IE8？" class="headerlink" title="2、rgba 不支持 IE8？"></a>2、rgba 不支持 IE8？</h4><p>解决方案:可以用 opacity<br>opacity:0.7;/<strong>FF chrome safari opera</strong>/<br>filter:alpha(opacity:70);/<em>用了 ie 滤镜,可以兼容 ie</em>/<br>但是,需要注意的是,opacity 会影响里面元素的透明度</p>
<h4 id="3、Css3-的新属性？"><a href="#3、Css3-的新属性？" class="headerlink" title="3、Css3 的新属性？"></a>3、Css3 的新属性？</h4><p>当一些 CSS3 样式语法还存在波动时，它们提供针对浏览器的前缀。现在主要流行的浏览器内核主<br>要有：<br>Trident 内核：主要代表为 IE 浏览器<br>Gecko 内核：主要代表为 Firefox   FF<br>Presto 内核：主要代表为 Opera<br>Webkit 内核：产要代表为 Chrome 和 Safari<br>而这些不同内核的浏览器，CSS3 属性（部分需要添加前缀的属性）对应需要添加不同的前缀，也将<br>其称之为浏览器的私有前缀，添加上私有前缀之后的 CSS3 属性可以说是对应浏览器的私有属性：<br>Trident 内核：前缀为-ms<br>Gecko 内核：前缀为-moz<br>Presto 内核：前缀为-o<br>Webkit 内核：前缀为-webkit</p>
<h4 id="4、document-form-item-问题"><a href="#4、document-form-item-问题" class="headerlink" title="4、document.form.item 问题"></a>4、document.form.item 问题</h4><p>问题：代码中存在 document.formName.item(“itemName”) 这样的语句，不能在 FF 下运行<br>解决方法：改用 document.formName.elements[“elementName”]</p>
<h4 id="5、集合类对象问题"><a href="#5、集合类对象问题" class="headerlink" title="5、集合类对象问题"></a>5、集合类对象问题</h4><p>问题：代码中许多集合类对象取用时使用()，IE 能接受，FF 不能<br>解决方法：<br>改用 [] 作为下标运算，例：<br>document.getElementsByName(“inputName”)(1)  改 为<br>document.getElementsByName(“inputName”)[1]</p>
<h4 id="6、window-event-event"><a href="#6、window-event-event" class="headerlink" title="6、window.event || event"></a>6、window.event || event</h4><p>问题：使用 window.event 无法在 FF 上运行<br>解决方法：<br>FF 的 event 只能在事件发生的现场使用，此问题暂无法解决。可以把 event 传到函数里变通<br>解决：<br>onMouseMove = “functionName(event)”<br>function functionName (e) {<br>e = e || window.event;<br>……<br>}</p>
<h4 id="7、HTML-对象的-id-作为对象名的问题"><a href="#7、HTML-对象的-id-作为对象名的问题" class="headerlink" title="7、HTML 对象的 id 作为对象名的问题"></a>7、HTML 对象的 id 作为对象名的问题</h4><p>问题：在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用，在 FF 中不能<br>解决方法：<br>使用对象变量时全部用标准的 getElementById(“idName”)  通过id取dom节点</p>
<h4 id="8、用-idName-字符串取得对象的问题"><a href="#8、用-idName-字符串取得对象的问题" class="headerlink" title="8、用 idName 字符串取得对象的问题"></a>8、用 idName 字符串取得对象的问题</h4><p>问题：在 IE 中，利用 eval_r(“idName”) 可以取得 id 为 idName 的 HTML 对象，在 FF 中不能<br>解决方法：<br>用 getElementById(“idName”) 代替 eval_r(“idName”)</p>
<h4 id="9、变量名与某-HTML-对象-id-相同的问题"><a href="#9、变量名与某-HTML-对象-id-相同的问题" class="headerlink" title="9、变量名与某 HTML 对象 id 相同的问题"></a>9、变量名与某 HTML 对象 id 相同的问题</h4><p>问题：在 FF 中，因为对象 id 不作为 HTML 对象的名称，所以可以使用与 HTML 对象 id 相同的变量<br>名，IE 中不能<br>解决方法：<br>在声明变量时，一律加上 var ，以避免歧义，这样在 IE 中亦可正常运行<br>最好不要取与 HTML 对象 id 相同的变量名，以减少错误    </p>
<h4 id="10、event-x-与-event-y-问题"><a href="#10、event-x-与-event-y-问题" class="headerlink" title="10、event.x 与 event.y 问题"></a>10、event.x 与 event.y 问题</h4><p>问题：在 IE 中，event 对象有 x,y 属性，FF 中没有<br>解决方法：<br>在 FF 中，与 event.x 等效的是 event.pageX ，但 event.pageX IE 中没有<br>故采用 event.clientX 代替 event.x ，在 IE 中也有这个变量<br>event.clientX 与 event.pageX 有微妙的差别，就是滚动条<br>要完全一样，可以这样：<br>mX = event.x ? event.x : event.pageX;<br>然后用 mX 代替 event.x</p>
<h4 id="11、-取得元素的属性"><a href="#11、-取得元素的属性" class="headerlink" title="11、 取得元素的属性"></a>11、 取得元素的属性</h4><p>在 FF 中，自己定义的属性必须 getAttribute() 取得  </p>
<p>在 FF 中没有 parentElement，parement.children 而用 parentNode，parentNode.childNodes</p>
<p>问题：<br>childNodes 的下标的含义在 IE 和 FF 中不同，FF 的 childNodes 中会插入空白文本节点<br>解决方法：<br>可以通过 node.getElementsByTagName_r() 来回避这个问题<br>问题：当 html 中节点缺失时，IE 和 FF 对 parentNode 的解释不同，例如：<br>​      FF 中 input.parentNode 的值为 form，而 IE 中 input.parentNode    的值为空节点<br>​问题：FF 中节点自己没有 removeNode 方法<br>解决方法：<br>   必须使用如下方法 node.parentNode.removeChild(node)</p>
<h4 id="12、const-问题"><a href="#12、const-问题" class="headerlink" title="12、const 问题"></a>12、const 问题</h4><p>问题：在 IE 中不能使用 const 关键字<br>解决方法：以 var 代替</p>
<h4 id="13、body-对象"><a href="#13、body-对象" class="headerlink" title="13、body 对象"></a>13、body 对象</h4><p>FF 的 body 在 body 标签没有被浏览器完全读入之前就存在，而 IE 则必须在 body 完全被读<br>入之后才存在<br>这会产生在 IE 下，文档没有载入完时，在 body 上 appendChild 会出现空白页面的问题<br>解决方法：<br>一切在 body 上插入节点的动作，全部在 onload 后进行</p>
<h4 id="14、url-encoding"><a href="#14、url-encoding" class="headerlink" title="14、url encoding"></a>14、url encoding</h4><p>问题：<br>一般 FF 无法识别 js 中的&amp;</p>
<p>解决方法：<br>在 js 中如果书写 url 就直接写&amp;不要写&amp;</p>
<h4 id="15、nodeName-和-tagName-问题"><a href="#15、nodeName-和-tagName-问题" class="headerlink" title="15、nodeName 和 tagName 问题"></a>15、nodeName 和 tagName 问题</h4><p>问题：<br>在 FF 中，所有节点均有 nodeName 值，但 textNode 没有 tagName 值，在 IE 中，nodeName<br>的使用有问题<br>解决方法：<br>使用 tagName，但应检测其是否为空</p>
<h4 id="16-元素属性"><a href="#16-元素属性" class="headerlink" title="16.元素属性"></a>16.元素属性</h4><p>IE下input.type 属性为只读，但是FF下可以修改</p>
<p> document.getElementsByName() 和document.all[name] 的问题</p>
<p>问题：在IE中，getElementsByName()、document.all[name] 均不能用来取得div 元素是否还有其它不能取的元素还不知道（这个问题还有争议，还在研究中）</p>
<h4 id="17-调用子框架或者其它框架中的元素的问题"><a href="#17-调用子框架或者其它框架中的元素的问题" class="headerlink" title="17.调用子框架或者其它框架中的元素的问题"></a>17.调用子框架或者其它框架中的元素的问题</h4><p>在IE中，可以用如下方法来取得子元素中的值</p>
<p>document.getElementByIdx_x(“frameName”).(document.)elementName</p>
<p>window.frames[“frameName”].elementName</p>
<p>在FF中则需要改成如下形式来执行，与IE兼容：window.frames[“frameName”].contentWindow.document.elementName</p>
<p>window.frames[“frameName”].document.elementName</p>
<h4 id="18-对象宽高赋值问题"><a href="#18-对象宽高赋值问题" class="headerlink" title="18.对象宽高赋值问题"></a>18.对象宽高赋值问题</h4><p>问题：FireFox中类似obj.style.height = imgObj.height 的语句无效</p>
<p>解决方法：统一使用obj.style.height = imgObj.height + “px”;</p>
<h4 id="19-innerText的问题"><a href="#19-innerText的问题" class="headerlink" title="19.innerText的问题"></a>19.innerText的问题</h4><p>问题：innerText 在IE中能正常工作，但是innerText 在FireFox中却不行</p>
<p>解决方法：在非IE浏览器中使用textContent代替innerText</p>
<h4 id="20-event-srcElement和event-toElement问题"><a href="#20-event-srcElement和event-toElement问题" class="headerlink" title="20.event.srcElement和event.toElement问题"></a>20.event.srcElement和event.toElement问题</h4><p>问题：IE下，even对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性</p>
<p>解决方法：var source = e.target || e.srcElement;var target = e.relatedTarget || e.toElement;</p>
<h4 id="21-禁止选取网页内容"><a href="#21-禁止选取网页内容" class="headerlink" title="21.禁止选取网页内容"></a>21.禁止选取网页内容</h4><p>问题：FF需要用CSS禁止，IE用JS禁止</p>
<p>解决方法：IE: obj.onselectstart = function() {return false;}</p>
<p>​                    FF: -moz-user-select:none;</p>
<h4 id="22-捕获事件"><a href="#22-捕获事件" class="headerlink" title="22.捕获事件"></a>22.捕获事件</h4><p>问题：火狐(FF)没有setCapture(),releaseCapture()方法</p>
<p>解决方法：<br>      IE：obj.setCapture();<br>             obj.releaseCapture()<br>      FF：<br>             window.captureEvents(Event.MouseMove|Event.MoouseUp);<br>             window.releaseEvents(Event.MouseMove|Event.MouseUp)</p>
<h4 id="移动端常见的兼容性问题"><a href="#移动端常见的兼容性问题" class="headerlink" title="移动端常见的兼容性问题"></a>移动端常见的兼容性问题</h4><h5 id="1-html5调用安卓或者ios的拨号功能"><a href="#1-html5调用安卓或者ios的拨号功能" class="headerlink" title="1.html5调用安卓或者ios的拨号功能"></a>1.html5调用安卓或者ios的拨号功能</h5><p>html5提供了自动调用拨号的标签，只要在a标签的href中添加tel：就可以了。如下：<br>&lt; a href=” “&gt;400-810-6999 转 1034&lt;/ a&gt;<br>拨打手机如下：<br>&lt; a href=”tel:15677776767”&gt;点击拨打 15677776767 &lt;/ a&gt;</p>
<h5 id="2-上下拉动滚动条时卡顿、慢"><a href="#2-上下拉动滚动条时卡顿、慢" class="headerlink" title="2.上下拉动滚动条时卡顿、慢"></a>2.上下拉动滚动条时卡顿、慢</h5><p>   body {<br>        -webkit-overflow-scrolling: touch;<br>        overflow-scrolling: touch;<br>    }<br> Android3+和 iOS5+支持 CSS3 的新属性为 overflow-scrolling。</p>
<h5 id="3-圆角bug"><a href="#3-圆角bug" class="headerlink" title="3.圆角bug"></a>3.圆角bug</h5><p>某些 Android 手机圆角失效<br>background-clip: padding-box;</p>
<h5 id="4-ios-设置input-按钮样式会被默认样式覆盖"><a href="#4-ios-设置input-按钮样式会被默认样式覆盖" class="headerlink" title="4.ios 设置input 按钮样式会被默认样式覆盖"></a>4.ios 设置input 按钮样式会被默认样式覆盖</h5><p>解决方式如下：</p>
<p>input,textarea {<br>border: 0;<br>-webkit-appearance: none;<br>}<br>设置默认样式为 none</p>
<h5 id="5-IOS键盘字母输入，默认首字母大写"><a href="#5-IOS键盘字母输入，默认首字母大写" class="headerlink" title="5.IOS键盘字母输入，默认首字母大写"></a>5.IOS键盘字母输入，默认首字母大写</h5><p>解决方案，设置如下属性</p>
<p>&lt;input type=”text”autocapitalize=”off”/&gt;</p>
<h5 id="6-h5底部输入框被键盘遮挡问题"><a href="#6-h5底部输入框被键盘遮挡问题" class="headerlink" title="6.h5底部输入框被键盘遮挡问题"></a>6.h5底部输入框被键盘遮挡问题</h5><p>h5页面有个问题是，当输入框在最底部，点击软键盘后输入框会被遮挡。可采用如下方式解决</p>
<p>var oHeight = $(document).height(); //浏览器当前的高度 </p>
<p>​     $(window).resize(function(){</p>
<p>​             if($(document).height() &lt; oHeight){ </p>
<p>​                     $(“#footer”).css(“position”,”static”); </p>
<p>​                    }else{ </p>
<p>​                             $(“#footer”).css(“position”,”absolute”);</p>
<p>​                     } </p>
<p>​     });</p>
<h5 id="7-IOS移动端click事件300ms的延迟响应"><a href="#7-IOS移动端click事件300ms的延迟响应" class="headerlink" title="7.IOS移动端click事件300ms的延迟响应"></a>7.IOS移动端click事件300ms的延迟响应</h5><p>解决方案：</p>
<p>1、fastclick可以解决在手机上点击事件的300ms延迟</p>
<p>2、zepto的touch模块，tap事件也是为了解决在click的延迟问题</p>
<p>3、触摸事件的响应顺序为touchstart –&gt; touchmove –&gt; touchend –&gt; click,也可以通过绑定ontouchstart事件，加快对事件的响应，解决300ms延迟问题</p>
<h5 id="8-在ios和andriod中-audio元素和video元素在无法自动播放"><a href="#8-在ios和andriod中-audio元素和video元素在无法自动播放" class="headerlink" title="8.在ios和andriod中,audio元素和video元素在无法自动播放"></a>8.在ios和andriod中,audio元素和video元素在无法自动播放</h5><p>应对方案：触屏即播$(‘html’).one(‘touchstart’,function(){audio.play()})</p>
<h5 id="9-CSS动画页面闪白-动画卡顿"><a href="#9-CSS动画页面闪白-动画卡顿" class="headerlink" title="9.CSS动画页面闪白,动画卡顿"></a>9.CSS动画页面闪白,动画卡顿</h5><p>解决方法:</p>
<p>1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位</p>
<p>2.开启硬件加速</p>
<p> -webkit-transform: translate3d(0, 0, 0);</p>
<p> -moz-transform: translate3d(0, 0, 0);</p>
<p> -ms-transform: translate3d(0, 0, 0); </p>
<p>  transform: translate3d(0, 0, 0);</p>
<h5 id="10-fixed定位缺陷"><a href="#10-fixed定位缺陷" class="headerlink" title="10.fixed定位缺陷"></a>10.fixed定位缺陷</h5><p>1、ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位</p>
<p>2、android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位</p>
<p>3、ios4下不支持position:fixed解决方案：可用iScroll插件解决这个问题</p>
<h1 id="6-webpack"><a href="#6-webpack" class="headerlink" title="6.webpack"></a>6.webpack</h1><h5 id="1、如何减少-Webpack-打包时间"><a href="#1、如何减少-Webpack-打包时间" class="headerlink" title="1、如何减少 Webpack 打包时间"></a>1、如何减少 Webpack 打包时间</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.优化 Loader</span><br><span class="line">2.HappyPack</span><br><span class="line">3.DllPlugin</span><br><span class="line">4.代码压缩</span><br><span class="line">5.一些小的优化点</span><br></pre></td></tr></table></figure>



<h5 id="2、如何减少-Webpack-打包后的文件体积"><a href="#2、如何减少-Webpack-打包后的文件体积" class="headerlink" title="2、如何减少 Webpack 打包后的文件体积"></a>2、如何减少 Webpack 打包后的文件体积</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.按需加载，将每个路由页面单独打包为一个文件</span><br><span class="line">2.Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</span><br><span class="line">3.Tree Shaking 可以实现删除项目中未被引用的代码</span><br></pre></td></tr></table></figure>



<h5 id="3、什么是模块化？"><a href="#3、什么是模块化？" class="headerlink" title="3、什么是模块化？"></a>3、什么是模块化？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块化是指把一个复杂的系统分解到多个模块以方便编码。</span><br></pre></td></tr></table></figure>

<h5 id="4、为什么出现模块化？"><a href="#4、为什么出现模块化？" class="headerlink" title="4、为什么出现模块化？"></a>4、为什么出现模块化？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">很久以前，开发网页要通过命名空间的方式来组织代码，例如 jQuery 库把它的API都放在了window.$下，在加载完 jQuery 后其他模块再通过window.$去使用 jQuery。 这样做有很多问题，其中包括：</span><br><span class="line"></span><br><span class="line">命名空间冲突，两个库可能会使用同一个名称，例如Zepto也被放在window.$下；</span><br><span class="line">无法合理地管理项目的依赖和版本；</span><br><span class="line">无法方便地控制依赖的加载顺序。</span><br><span class="line">当项目变大时这种方式将变得难以维护，需要用模块化的思想来组织代码。</span><br></pre></td></tr></table></figure>

<h5 id="5、构建的作用及常见功能是什么？"><a href="#5、构建的作用及常见功能是什么？" class="headerlink" title="5、构建的作用及常见功能是什么？"></a>5、构建的作用及常见功能是什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构建就是当源代码无法直接运行时，通过转化将源代码转换成可执行的 JavaScript、Css、HTML代码。</span><br><span class="line">一般包括如下内容：</span><br><span class="line"></span><br><span class="line">代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</span><br><span class="line">文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</span><br><span class="line">代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</span><br><span class="line">模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</span><br><span class="line">自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</span><br><span class="line">代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</span><br><span class="line">自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</span><br></pre></td></tr></table></figure>

<h5 id="6、你了解的构建工具有哪些，各自有什么优缺点？"><a href="#6、你了解的构建工具有哪些，各自有什么优缺点？" class="headerlink" title="6、你了解的构建工具有哪些，各自有什么优缺点？"></a>6、你了解的构建工具有哪些，各自有什么优缺点？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. Webpack</span><br><span class="line">Webpack的优点是：专注于处理模块化的项目，能做到开箱即用一步到位；</span><br><span class="line">    通过 Plugin 扩展，完整好用又不失灵活；</span><br><span class="line">    使用场景不仅限于 Web 开发；</span><br><span class="line">    社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；</span><br><span class="line">    良好的开发体验。</span><br><span class="line">Webpack的缺点是只能用于采用模块化开发的项目。</span><br><span class="line">2.Rollup</span><br><span class="line">Rollup 是在 Webpack 流行后出现的替代品；</span><br><span class="line">Rollup 生态链还不完善，体验不如 Webpack；</span><br><span class="line">Rollup 功能不如 Webpack 完善，但其配置和使用更加简单；</span><br><span class="line">Rollup 不支持 Code Spliting，但好处是打包出来的代码中没有 Webpack 那段模块的加载、执行和缓存的代码。</span><br><span class="line">Rollup 在用于打包 JavaScript 库时比 Webpack 更加有优势，因为其打包出来的代码更小更快。 但功能不够完善，很多场景都找不到现成的解决方案。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7、简单介绍一下webpack"><a href="#7、简单介绍一下webpack" class="headerlink" title="7、简单介绍一下webpack"></a>7、简单介绍一下webpack</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Webpack是一个打包模块化 javascript 的工具，它会从 main.js 出发，识别出源码中的模块化导入语句，递归地找出入口文件的所有依赖，将入口和其所有依赖打包到一个单独的文件中。从webpack 2版本开始，webpack已经内置了对ES6、CommonJS、AMD模块化语句的支持</span><br></pre></td></tr></table></figure>

<h5 id="8、Loader机制的作用是什么？"><a href="#8、Loader机制的作用是什么？" class="headerlink" title="8、Loader机制的作用是什么？"></a>8、Loader机制的作用是什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loader 可以看作具有文件转换功能的翻译员，配置里的module.rules数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。</span><br></pre></td></tr></table></figure>

<h5 id="9、css-loader与style-loader的作用"><a href="#9、css-loader与style-loader的作用" class="headerlink" title="9、css-loader与style-loader的作用"></a>9、css-loader与style-loader的作用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">css-loader读取 CSS 文件</span><br><span class="line">style-loader把 CSS 内容注入到 JavaScript 里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10、配置-Loader-时需要注意的地方？"><a href="#10、配置-Loader-时需要注意的地方？" class="headerlink" title="10、配置 Loader 时需要注意的地方？"></a>10、配置 Loader 时需要注意的地方？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、use属性的值需要是一个由 Loader 名称组成的数组，Loader 的执行顺序是由后到前的；</span><br><span class="line">2、每一个 Loader 都可以通过 URL querystring 的方式传入参数，例如css-loader?minimize中的minimize告诉css-loader要开启 CSS 压缩。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11、Plugin（插件）的作用是什么？"><a href="#11、Plugin（插件）的作用是什么？" class="headerlink" title="11、Plugin（插件）的作用是什么？"></a>11、Plugin（插件）的作用是什么？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	Plugin 是用来扩展 Webpack 功能的，通过在构建流程里注入钩子实现，它给 Webpack 带来了很大的灵活性。</span><br><span class="line">Webpack 是通过plugins属性来配置需要使用的插件列表的。plugins属性是一个数组，里面的每一项都是插件的一个实例，在实例化一个组件时可以通过构造函数传入这个组件支持的配置属性。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="12、ExtractTextPlugin插件的作用"><a href="#12、ExtractTextPlugin插件的作用" class="headerlink" title="12、ExtractTextPlugin插件的作用"></a>12、ExtractTextPlugin插件的作用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	ExtractTextPlugin插件的作用是提取出 JavaScript 代码里的 CSS 到一个单独的文件。</span><br><span class="line">对此你可以通过插件的filename属性，告诉插件输出的 CSS 文件名称是通过[name]_[contenthash:8].css字符串模版生成的，里面的[name]代表文件名称，[contenthash:8]代表根据文件内容算出的8位 hash 值， 还有很多配置选项可以在ExtractTextPlugin的主页上查到。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="13、DevServer开发工具"><a href="#13、DevServer开发工具" class="headerlink" title="13、DevServer开发工具"></a>13、DevServer开发工具</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DevServer 会启动一个 HTTP 服务器用于服务网页请求，同时会帮助启动 Webpack ，并接收 Webpack 发出的文件更变信号，通过 WebSocket 协议自动刷新网页做到实时预览。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="14、实时预览"><a href="#14、实时预览" class="headerlink" title="14、实时预览"></a>14、实时预览</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	Webpack 在启动时可以开启监听模式，开启监听模式后 Webpack 会监听本地文件系统的变化，发生变化时重新构建出新的结果。Webpack 默认是关闭监听模式的，你可以在启动 Webpack 时通过webpack --watch来开启监听模式。</span><br><span class="line">通过 DevServer 启动的 Webpack 会开启监听模式，当发生变化时重新执行完构建后通知 DevServer。 DevServer 会让 Webpack 在构建出的 JavaScript 代码里注入一个代理客户端用于控制网页，网页和 DevServer 之间通过 WebSocket 协议通信， 以方便 DevServer 主动向客户端发送命令。 DevServer 在收到来自** Webpack 的文件变化**通知时通过 注入的客户端控制网页刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="15、什么是模块热替换？"><a href="#15、什么是模块热替换？" class="headerlink" title="15、什么是模块热替换？"></a>15、什么是模块热替换？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	模块热替换能做到在不重新加载整个网页的情况下，通过将被更新过的模块替换老的模块，再重新执行一次来实现实时预览。</span><br><span class="line">模块热替换相对于默认的刷新机制能提供更快的响应和更好的开发体验。 模块热替换默认是关闭的，要开启模块热替换，你只需在启动 DevServer 时带上--hot参数，重启 DevServer 后再去更新文件就能体验到模块热替换的神奇了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="16、什么是Source-Map-及其使用"><a href="#16、什么是Source-Map-及其使用" class="headerlink" title="16、什么是Source Map 及其使用"></a>16、什么是Source Map 及其使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	Source Map能够提供将压缩文件恢复到源文件原始位置的映射代码的方式。这意味着你可以在优化压缩代码后轻松的进行调试。在编译器输出的代码上进行断点调试是一件辛苦和不优雅的事情， 调试工具可以通过Source Map映射代码，让你在源代码上断点调试。</span><br><span class="line"></span><br><span class="line">Source Map使用：Webpack 支持生成 Source Map，只需在启动时带上--devtool source-map参数。 加上参数重启 DevServer 后刷新页面，再打开 Chrome 浏览器的开发者工具，就可在 Sources 栏中看到可调试的源代码了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="17、Webpack的几个核心概念"><a href="#17、Webpack的几个核心概念" class="headerlink" title="17、Webpack的几个核心概念"></a>17、Webpack的几个核心概念</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。</span><br><span class="line">Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</span><br><span class="line">Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</span><br><span class="line">Loader：模块转换器，用于把模块原内容按照需求转换成新内容。</span><br><span class="line">Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。</span><br><span class="line">Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="18、Webpack简单工作原理"><a href="#18、Webpack简单工作原理" class="headerlink" title="18、Webpack简单工作原理"></a>18、Webpack简单工作原理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="19-什么是loader-什么是Plugin-loader和plugin有什么区别？"><a href="#19-什么是loader-什么是Plugin-loader和plugin有什么区别？" class="headerlink" title="19.什么是loader ? 什么是Plugin ? loader和plugin有什么区别？"></a>19.什么是loader ? 什么是Plugin ? loader和plugin有什么区别？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">webapck默认只能打包JS和JOSN模块，要打包其它模块，需要借助loader，loader就可以让模块中的内容转化成webpack或其它laoder可以识别的内容。</span><br><span class="line"></span><br><span class="line">loader就是模块转换化，或叫加载器。不同的文件，需要不同的loader来处理。</span><br><span class="line">plugin是插件，可以参与到整个webpack打包的流程中，不同的插件，在合适的时机，可以做不同的事件。</span><br><span class="line"></span><br><span class="line">**css-loader:**</span><br><span class="line">加载css模块 转换成模块化的css 让webpack识别它</span><br><span class="line">**style-loader:**</span><br><span class="line">把css代码注入到js中，通过DOM操作去加载CSS 把css代码放到了header标签中style标签中</span><br><span class="line">**babel-loader** </span><br><span class="line">把JS高阶转成JS低阶 pollyfill</span><br><span class="line">**eslint-loader:**</span><br><span class="line">检查JS代码是否符合某个规则</span><br><span class="line">**file-loader:**</span><br><span class="line">把文件输出到一个文件夹中，在代码中通过URL引用输出的文件</span><br><span class="line">**url-loader:**</span><br><span class="line">和file-loader类似，比file-loader强大一个，让小图片直接生成base64</span><br><span class="line">**less-loader:**</span><br><span class="line">把less代码转化css代码</span><br><span class="line">**html-loader:**</span><br><span class="line">处理html模块中的插件图片等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="20-webpack中都有哪些插件，这些插件有什么作用？"><a href="#20-webpack中都有哪些插件，这些插件有什么作用？" class="headerlink" title="20.webpack中都有哪些插件，这些插件有什么作用？"></a>20.webpack中都有哪些插件，这些插件有什么作用？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html-webpack-plugin**</span><br><span class="line">自动创建一个HTML文件，并把打包好的JS插入到HTML文件中</span><br><span class="line">**clean-webpack-plugin**</span><br><span class="line">在每一次打包之前，删除整个输出文件夹下所有的内容</span><br><span class="line">**mini-css-extrcat-plugin**</span><br><span class="line">抽离CSS代码，放到一个单独的文件中</span><br><span class="line">**optimize-css-assets-plugin**</span><br><span class="line">压缩css</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="21-如何利用webpack优化前端性能"><a href="#21-如何利用webpack优化前端性能" class="headerlink" title="21.如何利用webpack优化前端性能?"></a>21.如何利用webpack优化前端性能?</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 压缩代码**。删除多余的代码、注释、简化代码的写法等等方式</span><br><span class="line">2. 利用 **CDN** 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径</span><br><span class="line">3. **删除死代码**，将代码中永远不会走到的片段删除掉</span><br><span class="line">4. **优化图片**，对于小图可以使用 base64 的方式写入文件中</span><br><span class="line">5. 按照路由拆分代码，实现按需加载，**提取公共代码**</span><br><span class="line">6. 给打包出来的文件名添加哈希，实现浏览器缓存文件，版本</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="7-vue3-0"><a href="#7-vue3-0" class="headerlink" title="7.vue3.0"></a>7.vue3.0</h1><h5 id="1-Vue3-0和Vue2-0的区别"><a href="#1-Vue3-0和Vue2-0的区别" class="headerlink" title="1.Vue3.0和Vue2.0的区别"></a>1.Vue3.0和Vue2.0的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">· 3.0比2.0 快2倍</span><br><span class="line">· 3.0去掉了filter, 么有beforeCreate created,用setup取代</span><br><span class="line">· reactivity是可以单独作为库使用的 </span><br><span class="line">· 单独功能可以抽离 取代了mixin  优于mixin 解决上下反复横跳</span><br><span class="line">· 支持多个子节点 fragment</span><br><span class="line">· setup里没有this</span><br><span class="line">· Proxy实现响应式不需要set delete  兼容性并不好</span><br><span class="line">· 响应式方面 性能得到很大提升 不用初始化的时候就递归遍历属性</span><br><span class="line">· 响应式不区分数组和对象</span><br><span class="line">· 3.0兼容IE12以上</span><br><span class="line">· composition api 可以和 options API 同时存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-Vue3-0都有哪些重要新特性？"><a href="#2-Vue3-0都有哪些重要新特性？" class="headerlink" title="2.Vue3.0都有哪些重要新特性？"></a>2.Vue3.0都有哪些重要新特性？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">建议往`Composition API`和`Tree-shaking`方面答，对应比较`React Hooks`和webpack 的`Tree-shaking`</span><br><span class="line">composition-api解决了什么问题</span><br><span class="line">1.使用传统的option配置方法写组件的时候问题，随着业务复杂度越来越高，代码量会不断的加大；由于相关业务的代码需要遵循option的配置写到特定的区域，导致后续维护非常的复杂，同时代码可复用性不高，而composition-api就是为了解决这个问题而生的</span><br><span class="line">compositon-api提供了一下几个函数</span><br><span class="line">reactive</span><br><span class="line">watchEffect</span><br><span class="line">computed</span><br><span class="line">ref</span><br><span class="line">toRefs</span><br><span class="line">生命周期的hooks</span><br><span class="line">2.Vue3提出万物皆可 TreeShaking的概念</span><br><span class="line">什么是 TreeShaking </span><br><span class="line">TreeShaking 是一个术语，指的是在打包构建过程中移除没有被引用到的代码，这些代码可以成为 dead code。这个概念最早在基于 ES6 的打包工具 Rollup 中提出，后来被引入到 webpack 中。TreeShaking 比较依赖于 ES6 模块系统的静态结构特性，比如 import 和 export。</span><br></pre></td></tr></table></figure>

<h5 id="3-Vue3-0-对比Vue2-0的优势在哪？"><a href="#3-Vue3-0-对比Vue2-0的优势在哪？" class="headerlink" title="3.Vue3.0 对比Vue2.0的优势在哪？"></a>3.Vue3.0<code> 对比</code>Vue2.0的优势在哪？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vue3.0 的发布与 vue2.0 相比，优势主要体现在：更快、更小、更易维护、更易于原生、让开发者更轻松；</span><br><span class="line">更快</span><br><span class="line">　　1、virtual DOM 完全重写，mounting &amp; patching 提速 100%；</span><br><span class="line">　　2、更多编译时 （compile-time）提醒以减少 runtime 开销；</span><br><span class="line">　　3、基于 Proxy 观察者机制以满足全语言覆盖以及更好的性能；</span><br><span class="line">　　4、放弃 Object.defineProperty ，使用更快的原生 Proxy；</span><br><span class="line">　　5、组件实例初始化速度提高 100%;</span><br><span class="line">　　6、提速一倍/内存使用降低一半；</span><br><span class="line">更小</span><br><span class="line">　　1、Tree-shaking 更友好；</span><br><span class="line">　　2、新的 core runtime：~ 10kb gzipped</span><br></pre></td></tr></table></figure>

<h5 id="4-Vue3-0和React-16-X都有哪些区别和相似处？"><a href="#4-Vue3-0和React-16-X都有哪些区别和相似处？" class="headerlink" title="4.Vue3.0和React 16.X都有哪些区别和相似处？"></a>4.Vue3.0<code>和</code>React 16.X都有哪些区别和相似处？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">相似之处</span><br><span class="line">他们都是JavaScript的UI框架，专注于创造前端的富应用</span><br><span class="line">不同于早期的JavaScript框架“功能齐全”，Reat与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件。</span><br><span class="line">Vue.js(2.0版本)与React的其中最大一个相似之处，就是他们都使用了一种叫’Virtual DOM’的东西</span><br><span class="line">都鼓励组件化</span><br><span class="line">看到React和Vue都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据。</span><br><span class="line">React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境</span><br><span class="line">React和Vue都有很好的Chrome扩展工具去帮助你找出bug。</span><br><span class="line">Vue与React最后一个相似但略有不同之处是它们配套框架的处理方法。相同之处在于，两个框架都专注于UI层，其他的功能如路由、状态管理等都交由同伴框架进行处理。</span><br><span class="line">react</span><br><span class="line">数据流单向</span><br><span class="line">React推广了Virtual DOM，并创造了新的语法——JSX，JSX允许开发者在JavaScript中书写HTML</span><br><span class="line">React一样由如Facebook这类大公司维护</span><br><span class="line">props对于子组件来说是必须的，因为它依赖一个“单一数据源”作为它的“状态”</span><br><span class="line">React可以使用Create React App (CRA)</span><br><span class="line">而React的react-router和react-redux则是由社区成员维护，它们都不是官方维护的。</span><br><span class="line">React与Vue最大的不同是模板的编写</span><br><span class="line">在React中你需要使用setState()方法去更新状态</span><br><span class="line">多数情况下，框架内置的状态管理是不足以支撑大型应用的，Redux或Vuex等状态管理方案是必须使用的。</span><br><span class="line">vue</span><br><span class="line">数据双向绑定</span><br><span class="line">Vue使用模板系统而不是JSX，使其对现有应用的升级更加容易,这是因为模板用的就是普通的HTML，通过Vue来整合现有的系统是比较容易的，不需要整体重构</span><br><span class="line">Vue主要是由一位开发者进行维护的</span><br><span class="line">而在Vue中，props略有不同。它们一样是在组件中被定义，但Vue依赖于模板语法，你可以通过模板的循环函数更高效地展示传入的数据。</span><br><span class="line">Vue对应的则是vue-cli</span><br><span class="line">Vue的核心团队维护着vue-router和vuex</span><br><span class="line">React与Vue最大的不同是模板的编写</span><br><span class="line">在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。</span><br><span class="line">Vue的）解决方案适用于小型应用，但对于对于大型应用而言不太适合。</span><br></pre></td></tr></table></figure>

<h5 id="5-Vue3-0是如何实现代码逻辑复用的？"><a href="#5-Vue3-0是如何实现代码逻辑复用的？" class="headerlink" title="5.Vue3.0是如何实现代码逻辑复用的？"></a>5.<code>Vue3.0</code>是如何实现代码逻辑复用的？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mixins有命名冲突，隐式依赖的问题</span><br><span class="line"></span><br><span class="line">1.代码提取</span><br><span class="line">相比Composition API的第一个明显优点是提取逻辑很容易。</span><br><span class="line">2.代码重用</span><br><span class="line">要在组件中使用该函数，我们只需将模块导入组件文件并调用它（注意导入是一个函数）。</span><br><span class="line">3.命名冲突解决了</span><br><span class="line">我们之前已经了解了mixin如何使用与消费者组件中的名称相同的属性，或者甚至更隐蔽地使用了消费者组件使用的其他mixin中的属性。</span><br><span class="line">4.隐式依赖...解决了！</span><br><span class="line">前面还看到mixin如何使用在消费组件上定义的 data 属性，这可能会使代码变得脆弱，并且很难进行推理。</span><br></pre></td></tr></table></figure>

<h1 id="8-移动端、小程序"><a href="#8-移动端、小程序" class="headerlink" title="8.移动端、小程序"></a>8.移动端、小程序</h1><h4 id="1-移动端兼容适配"><a href="#1-移动端兼容适配" class="headerlink" title="1. 移动端兼容适配"></a>1. 移动端兼容适配</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">•	rem, em, 百分比</span><br><span class="line">•	框架的栅格布局</span><br><span class="line">•	media query媒体查询</span><br><span class="line">•	手淘团队的一套flexible.js, 自动判断dpr进行整个布局视口的放缩</span><br></pre></td></tr></table></figure>

<h4 id="2-flexible如何实现自动判断dpr"><a href="#2-flexible如何实现自动判断dpr" class="headerlink" title="2.flexible如何实现自动判断dpr"></a>2.flexible如何实现自动判断dpr</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断机型, 找出样本机型去适配. 比如iphone以6为样本, 宽度375px, dpr是2</span><br></pre></td></tr></table></figure>

<h4 id="3-为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？"><a href="#3-为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？" class="headerlink" title="3.为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？"></a>3.为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iPhone6的满屏宽度是375px，而iPhone6采用的视网膜屏的物理像素是满屏宽度的2倍，也就是dpr(设备像素比)为2, 并且设计师所用的PS设计软件分辨率和像素关系是1:1。所以为了做出的清晰的页面，设计师一般给出750px的设计图，我们再根据需求对元素的尺寸设计和压缩。</span><br></pre></td></tr></table></figure>

<h4 id="4-如何处理异形屏iphone-X"><a href="#4-如何处理异形屏iphone-X" class="headerlink" title="4.如何处理异形屏iphone X"></a>4.如何处理异形屏iphone X</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">safe area: 默认放置在安全区域以避免遮挡, 但会压缩</span><br><span class="line">•	在meta中添加viewport-fit=cover: 告诉浏览器要讲整个页面渲染到浏览器中，不管设备是圆角与否，这个时候会造成页面的元素被圆角遮挡</span><br><span class="line">•	padding: constant(env): 解决遮挡问题</span><br></pre></td></tr></table></figure>

<h4 id="5-移动端首屏优化"><a href="#5-移动端首屏优化" class="headerlink" title="5.移动端首屏优化"></a>5.移动端首屏优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">采用服务器渲染ssr</span><br><span class="line">按需加载配合webpack分块打包, 通过entry和commonChunkPlugin</span><br><span class="line">很有必要将script标签➕异步</span><br><span class="line">有轮播图 最好给个默认 另外要处理图片懒加载</span><br><span class="line">打包线上也要注意去掉map 文件</span><br><span class="line">组件, 路由懒加载</span><br><span class="line">webpack的一切配置 肯定是必须的</span><br><span class="line">压缩图片 https://tinypng.com/ </span><br><span class="line">建议还是用webpack的图片压缩插件</span><br><span class="line">骨架屏</span><br><span class="line">Loading页面</span><br></pre></td></tr></table></figure>

<h4 id="6-PWA全称Progressive-Web-App，即渐进式WEB应用"><a href="#6-PWA全称Progressive-Web-App，即渐进式WEB应用" class="headerlink" title="6.PWA全称Progressive Web App，即渐进式WEB应用"></a>6.PWA全称Progressive Web App，即渐进式WEB应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能</span><br><span class="line">解决了哪些问题？</span><br><span class="line">•	可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</span><br><span class="line">•	实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</span><br><span class="line">•	实现了消息推送</span><br><span class="line">它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。</span><br></pre></td></tr></table></figure>

<h4 id="7-离线包方案"><a href="#7-离线包方案" class="headerlink" title="7.离线包方案"></a>7.离线包方案</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在 web 页面在移动端的地位越来越高，大部分主流 App 采用 native + webview 的 hybrid 模式，加载远程页面受限于网络，本地 webview 引擎，经常会出现渲染慢导致的白屏现象，体验很差，于是离线包方案应运而生。动态下载的离线包可以使得我们不需要走完整的 App 审核发布流程就完成了版本的更新</span><br></pre></td></tr></table></figure>

<h4 id="8-自适应和响应式布局的区别"><a href="#8-自适应和响应式布局的区别" class="headerlink" title="8. 自适应和响应式布局的区别"></a>8. 自适应和响应式布局的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.	自适应布局通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式布局通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。</span><br><span class="line">2.	自适应布局需要开发多套界面，而响应式布局只需要开发一套界面就可以了。</span><br><span class="line">3.	自适应对页面做的屏幕适配是在一定范围：比如pc端一般要大于1024像素，手机端要小于768像素。而响应式布局是一套页面全部适应。</span><br><span class="line">4.	自适应布局如果屏幕太小会发生内容过于拥挤。而响应式布局正是为了解决这个问题而衍生出的概念，它可以自动识别屏幕宽度并做出相应调整的网页设计。</span><br></pre></td></tr></table></figure>

<h4 id="9-简单描述下微信小程序的相关文件类型？"><a href="#9-简单描述下微信小程序的相关文件类型？" class="headerlink" title="9.简单描述下微信小程序的相关文件类型？"></a>9.简单描述下微信小程序的相关文件类型？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">微信小程序项目结构主要有一下几个文件类型,如下</span><br><span class="line">1、WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构</span><br><span class="line">建出页面的结构。内部主要是微信自己定义的一套组件。</span><br><span class="line">2、WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，</span><br><span class="line">3、js 逻辑处理，网络请求</span><br><span class="line">4、json 小程序设置，如页面注册，页面标题及 tabBar。</span><br><span class="line">5、app.json 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文</span><br><span class="line">件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 window 背景色，配置导航</span><br><span class="line">条样式，配置默认标题。</span><br><span class="line">6、app.js 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我</span><br><span class="line">们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-你是怎么封装微信小程序的数据请求的？"><a href="#10-你是怎么封装微信小程序的数据请求的？" class="headerlink" title="10.你是怎么封装微信小程序的数据请求的？"></a>10.你是怎么封装微信小程序的数据请求的？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 将所有的接口放在统一的 js 文件中并导出</span><br><span class="line">2、在 app.js 中创建封装请求数据的方法</span><br><span class="line">3、在子页面中调用封装的方法请求数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="11-小程序有哪些参数传值的方法？"><a href="#11-小程序有哪些参数传值的方法？" class="headerlink" title="11.小程序有哪些参数传值的方法？"></a>11.小程序有哪些参数传值的方法？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、给 HTML 元素添加 data-*属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或 onload 的</span><br><span class="line">param 参数获取。但 data-名称不能有大写字母和不可以存放对象</span><br><span class="line">2、设置 id 的方法标识来传值通过 e.currentTarget.id 获取设置的 id 的值,然后通过设置全局对象的方式来</span><br><span class="line">传递数值</span><br><span class="line">3、在 navigator 中添加参数传值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="12-简述微信小程序原理？"><a href="#12-简述微信小程序原理？" class="headerlink" title="12.简述微信小程序原理？"></a>12.简述微信小程序原理？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、微信小程序采用 JavaScript、WXML、WXSS 三种技术进行开发，从技术讲和现有的前端开发差不多，</span><br><span class="line">但深入挖掘的话却又有所不同。</span><br><span class="line">2、JavaScript：首先 JavaScript 的代码是运行在微信 App 中的，并不是运行在浏览器中，因此一些 H5 技</span><br><span class="line">术的应用，需要微信 App 提供对应的 API 支持，而这限制住了 H5 技术的应用，且其不能称为严格的 H5，</span><br><span class="line">可以称其为伪 H5，同理，微信提供的独有的某些 API，H5 也不支持或支持的不是特别好。</span><br><span class="line">3、WXML：WXML 微信自己基于 XML 语法开发的，因此开发时，只能使用微信提供的现有标签，HTML</span><br><span class="line">的标签是无法使用的。</span><br><span class="line">4、WXSS：WXSS 具有 CSS 的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有</span><br><span class="line">详细的文档。</span><br><span class="line">5、微信的架构，是数据驱动的架构模式，它的 UI 和数据是分离的，所有的页面更新，都需要通过对数</span><br><span class="line">据的更改来实现。</span><br><span class="line">6、小程序分为两个部分 webview 和 appService。其中 webview 主要用来展现 UI，appService 有来处理</span><br><span class="line">业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事</span><br><span class="line">件的处理。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="13-小程序的双向绑定和-vue-哪里不一样？"><a href="#13-小程序的双向绑定和-vue-哪里不一样？" class="headerlink" title="13.小程序的双向绑定和 vue 哪里不一样？"></a>13.小程序的双向绑定和 vue 哪里不一样？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">小程序直接 this.data 的属性是不可以同步到视图的，必须调用：</span><br><span class="line">小程序：</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">    items: []</span><br><span class="line">    &#125;,</span><br><span class="line">    onLoad: function(options) &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">    items: [1,2,3]</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;&#125;)</span><br><span class="line">    Vue：</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">    items: []</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">    this.items = [1, 2, 3]</span><br><span class="line">&#125;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-webview-中的页面怎么跳回小程序中？"><a href="#14-webview-中的页面怎么跳回小程序中？" class="headerlink" title="14.webview 中的页面怎么跳回小程序中？"></a>14.webview 中的页面怎么跳回小程序中？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-view/&gt;网页中可使用 JSSDK 1.3.2 提供的接口返回小程序页面。</span><br><span class="line">例如：wx.miniProgram.navigateTo(&#123;url: &#x27;/path/to/page&#x27;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="15-小程序关联微信公众号如何确定用户的唯一性？"><a href="#15-小程序关联微信公众号如何确定用户的唯一性？" class="headerlink" title="15.小程序关联微信公众号如何确定用户的唯一性？"></a>15.小程序关联微信公众号如何确定用户的唯一性？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 wx.getUserInfo 方法 withCredentials 为 true 时可获取 encryptedData，里面有 union_id。后端需要进行</span><br><span class="line">对称解密。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="16-小程序如何实现下拉刷新？"><a href="#16-小程序如何实现下拉刷新？" class="headerlink" title="16.小程序如何实现下拉刷新？"></a>16.小程序如何实现下拉刷新？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用 view 代替 scroll-view,,设置 onPullDownRefresh 函数实现。</span><br><span class="line">1、在 json 文件中配置 enablePullDownRefresh 为 true(app.json 中在 window 中设置 enablePullDownRefresh,</span><br><span class="line">此效果作用于全局)。</span><br><span class="line">2、在 js 文件中实现 onPullDownRefresh 方法,在网络请求完成后调用 wx.stopPullDownRefresh()来结束下拉刷</span><br><span class="line">新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="17-小程序调用后台接口遇到哪些问题？"><a href="#17-小程序调用后台接口遇到哪些问题？" class="headerlink" title="17.小程序调用后台接口遇到哪些问题？"></a>17.小程序调用后台接口遇到哪些问题？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、数据的大小有限制，超过范围会直接导致整个小程序崩溃，除非重启小程序；</span><br><span class="line">2、小程序不可以直接渲染文章内容页这类型的 html 文本内容，若需显示要借住插件，但插件渲染会导致</span><br><span class="line">页面加载变慢，所以最好在后台对文章内容的 html 进行过滤，后台直接处理批量替换 p 标签 div 标签为 view 标</span><br><span class="line">签，然后其它的标签让插件来做，减轻前端的时间。</span><br><span class="line"></span><br><span class="line">页面加载变慢，所以最好在后台对文章内容的 html 进行过滤，后台直接处理批量替换 p 标签 div 标签为 view 标</span><br><span class="line">签，然后其它的标签让插件来做，减轻前端的时间。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="18-小程序的-wxss-和-css-有哪些不一样的地方？"><a href="#18-小程序的-wxss-和-css-有哪些不一样的地方？" class="headerlink" title="18.小程序的 wxss 和 css 有哪些不一样的地方？"></a>18.小程序的 wxss 和 css 有哪些不一样的地方？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、wxss 的图片引入需使用外链地址。</span><br><span class="line">2、没有 Body，样式可直接使用 import 导入。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="19-分析下微信小程序的优劣势"><a href="#19-分析下微信小程序的优劣势" class="headerlink" title="19.分析下微信小程序的优劣势"></a>19.分析下微信小程序的优劣势</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">优 势：</span><br><span class="line">1、无需下载，通过搜索和扫一扫就可以打开。</span><br><span class="line">2、良好的用户体验：打开速度快。</span><br><span class="line">3、开发成本要比 App 要低</span><br><span class="line">4、安卓上可以添加到桌面，与原生 App 差不多。</span><br><span class="line">5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序</span><br><span class="line">是无法发布到线上的。</span><br><span class="line">劣势：</span><br><span class="line">1、限制较多。页面大小不能超过 1M。不能打开超过 5 个层级的页面。</span><br><span class="line">2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。</span><br><span class="line">3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的</span><br><span class="line">限制。</span><br><span class="line">4、依托于微信，无法开发后台管理功能。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="9-es6"><a href="#9-es6" class="headerlink" title="9.es6"></a>9.es6</h1><h2 id="1、var、let、const之间的区别"><a href="#1、var、let、const之间的区别" class="headerlink" title="1、var、let、const之间的区别"></a><strong>1、var、let、const之间的区别</strong></h2><blockquote>
<p>var声明变量可以重复声明，而let不可以重复声明<br>var是不受限于块级的，而let是受限于块级<br>var会与window相映射（会挂一个属性），而let不与window相映射<br>var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错<br>const声明之后必须赋值，否则会报错<br>const定义不可变的量，改变了就会报错<br>const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错</p>
</blockquote>
<h2 id="2、使用箭头函数应注意什么？"><a href="#2、使用箭头函数应注意什么？" class="headerlink" title="2、使用箭头函数应注意什么？"></a><strong>2、使用箭头函数应注意什么？</strong></h2><blockquote>
<p>（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）<br>（2）不能够使用arguments对象<br>（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数</p>
</blockquote>
<h2 id="3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能"><a href="#3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能" class="headerlink" title="3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能"></a><strong>3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能</strong></h2><blockquote>
<p>基本的字符串格式化。<br>将表达式嵌入字符串中进行拼接。<br>用${}来界定在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。<br>ES6反引号(``)就能解决类模板字符串的功能</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;web&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;你好，$&#123;name&#125; 已经 $&#123;age&#125;岁了&#x27;</span></span><br><span class="line">str = str.replace(<span class="regexp">/\$\&#123;([^&#125;]*)\&#125;/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//你好，web 已经 10岁了</span></span><br></pre></td></tr></table></figure>

<h2 id="4、介绍下-Set、Map的区别？"><a href="#4、介绍下-Set、Map的区别？" class="headerlink" title="4、介绍下 Set、Map的区别？"></a><strong>4、介绍下 Set、Map的区别？</strong></h2><blockquote>
<p>应用场景Set用于数据重组，Map用于数据储存</p>
<p>Set：　<br>（1）成员不能重复<br>（2）只有键值没有键名，类似数组<br>（3）可以遍历，方法有add, delete,has<br>Map:<br>（1）本质上是健值对的集合，类似集合<br>（2）可以遍历，可以跟各种数据格式转换</p>
</blockquote>
<h2 id="5、ECMAScript-6-怎么写-class-，为何会出现-class？"><a href="#5、ECMAScript-6-怎么写-class-，为何会出现-class？" class="headerlink" title="5、ECMAScript 6 怎么写 class ，为何会出现 class？"></a><strong>5、ECMAScript 6 怎么写 class ，为何会出现 class？</strong></h2><blockquote>
<p>ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span> &#123; </span><br><span class="line">      <span class="comment">//构造方法</span></span><br><span class="line">       <span class="built_in">this</span>.x = x; <span class="comment">//this关键字代表实例对象</span></span><br><span class="line">       <span class="built_in">this</span>.y = y; </span><br><span class="line">  &#125; <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、Promise构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#6、Promise构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="6、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？"></a><strong>6、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</strong></h2><blockquote>
<p>promise构造函数是同步执行的，then方法是异步执行的</p>
</blockquote>
<h2 id="7、setTimeout、Promise、Async-Await-的区别"><a href="#7、setTimeout、Promise、Async-Await-的区别" class="headerlink" title="7、setTimeout、Promise、Async/Await 的区别"></a><strong>7、setTimeout、Promise、Async/Await 的区别</strong></h2><blockquote>
<p>事件循环中分为宏任务队列和微任务队列<br>其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式<br>async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行</p>
</blockquote>
<h2 id="8、promise有几种状态，什么时候会进入catch？"><a href="#8、promise有几种状态，什么时候会进入catch？" class="headerlink" title="8、promise有几种状态，什么时候会进入catch？"></a><strong>8、promise有几种状态，什么时候会进入catch？</strong></h2><blockquote>
<p>三个状态：<br>pending、fulfilled、reject<br>两个过程：<br>padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch</p>
</blockquote>
<h2 id="9、下面的输出结果是多少"><a href="#9、下面的输出结果是多少" class="headerlink" title="9、下面的输出结果是多少"></a><strong>9、下面的输出结果是多少</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3</p>
</blockquote>
<h2 id="10、使用结构赋值，实现两个变量的值的交换"><a href="#10、使用结构赋值，实现两个变量的值的交换" class="headerlink" title="10、使用结构赋值，实现两个变量的值的交换"></a><strong>10、使用结构赋值，实现两个变量的值的交换</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a,b] = [b,a];</span><br></pre></td></tr></table></figure>

<h2 id="11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key"><a href="#11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key" class="headerlink" title="11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key"></a><strong>11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> product = &#123;</span><br><span class="line">    [name]:<span class="string">&quot;洗衣机&quot;</span>,    </span><br><span class="line">    <span class="string">&quot;price&quot;</span>:<span class="number">799</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(product);</span><br></pre></td></tr></table></figure>

<h2 id="12、下面Set结构，打印出的size值是多少"><a href="#12、下面Set结构，打印出的size值是多少" class="headerlink" title="12、下面Set结构，打印出的size值是多少"></a><strong>12、下面Set结构，打印出的size值是多少</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = newSet();</span><br><span class="line">s.add([<span class="number">1</span>]);s.add([<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s.size);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：2<br>两个数组[1]并不是同一个值，它们分别定义的数组，在内存中分别对应着不同的存储地址，因此并不是相同的值都能存储到Set结构中，所以size为2</p>
</blockquote>
<h2 id="13、Promise-中reject-和-catch-处理上有什么区别"><a href="#13、Promise-中reject-和-catch-处理上有什么区别" class="headerlink" title="13、Promise 中reject 和 catch 处理上有什么区别"></a><strong>13、Promise 中reject 和 catch 处理上有什么区别</strong></h2><blockquote>
<p>reject 是用来抛出异常，catch 是用来处理异常<br>reject 是 Promise 的方法，而 catch 是 Promise 实例的方法<br>reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch<br>网络异常（比如断网），会直接进入catch而不会进入then的第二个回调</p>
</blockquote>
<h2 id="14、如何使用Set去重"><a href="#14、如何使用Set去重" class="headerlink" title="14、如何使用Set去重"></a><strong>14、如何使用Set去重</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">43</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">68</span>,<span class="number">12</span>];</span><br><span class="line"><span class="keyword">let</span> item = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(item);<span class="comment">//[12, 43, 23, 68]</span></span><br></pre></td></tr></table></figure>

<h2 id="15、将下面for循环改成for-of形式"><a href="#15、将下面for循环改成for-of形式" class="headerlink" title="15、将下面for循环改成for of形式"></a><strong>15、将下面for循环改成for of形式</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>答案：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16、理解-async-await以及对Generator的优势"><a href="#16、理解-async-await以及对Generator的优势" class="headerlink" title="16、理解 async/await以及对Generator的优势"></a><strong>16、理解 async/await以及对Generator的优势</strong></h2><blockquote>
<p>async await 是用来解决异步的，async函数是Generator函数的语法糖<br>使用关键字async来表示，在函数内部使用 await 来表示异步<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数<br>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句<br><strong>async较Generator的优势：</strong><br>（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样<br>（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　<br>（3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值<br>（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用</p>
</blockquote>
<h2 id="17、forEach、for-in、for-of三者区别"><a href="#17、forEach、for-in、for-of三者区别" class="headerlink" title="17、forEach、for in、for of三者区别"></a><strong>17、forEach、for in、for of三者区别</strong></h2><blockquote>
<p>forEach更多的用来遍历数组<br>for in 一般常用来遍历对象或json<br>for of数组对象都可以遍历，遍历对象需要通过和Object.keys()<br>for in循环出的是key，for of循环出的是value</p>
</blockquote>
<h2 id="28、说一下es6的导入导出模块"><a href="#28、说一下es6的导入导出模块" class="headerlink" title="28、说一下es6的导入导出模块"></a><strong>28、说一下es6的导入导出模块</strong></h2><blockquote>
<p>导入通过import关键字</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只导入一个</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">&quot;./example.js&quot;</span></span><br><span class="line"><span class="comment">// 导入多个</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum,multiply,time&#125; <span class="keyword">from</span> <span class="string">&quot;./exportExample.js&quot;</span></span><br><span class="line"><span class="comment">// 导入一整个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">&quot;./exportExample.js&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>导出通过export关键字</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以将export放在任何变量,函数或类声明的前面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="comment">//也可以使用大括号指定所要输出的一组变量</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br><span class="line"><span class="comment">//使用export default时，对应的import语句不需要使用大括号</span></span><br><span class="line"><span class="keyword">let</span> bosh = <span class="function"><span class="keyword">function</span> <span class="title">crs</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> bosh;</span><br><span class="line"><span class="keyword">import</span> crc <span class="keyword">from</span> <span class="string">&#x27;crc&#x27;</span>;</span><br><span class="line"><span class="comment">//不使用export default时，对应的import语句需要使用大括号</span></span><br><span class="line"><span class="keyword">let</span> bosh = <span class="function"><span class="keyword">function</span> <span class="title">crs</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> bosh;</span><br><span class="line"><span class="keyword">import</span> &#123;crc&#125; <span class="keyword">from</span> <span class="string">&#x27;crc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="10-React"><a href="#10-React" class="headerlink" title="10.React"></a>10.React</h1><ol>
<li><p>react组件如何通信</p>
<ul>
<li>父组件向子组件通信：使用 props</li>
<li>子组件向父组件通信：使用 props 回调</li>
<li>跨级组件间通信：使用 context 对象</li>
<li>非嵌套组件间通信：使用事件订阅</li>
</ul>
</li>
<li><p>jsx本质是什么</p>
<p>jsx其实是语法糖，开发环境会将jsx编译成js代码，jsx的写法大大降低了学习成本和编码工作量</p>
</li>
<li><p>context是什么，有何用途</p>
<p>在react应用中，数据总是通过 props 自上而下进行传递。 这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题）。<strong>Context 可以共享对于一个组件树而言是“全局”的数据。这样就不必显式地通过组件树的逐层传递 props</strong></p>
</li>
<li><p>shouldComponentUpdate用途</p>
<p>询问组件是否需要更新的一个钩子函数，判断数据是否需要重新渲染，返回一个布尔值。默认的返回值是true，需要重新render()。若如果返回值是false则不触发渲染,利用这个生命周期函数可以强制关闭不需要更新的子组件来提升渲染性能。<br>这个方法用来判断是否需要调用 render 方法重新描绘 dom。<br>因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
</li>
<li><p>描述redux单项数据流</p>
<p>当一个页面渲染完后，UI出现，用户其实是触发了UI上的一些Action，Action将会被送到Reducers方法里，Reducers将会更新Store，数据就是React开发中的State，State其实是Store的一部分，所有的视图层的东西，也就是组件，其实是由State来唯一决定的。</p>
<p>![img](D:\课件\课件p4\day06 React\img\Center)</p>
</li>
<li><p>setState是同步还是异步？</p>
<p>既可能是同步的,也可能是异步的。 准确地说,在React内部机制能检测到的地方, setState就是异步的;在React检测不到的地方,例如setInterval,setTimeout里,setState就是同步更新的</p>
</li>
<li><p>什么是纯函数</p>
<p>一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。</p>
</li>
<li><p>react组件生命周期</p>
<p>// 实例化组件，也就是构造DOM元素<br>constructor();<br>// 当DOM元素载入之前调用<br>componentWillMount();<br>// 将构造的元素插入到指定的页面元素中<br>render();<br>// 当DOM元素载入页面之后调用<br>componentDidMount();<br>// 当从页面中卸载时会调用<br>componentWillUnmount()</p>
</li>
<li><p>react发起ajax应该在哪个生命周期</p>
<p>componentDidMount生命周期中调用</p>
</li>
<li><p>渲染列表，为何使用key？</p>
<p>key是给每一个虚拟dom的唯一id,可以依靠key,更准确, 更快的拿到旧虚拟dom中对应的新虚拟dom节点。</p>
</li>
<li><p>函数组件和class组件区别</p>
<p>函数组件纯函数，输入props，输出jsx</p>
<p>函数组件没有实例，没有生命周期，没有state</p>
<p>函数组件不能扩展其他方法</p>
<p>class创建的组件,有自己的私有数据(this.state)和生命周期 </p>
</li>
<li><p>什么是受控组件</p>
<p>简单的说就是input里面的值受state值控制</p>
</li>
<li><p>何时使用异步组件</p>
<p> 加载大组件  路由异步加载  资源异步加载</p>
</li>
<li><p>多个组件有公共逻辑，如何抽离</p>
<ul>
<li><code>HOC</code>，高阶组件   高阶组件不是一种功能，而是一种模式</li>
<li><code>Render Props</code>核心思想：通过一个函数将class组件的state作为props传递给纯函数组件</li>
</ul>
</li>
<li><p>redux如何进行异步请求 ajax请求</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>在actionType中添加异步数据需要的action类型</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> INIT_TODO_ITEM = <span class="string">&#x27;init_todo_item&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.在actionCreator中添加生成action的函数</span><br><span class="line">export const getInitTodoItemAction = (list) =&gt; (&#123;</span><br><span class="line">    type: INIT_TODO_ITEM,</span><br><span class="line">    list</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>在容器组件的ComponentDidMount中发送ajax请求，并生成和发送action</span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    axios.get(<span class="string">&#x27;/getData&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> action = getInitTodoItemAction(res.data)</span><br><span class="line">      store.dispatch(action)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span>在reducer中添加处理action的方法</span><br><span class="line"><span class="keyword">if</span>(action.type === INIT_TODO_ITEM)&#123;</span><br><span class="line">    newState.list = action.list</span><br><span class="line">    <span class="keyword">return</span> newState </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>react-router如何配置懒加载</p>
<p>lazyload-loader方式     <code>import Shop from &#39;lazy!./src/view/Shop&#39;;</code></p>
<p>箭头函数方式 <code>component:resolve =&gt; require([&#39;@/component/Login&#39;],resolve)</code>·</p>
</li>
<li><p>PureComponent和Component有何区别</p>
<p>React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate()。</p>
<p>在PureComponent中，如果包含比较复杂的数据结构，可能会因深层的数据不一致而产生错误的否定判断，导致界面得不到更新。</p>
</li>
<li><p>react事件和dom事件区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. event 是 SyntheticEvent 组合事件对象，模拟出来 DOM 事件所有能力</span><br><span class="line">2. event.nativeEvent 是原生事件对象</span><br><span class="line">3. 所有的事件，都被挂载到 document 上，为了性能</span><br><span class="line">4. 和 DOM 事件不一样，和 Vue 事件也不一样</span><br></pre></td></tr></table></figure></li>
<li><p>react性能优化</p>
<p>使用shouldComponentUpdate来优化组件</p>
<p>shouldComponentUpdate的实现方式，shouldComponentUpdate在比对prop和上次渲染所用的prop方面，依然用的是尽量简单的方法，做的是所谓的“浅层比较”。简单来说就是用JavaScript的===操作符来比较，如果prop的类型是字符串或者数字，只要值相同，那么“浅层比较”也会认为二者相同，但是，如果prop的类型是复杂对象，那么“浅层比较”的方式只看这两个prop是不是同一个对象的引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是两个不同的prop。</p>
</li>
<li><p>react和vue区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定。</span><br><span class="line">2、vue的语法较为简单，适用于小型项目创建，而react更适用于Web端和原生App的开发，侧重于大型应用。</span><br><span class="line">3、vue拥有更快的渲染速度和更小的体积，react则拥有更大的生态圈，可以带来更多的工具支持。</span><br><span class="line">4、模板渲染方式的不同</span><br><span class="line">在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。</span><br><span class="line"></span><br><span class="line">在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="11-实战"><a href="#11-实战" class="headerlink" title="11.实战"></a>11.实战</h1><p>1.promise封装ajax？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Promise 封装 ajax</span><br><span class="line">function fetch(method, url, data)&#123;  //1.</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123; //2.</span><br><span class="line">        var xhr = new XMLHttpRequest();//3.</span><br><span class="line">        var method = method || &quot;GET&quot;;</span><br><span class="line">        var data = data || null;</span><br><span class="line">        xhr.open(method, url, true);//4.</span><br><span class="line">        xhr.send(data);//post请求发送数据</span><br><span class="line">        xhr.onreadystatechange = function() &#123;//5.</span><br><span class="line">            if(xhr.status === 200 &amp;&amp; xhr.readyState === 4)&#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                reject(xhr.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 使用</span><br><span class="line">fetch(&quot;GET&quot;, &quot;addFun?id=123&quot;, null)</span><br><span class="line">.then(result =&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.移动端1像素问题如何解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">移动端 1px 像素问题及解决办法</span><br><span class="line">前言：在移动端web开发中，UI设计稿中设置边框为1像素，前端在开发过程中如果出现border:1px，测试会发现在某些机型上，1px会比较粗，即是较经典的 移动端1px像素问题。</span><br><span class="line">解决办法</span><br><span class="line">//1.把边框值缩小  小于1px</span><br><span class="line"> @media screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">     .border &#123; border: 0.5px solid #ccc &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @media screen and (-webkit-min-device-pixel-ratio: 3) &#123;</span><br><span class="line">     .border &#123; border: 0.333333px solid #ccc &#125;</span><br><span class="line">&#125;</span><br><span class="line">2.使用transform:scaleY</span><br><span class="line">.line&#123;</span><br><span class="line">     width: 100%;</span><br><span class="line">     height: 1px;</span><br><span class="line">     background-color: black;</span><br><span class="line">     margin-top: 100px;</span><br><span class="line">     transform: scaleY(0.33333);  //y轴缩放了1/3</span><br><span class="line">     transform-origin: 0 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>3.如何解决vuex刷新之后数据重置的问题 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于vuex是保存在内存中的所以每次页面刷新数据都会被重置，相当于重新加载js代码。</span><br><span class="line">方法一：利用beforeunload事件在用户刷新页面时将vuex的store存入sessionstorage中然后再在页面加载时获从sessionstorage中获取,replaceState  store，然后清除</span><br><span class="line">方法二：也是我研究iview-admin时总结出来的方法。登入时保存token在cookie中，store中保存的token用函数指向这个cookie，再路由守卫中做控制当token存在但却没有用户信息时调用获取用户信息的actiion方法为store中的用户信息重新赋值，也就是在每次刷新页面时都会重新请求一遍用户信息</span><br></pre></td></tr></table></figure>

<p>4.git常用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Git常用操作命令：</span><br><span class="line">1) 远程仓库相关命令</span><br><span class="line">检出仓库：$ git clone git://github.com/jquery/jquery.git</span><br><span class="line">查看远程仓库：$ git remote -v</span><br><span class="line">添加远程仓库：$ git remote add [name] [url]</span><br><span class="line">删除远程仓库：$ git remote rm [name]</span><br><span class="line">修改远程仓库：$ git remote set-url --push [name] [newUrl]</span><br><span class="line">拉取远程仓库：$ git pull [remoteName] [localBranchName]</span><br><span class="line">推送远程仓库：$ git push [remoteName] [localBranchName]</span><br><span class="line">2）分支(branch)操作相关命令</span><br><span class="line">查看本地分支：$ git branch</span><br><span class="line">查看远程分支：$ git branch -r</span><br><span class="line">创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支</span><br><span class="line">切换分支：$ git checkout [name]</span><br><span class="line">创建新分支并立即切换到新分支：$ git checkout -b [name]</span><br><span class="line">删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</span><br><span class="line">合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并</span><br><span class="line">创建远程分支(本地分支push到远程)：$ git push origin [name]</span><br><span class="line">删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] </span><br></pre></td></tr></table></figure>

<p>5.promise原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise原理实现</span><br><span class="line">基于上面的应用场景发现promise可以有三种状态，分别是pedding 、Fulfilled、 Rejected。</span><br><span class="line">Pending Promise对象实例创建时候的初始状态</span><br><span class="line">Fulfilled 可以理解为成功的状态</span><br><span class="line">Rejected可以理解为失败的状态</span><br><span class="line">·构造一个Promise实例需要给Promise构造函数传入一个函数。传入的函数需要有两个形参，两个形参都是function类型的参数。分别是resolve和reject。</span><br><span class="line">·Promise上还有then方法，then 方法就是用来指定Promise 对象的状态改变时确定执行的操作，resolve 时执行第一个函数（onFulfilled），reject时执行第二个函数（onRejected）</span><br><span class="line">·当状态变为resolve时便不能再变为reject，反之同理。</span><br></pre></td></tr></table></figure>

<p>6.router和localhost.href和go(-1)区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①vue-router使用pushState进行路由更新，静态跳转，页面不会重新加载；location.href会触发浏览器，页面重新加载一次</span><br><span class="line">②vue-router使用diff算法，实现按需加载，减少dom操作</span><br><span class="line">③vue-router是路由跳转或同一个页面跳转；location.href是不同页面间跳转；</span><br><span class="line">④vue-router是异步加载this.$nextTick(()=&gt;&#123;获取url&#125;)；location.href是同步加载</span><br><span class="line">location.href可直接获取当前路径</span><br></pre></td></tr></table></figure>

<p>7.css动态效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">css3动画属性有哪些</span><br><span class="line">transition ：   平衡过渡</span><br><span class="line">animation： 动画</span><br><span class="line">transform： 改变元素的大小、位置 </span><br><span class="line"></span><br><span class="line">https://www.w3cschool.cn/css3/css3-qs8z2oq9.html</span><br><span class="line">1、CSS3和SVG文字背景动画，超酷的文字特效</span><br><span class="line">2、CSS3下划线跟随动画菜单，背景色渐变</span><br><span class="line">3、CSS3手势变换动画特效</span><br><span class="line">4、基于Bootstrap的CSS3面包屑菜单</span><br><span class="line">5、纯CSS3实现圆盘时钟动画</span><br><span class="line">6、HTML5/CSS3 3D下拉折叠菜单 3D子菜单</span><br><span class="line">7、动感的CSS3 Loading文字特效</span><br></pre></td></tr></table></figure>

<p>8.vue框架搭建（中高级）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/GeniusZ/p/12531027.html</span><br><span class="line">初始化项目vue-cli</span><br><span class="line">修改目录结构</span><br><span class="line">多环境运行</span><br><span class="line">axios封装</span><br><span class="line">模块化vuex</span><br><span class="line">全局引用样式</span><br><span class="line">移动端适配配置</span><br><span class="line">常用util</span><br><span class="line">引入第三方UI框架</span><br><span class="line">配置vue.config.js文件</span><br><span class="line">vue项目框架性能优化（重点）</span><br><span class="line">	js,css代码的最小化压缩和分割</span><br><span class="line">    js,css代码公用代码提取, 按需引入(cdn加载)</span><br><span class="line">    图片文件的压缩</span><br><span class="line">    gzip的压缩</span><br><span class="line">    去除console.log</span><br></pre></td></tr></table></figure>

<p>9.前端上百万的点，加载会崩溃，有啥性能优化方案？(大数据项目)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分页分表，比如前端可以把数据分页展示，后端也分段吐数据从渲染上解决：</span><br><span class="line">异步渲染，比如进入页面先不渲染，然后加载好页面再渲染。</span><br><span class="line">局部渲染：只渲染目前可见区域的数据，再渲染次屏数据。</span><br><span class="line">还有性能瓶颈，可以考虑web worker 做压缩和解码，也可以考虑离屏canvas做预渲染。</span><br><span class="line">减少网络耗时：压缩数据，gzip等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10,说下云计算？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">云计算，有这么几大类：</span><br><span class="line">云主机，云应用，云存储等。</span><br><span class="line">云主机，目前经常dao见到的是云桌面，就是在互联网上，或者企业云环境上，有一些虚拟的电脑，你通过终端登录到这些虚拟电脑上，这些虚拟的电脑给你呈现了一个跟普通电脑一样的启动画面，进入windows、linux或其它操作系统，你可以象用自己的电脑一样在上面装应用，办公。</span><br><span class="line">举例：eyeos</span><br><span class="line">云应用，简单理解，就是有在互联网上有一些应用，这些应用可以通过浏览器、客户端等操作，数据放在互联网上，用目前经常用的是办公、事务管理类的应用，比如office365，云便签等。云应用可以在任意地点通过多种方式访问。</span><br><span class="line">举例：evernote</span><br><span class="line">云存储，广泛意义上的云存储范围非常大，但是常见的云存储实际上很多人都在用了，简单理解就是互联网上放了一块逻辑上归属于你的硬盘，比如百度云的云盘上面可以存放文件、视频什么的。</span><br><span class="line">举例：百度云、360云盘、腾讯微云、新浪微盘</span><br></pre></td></tr></table></figure>

<p>11.ajax和axios的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。</span><br><span class="line">简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。</span><br></pre></td></tr></table></figure>

<p>12.在vue中如何监听对象obj.a</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    obj.a:&#123;</span><br><span class="line">        handler(new_value,old_value)&#123;</span><br><span class="line">            console.log(new_value,old_value)</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.在vue中如何给属性动态添加新属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在组件上添加属性 this.$set(this.data,&quot;obj&quot;,value&#x27;);  //vue2 obj添加删除属性</span><br><span class="line">删除属性this.$delete(this.data,&quot;obj&quot;,value&#x27;);</span><br></pre></td></tr></table></figure>

<p>14.简单描述nextTick原理及作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.异步说明</span><br><span class="line">Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</span><br><span class="line">2.事件循环说明</span><br><span class="line">简单来说，Vue在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</span><br><span class="line">作用：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</span><br></pre></td></tr></table></figure>

<p>15.如何解决弹性盒布局div会随内部表格被撑开的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">弹性布局时div被内容撑开导致变形,直接将内容width or height 设为0;</span><br></pre></td></tr></table></figure>

<p>16.兼容pc端移动端响应式页面，pc端左右轮播，移动端上下轮播实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/kzj0916/article/details/108164259</span><br><span class="line">一，通过媒体查询实现响应式（@media）</span><br><span class="line">优点：适用于小型网页，用户交互较少的项目，代码用量较少；</span><br><span class="line">缺点：在页面内容过多，用户交互过多的时候，如果通过 @media 来一个个改的话，那代码量可就很多了，而且也不方便维护。因此需要另一种方式来解决这个问题。</span><br><span class="line"></span><br><span class="line">二，通过判断打开设备的类型，区分需要显示的方式和界面</span><br><span class="line"> //App.vue</span><br><span class="line">  mounted() &#123;</span><br><span class="line">      if (this._isMobile()) &#123;</span><br><span class="line">        alert(&quot;手机端&quot;);</span><br><span class="line">        // this.$router.push(&#x27;/m_index&#x27;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        alert(&quot;pc端&quot;);</span><br><span class="line">        // this.$router.replace(&#x27;/pc_index&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      //App.vue</span><br><span class="line">      _isMobile() &#123;</span><br><span class="line">        let flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)</span><br><span class="line">        return flag;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>17.$set作用和$delete作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果我们在创建实例以后，再在实例上绑定新属性，vue是无法进行双向绑定的。</span><br><span class="line">$set 用于手动让vue实现动态绑定数据 $delete反之</span><br></pre></td></tr></table></figure>

<p>18.路由懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、为什么要使用路由懒加载</span><br><span class="line">　　为给客户更好的客户体验，首屏组件加载速度更快一些，解决白屏问题。</span><br><span class="line">二、定义</span><br><span class="line">　　懒加载简单来说就是延迟加载或按需加载，即在需要的时候的时候进行加载。</span><br><span class="line">三、使用</span><br><span class="line">　　常用的懒加载方式有两种：即使用vue异步组件 和 ES中的import</span><br></pre></td></tr></table></figure>

<p>19.数组新特性，map和foreach区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreEach()方法:针对每一个元素执行提供的函数。</span><br><span class="line">map()方法:创建一个新的数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来。</span><br><span class="line">区别</span><br><span class="line">forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。</span><br></pre></td></tr></table></figure>

<p>20.promise.all</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一、Pomise.all的使用</span><br><span class="line">常见使用场景 ： 多个异步结果合并到一起</span><br><span class="line">Promise.all可以将多个Promise实例包装成一个新的Promise实例。用于将多个Promise实例，包装成一个新的Promise实例。</span><br><span class="line">二、Pomise.race的使用</span><br><span class="line">类似于Promise.all() ,区别在于 它有任意一个返回成功后，就算完成，但是 进程不会立即停止</span><br><span class="line">常见使用场景：把异步操作和定时器放到一起，如果定时器先触发，认为超时，告知用户</span><br></pre></td></tr></table></figure>

<p>21.async await</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async 是一个修饰符，async 定义的函数会默认的返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数</span><br><span class="line">await 也是一个修饰符，</span><br><span class="line">await 关键字 只能放在 async 函数内部， await关键字的作用 就是获取 Promise中返回的内容， 获取的是Promise函数中resolve或者reject的值</span><br><span class="line">async/await 的优势在于处理 then 链</span><br><span class="line">单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）</span><br><span class="line">async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</span><br><span class="line">await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误</span><br></pre></td></tr></table></figure>

<p>22.图片懒加载的实现原理和方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 原理</span><br><span class="line">图片懒加载是前端页面优化的一种方式，在页面中有很多图片的时候，图片加载就需要很多时间，很耗费服务器性能，不仅影响渲染速度还会浪费带宽，为了解决这个问题，提高用户体验，所以就出现了懒加载这种方式来减轻服务器的压力，优先加载可视区域的内容，其他部分等进入了可视区域再加载，从而提高性能。</span><br><span class="line">2. 实现</span><br><span class="line">思路：在图片没有进入可视区域时，先不给的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。图片的真实地址需要存储在data-src中。</span><br><span class="line">图片没有进入可视区域，也就是说图片的offsetTop需要小于页面的可视高度，但想一想，当图片在页面的下方的时候呢，需要页面滚动了一段距离之后才能看到图片，所以这里需要满足img.scrollTop &lt; 页面的可视区域高度+页面滚动的高度，这里是实现图片懒加载的关键，接下来看具体代码的实现</span><br></pre></td></tr></table></figure>

<p>23.js和css实现动态效果方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">css动画 题库7</span><br><span class="line">js实现动画核心要用到两个函数，一个是setTimeOut,另一个是setInterval.</span><br></pre></td></tr></table></figure>

<p>24.路由传参的方式，query和params各个方式之间的优劣</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1.query后边传递的东西带括号</span><br><span class="line">2.query传值在浏览器地址栏传递数据可见，params不可见</span><br><span class="line">3.接收数据必须在页面加载完成后（mounted而不是created）</span><br><span class="line">4.query传递的数据在页面刷新后能够保留，params不行</span><br></pre></td></tr></table></figure>

<p>25.根据接口中的数据进行区别挂载，怎么实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js根据json数据中的某一个属性来给数据分组的方法</span><br></pre></td></tr></table></figure>

<p>26.路由跳转之前的钩子函数中是否可以过去例如this这样的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">    // 不！能！获取组件实例 `this`</span><br><span class="line">    // 因为当钩子执行前，组件实例还没被创建</span><br><span class="line">　　 next() // 必须有这个，相当于一个按钮开启一样。</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">　　　next() // 必须有这个，相当于一个按钮开启一样</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    // 导航离开该组件的对应路由时调用</span><br><span class="line">    // 可以访问组件实例 `this`</span><br><span class="line">　　next() // 必须有这个，相当于一个按钮开启一样</span><br><span class="line">  &#125;</span><br><span class="line"> beforeRouteEnter 钩子 不能 访问 this，因为钩子在导航确认前被调用，因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</span><br><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  next(vm =&gt; &#123;</span><br><span class="line">    // 通过 `vm` 访问组件实例</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">你可以 在 beforeRouteLeave 中直接访问 this。这个 leave 钩子通常用来禁止用户在还未保存修改前突然离开。可以通过 next(false) 来取消导航。同时注意必须有这个next()，相当于一个按钮开启一样。</span><br></pre></td></tr></table></figure>

<p>27.<br>28.父子组件传值，父组件中值改变，子组建如何监听值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6个方法</span><br></pre></td></tr></table></figure>

<p>29.宏任务和微任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1.宏任务</span><br><span class="line">(macro)task，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</span><br><span class="line">浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染</span><br><span class="line">宏任务包含：</span><br><span class="line">script(整体代码)</span><br><span class="line">setTimeout</span><br><span class="line">setInterval</span><br><span class="line">I/O</span><br><span class="line">UI交互事件</span><br><span class="line">postMessage</span><br><span class="line">MessageChannel</span><br><span class="line">setImmediate(Node.js 环境)</span><br><span class="line">2.微任务</span><br><span class="line">microtask,可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。</span><br><span class="line">所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。</span><br><span class="line">微任务包含：</span><br><span class="line">Promise.then</span><br><span class="line">Object.observe</span><br><span class="line">MutaionObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br><span class="line">3.运行机制</span><br><span class="line">在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：</span><br><span class="line">执行一个宏任务（栈中没有就从事件队列中获取）</span><br><span class="line">执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</span><br><span class="line">宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</span><br><span class="line">当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</span><br><span class="line">渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</span><br><span class="line">	   async function job1()&#123;</span><br><span class="line">			console.log(&#x27;a&#x27;)//1</span><br><span class="line">			await job2()</span><br><span class="line">			console.log(&#x27;b&#x27;)//4</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		async function job2()&#123;</span><br><span class="line">			console.log(&#x27;c&#x27;)//2</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		setTimeout(function()&#123;</span><br><span class="line">			new Promise(function(resoive)&#123;</span><br><span class="line">				console.log(&#x27;d&#x27;)//6</span><br><span class="line">				resoive()</span><br><span class="line">			&#125;).then(function()&#123;</span><br><span class="line">				console.log(&#x27;e&#x27;)//8</span><br><span class="line">			&#125;)</span><br><span class="line">			console.log(&#x27;f&#x27;)//7</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		job1()</span><br><span class="line"></span><br><span class="line">		   new Promise(function(resoive)&#123;</span><br><span class="line">				resoive()</span><br><span class="line">			&#125;).then(function()&#123;</span><br><span class="line">				console.log(&#x27;g&#x27;)//5</span><br><span class="line">			&#125;)</span><br><span class="line">			</span><br><span class="line">			console.log(&#x27;g&#x27;)//3</span><br><span class="line">			</span><br><span class="line">			答案：a c g b g d f e</span><br></pre></td></tr></table></figure>



<p>30.es class类和继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;//创建Animal类            </span><br><span class="line">    constructor(species) &#123; //constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用该方法。                </span><br><span class="line">        this.species = species //Animal类 自己定义了species 属性            </span><br><span class="line">    &#125;            </span><br><span class="line">    eat() &#123; //Animal类 自己又定义了eat 方法                </span><br><span class="line">        console.log(&#x27;eateat&#x27;)            </span><br><span class="line">    &#125;            </span><br><span class="line">    static isAnimal() &#123; //静态方法需要 static 修饰                </span><br><span class="line">        console.log(&#x27;i don\&#x27;t know &#x27;)            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;        </span><br><span class="line">class Lion extends Animal &#123;//创建Lion类            </span><br><span class="line">    constructor(species, size) &#123; //constructor方法如果没有显式定义，会隐式生成一个constructor方法。所以即使你没有添加构造函数，构造函数也是存在的。constructor方法默认返回实例对象this，但是也可以指定constructor方法返回一个全新的对象，让返回的实例对象不是该类的实例。                </span><br><span class="line">        // return new Animal();// 这里没有用this哦，直接返回一个全新的对象                </span><br><span class="line">        super(species)//继承父类的属性，必须写在任何this的开头，不然会报错                </span><br><span class="line">        this.size = size  // Lion类 自己又定义了size 属性                </span><br><span class="line">        // 继承和定义属性都在 构造函数 constructor 中继承或定义            </span><br><span class="line">    &#125;            </span><br><span class="line">    eat() &#123;//重写原型方法                </span><br><span class="line">        console.log(&#x27;eatmeat&#x27;)            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;        </span><br><span class="line">let lion = new Lion(&#x27;Feline family&#x27;, &#x27;big&#x27;)        </span><br><span class="line">let animal = new Animal(&#x27;Feline big&#x27;)        </span><br><span class="line">console.log(lion.species) //继承了父类的属性        </span><br><span class="line">console.log(lion.size) //Lion类的属性        </span><br><span class="line">Animal.isAnimal() //isAnimal方法是静态方法， Animal类中有这个方法，所以能调用，animal 实例调用不了 animal.isAnimal（） 会报错        </span><br><span class="line">Lion.isAnimal() //isAnimal方法是静态方法， Lion 类中继承了这个方法，所以能调用，lion 实例调用不了 lion.isAnimal（） 会报错        </span><br><span class="line">// animal.isAnimal()  //Uncaught TypeError: animal.isAnimal is not a function        </span><br><span class="line">// lion.isAnimal()  //Uncaught TypeError: lion.isAnimal is not a function        </span><br><span class="line">// 类的所有方法都定义在类的prototype属性上面，所有类中定义的方法都会被实例继承，如果在类方法前面加上static关键字就不会被实例继承了。        </span><br><span class="line">// 静态方法是直接通过类名来调用。Animal.isAnimal() Lion.isAnimal() 能调用成功        </span><br><span class="line">// Animal.eat() //类的所有方法都定义在类的prototype属性上面，  Animal.eat() 调用会报错        </span><br><span class="line">// Lion.eat() // 类的所有方法都定义在类的prototype属性上面，  Lion.eat() 调用会报错        </span><br><span class="line">lion.eat() //eatmeat        </span><br><span class="line">animal.eat()  // eateat        </span><br><span class="line">//constructor中定义的属性可以称为实例属性（即定义在this对象上），constructor外声明的属性都是定义在原型上的，可以称为原型属性（即定义在class上)。hasOwnProperty()函数用于判断属性是否是实例属性。其结果是一个布尔值，true说明是实例属性，false说明不是实例属性。in操作符会在通过对象能够访问给定属性时返回true,无论该属性存在于实例中还是原型中。        </span><br><span class="line">console.log(lion.hasOwnProperty(&quot;size&quot;));//true        </span><br><span class="line">console.log(lion.hasOwnProperty(&quot;size&quot;));//true        </span><br><span class="line">console.log(lion.hasOwnProperty(&quot;eat&quot;));//false        </span><br><span class="line">console.log(&quot;size&quot; in lion);//true        </span><br><span class="line">console.log(&quot;size&quot; in lion);//true        </span><br><span class="line">console.log(&quot;eat&quot; in lion);//true        </span><br><span class="line">console.log(&quot;eatSize&quot; in lion);//false        </span><br><span class="line">//类的所有实例共享一个原型对象，它们的原型都是Person.prototype，所以proto属性是相等的        </span><br><span class="line">var lion2 = new Lion(&#x27;Feline family2&#x27;, &#x27;big2&#x27;)        </span><br><span class="line">console.log(lion.__proto__ === lion2.__proto__);//true        </span><br><span class="line">//由此，也可以通过proto来为类增加方法。使用实例的proto属性改写原型，会改变Class的原始定义，影响到所有实例，所以不推荐使用！        </span><br><span class="line">// 另外要理解的两点：1.实例属性指的是在构造函数方法中定义的属性和方法，每一个实例对象都独立开辟一块内存空间用于保存属性和方法。        </span><br><span class="line">//                2.原型属性指的是用于创建实例对象的构造函数的原型的属性，每一个创建的实例对象都共享原型属性。    </span><br></pre></td></tr></table></figure>

<p>31.深拷贝实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">1.JSON方法实现</span><br><span class="line">//_tmp和result是相互独立的，没有任何联系，有各自的存储空间。</span><br><span class="line">let deepClone = function (obj) &#123;</span><br><span class="line">    let _tmp = JSON.stringify(obj);//将对象转换为json字符串形式</span><br><span class="line">    let result = JSON.parse(_tmp);//将转换而来的字符串转换为原生js对象</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj1 = &#123;</span><br><span class="line">    weiqiujaun: &#123;</span><br><span class="line">        age: 20,</span><br><span class="line">        class: 1502</span><br><span class="line">    &#125;,</span><br><span class="line">    liuxiaotian: &#123;</span><br><span class="line">        age: 21,</span><br><span class="line">        class: 1501</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let test = deepClone(obj1);</span><br><span class="line">console.log(test);</span><br><span class="line"></span><br><span class="line">2.用for…in实现遍历和复制</span><br><span class="line"></span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">    let result = typeof  obj.splice === &quot;function&quot; ? [] : &#123;&#125;;</span><br><span class="line">    if (obj &amp;&amp; typeof obj === &#x27;object&#x27;) &#123;</span><br><span class="line">        for (let key in obj) &#123;</span><br><span class="line">            if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;</span><br><span class="line">                result[key] = deepClone(obj[key]);//如果对象的属性值为object的时候，递归调用deepClone,即在吧某个值对象复制一份到新的对象的对应值中。</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result[key] = obj[key];//如果对象的属性值不为object的时候，直接复制参数对象的每一个键值到新的对象对应的键值对中。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let testArray = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];</span><br><span class="line">let testRes = deepClone(testArray);</span><br><span class="line">console.log(testRes);</span><br><span class="line">console.log(typeof testRes[1]);</span><br><span class="line">let testObj = &#123;</span><br><span class="line">    name: &quot;weiqiujuan&quot;,</span><br><span class="line">    sex: &quot;girl&quot;,</span><br><span class="line">    age: 22,</span><br><span class="line">    favorite: &quot;play&quot;,</span><br><span class="line">    family: &#123;brother: &quot;son&quot;, mother: &quot;haha&quot;, father: &quot;heihei&quot;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">let testRes2 = deepClone(testObj);</span><br><span class="line">testRes2.family.brother = &quot;weibo&quot;;</span><br><span class="line">console.log(testRes2);</span><br><span class="line"></span><br><span class="line">3.利用数组的Array.prototype.forEach进copy</span><br><span class="line">let deepClone = function (obj) &#123;</span><br><span class="line">    let copy = Object.create(Object.getPrototypeOf(obj));</span><br><span class="line">    let propNames = Object.getOwnPropertyNames(obj);</span><br><span class="line">    propNames.forEach(function (items) &#123;</span><br><span class="line">        let item = Object.getOwnPropertyDescriptor(obj, items);</span><br><span class="line">        Object.defineProperty(copy, items, item);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    return copy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let testObj = &#123;</span><br><span class="line">    name: &quot;weiqiujuan&quot;,</span><br><span class="line">    sex: &quot;girl&quot;,</span><br><span class="line">    age: 22,</span><br><span class="line">    favorite: &quot;play&quot;,</span><br><span class="line">    family: &#123;brother: &quot;wei&quot;, mother: &quot;haha&quot;, father: &quot;heihei&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let testRes2 = deepClone(testObj);</span><br><span class="line">console.log(testRes2);</span><br><span class="line"></span><br><span class="line">4.浅拷贝（使用object.assign方法）</span><br><span class="line">let target=[];</span><br><span class="line">let testArr=[2,3,5,8];</span><br><span class="line">Object.assign(target,testArr);</span><br><span class="line">console.log(target);</span><br><span class="line">testArr.push(8);</span><br><span class="line">console.log(&quot;我是原来的&quot;+target+&quot;,我是现在的&quot;+testArr);</span><br></pre></td></tr></table></figure>

<p>32。写出几种会话跟踪用户的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①　URL重写</span><br><span class="line">②　隐藏表单</span><br><span class="line">③　Cookie</span><br><span class="line">④　Session</span><br></pre></td></tr></table></figure>

<p>33.http的method有几种以及各自含义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET: 获取资源###</span><br><span class="line">HEAD: 获取报文头部###</span><br><span class="line">POST: 传输实体主体###</span><br><span class="line">PUT: 传输文件###</span><br><span class="line">DELETE: 删除文件###</span><br><span class="line">OPTIONS: 询问支持方法####</span><br><span class="line">GET : 获取资源</span><br></pre></td></tr></table></figure>

<p>34.http请求报文中user-agent和referer含义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user-agent作用</span><br><span class="line">User-Agent：产生请求的浏览器类型。</span><br><span class="line">User-Agent会告诉网站服务器，访问者是通过什么工具来请求的，如果是爬虫请求，一般会拒绝，如果是用户浏览器，就会应答。</span><br><span class="line"></span><br><span class="line">Referer的作用</span><br><span class="line">1.防盗链。</span><br><span class="line">比如我只允许我自己的网站访问我自己的图片服务器，那我的域名是www.google.com，那么图片服务器每次取到Referer来判断一下是不是我自己的域名www.google.com，如果是就继续访问，不是就拦截。</span><br><span class="line">2.防止恶意请求</span><br><span class="line">比如静态请求是*.html结尾的，动态请求是*.shtml，那么由此可以这么用，所有的*.shtml请求，必须 Referer 为我自己的网站。</span><br></pre></td></tr></table></figure>

<p>35.http底层的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.http协议: 超文本传输协议,可以传递各种类型的文件,是使用最广泛的协议模式, 是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用</span><br><span class="line">2.http协议的底层是在应用层里,是一个特殊处理的socket,建立在TCP/IP协议之上的一种广泛应用</span><br><span class="line">2.1.服务器先初始化一个socket,与端口绑定,对端口进行监听,调用阻塞,等待客户端的连接</span><br><span class="line">2.2.初始化客户端的socket,与服务器的socket连接,需要经过三次握手</span><br><span class="line">2.3.客户端向服务器发送数据请求.景行链接</span><br><span class="line">2.4.服务器将数据返回给客户端,客户端读取数据,显示在界面上</span><br><span class="line">2.5.客户端断开连接需要经过四次握手断开连接</span><br></pre></td></tr></table></figure>

<p>36.整个工作流程从产品经理接项目开始描述一遍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求经理拿到需求，并确认需求，然后开组会讲解需求并分配需求，如果有难点的技术功能实现需大家商讨下如何实现。待大家都能了解需求和功能实现之后进行开发，2周一个迭代，其中包括修改上次迭代提出的bug，并更新发布最新版进行复测，待所有功能实现完毕后，经需求经理确认功能，ui确认设计稿还原度后然后经由测试组进行测试，测试通过之后进行上线部署；</span><br></pre></td></tr></table></figure>

<p>37.vuex里module具体有什么作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</span><br><span class="line">为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</span><br></pre></td></tr></table></figure>

<p>38.路由hstory，会报404错误怎样解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">为什么出现404？</span><br><span class="line">通过history api，我们丢掉了丑陋的#，但是它也有个问题：不怕前进，不怕后退，就怕刷新，f5，（如果没有准备的话）,因为刷新是实实在在地去请求服务器的,不玩虚的。</span><br><span class="line">在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题.但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</span><br><span class="line">常用解决方案：</span><br><span class="line">1.后台是node的话，可以使用connect-history-api-fallback 中间件来解决</span><br><span class="line">2.后台部署在nginx上的话，需要配置</span><br><span class="line">        location / &#123;</span><br><span class="line">          try_files $uri $uri/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line">3.后台部署在tomcat上，在tocmat的webapps下的项目中创建WEB-INF文件夹，在文件夹中创建文件web.xml。格式如下</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee</span><br><span class="line">http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt;</span><br><span class="line">&lt;display-name&gt;Router for Tomcat&lt;/display-name&gt;</span><br><span class="line">  &lt;error-page&gt;</span><br><span class="line">  &lt;error-code&gt;404&lt;/error-code&gt;</span><br><span class="line">  &lt;location&gt;/index.html&lt;/location&gt;</span><br><span class="line">  &lt;/error-page&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line">警告</span><br><span class="line">给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;history&#x27;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#x27;*&#x27;, component: NotFoundComponent &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>39.当表单提交文件的时候，用什么属性和参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">form表单提交文件时必须指定的两个属性</span><br><span class="line">method=&quot;post&quot; </span><br><span class="line">enctype=&quot;multipart/form-data&quot;</span><br></pre></td></tr></table></figure>

<p>40.promise并行和串行执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建promise</span><br><span class="line"> * @param &#123;Number&#125; value </span><br><span class="line"> */</span><br><span class="line">function makePromise (value) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;, Math.random() * 1000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function print (value) &#123;</span><br><span class="line">  return value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let promises = [1, 3, 4, 5, 6].map((item, index) =&gt; &#123;</span><br><span class="line">  return makePromise(item)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 并行执行</span><br><span class="line">Promise.all(promises)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;done&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;error&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 串行执行</span><br><span class="line">let parallelPromises = promises.reduce(</span><br><span class="line">  (total, currentValue) =&gt; total.then(() =&gt; currentValue.then(print)),Promise.resolve()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">parallelPromises</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">  // console.log(&#x27;done&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;done&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 顺带复习一下reduce方法</span><br><span class="line"></span><br><span class="line">reduce((total, currentValue, currentIndex, arr) =&gt; &#123;&#125;, initialValue)</span><br><span class="line">let arr1 = [1, 2, 3, 4, 5]</span><br><span class="line">let res = arr1.reduce((total, currentValue, currentIndex, arr) =&gt; &#123;</span><br><span class="line">    return total + currentValue</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>41.说说数据结构和算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合</span><br><span class="line">常用的数据结构有：堆 栈 数组 队列 链表 树 哈希 图表</span><br><span class="line">算法简单来说就是解决问题的方案步骤</span><br><span class="line">常用的算法有：</span><br><span class="line">①、排序</span><br><span class="line">排序就是对一组数据按照一定的顺序（从大到小或者从小到大）进行排序；</span><br><span class="line">常见排序如下：</span><br><span class="line">简单排序：冒泡排序、选择排序、插入排序；</span><br><span class="line">高级排序：快速排序、希尔排序、归并排序、基数排序、鸡尾酒排序等等；</span><br><span class="line">②、递归</span><br><span class="line">递归是一种直接或者间接调用自身的一种算法，递归的目的是简化程序设计使程序更加易读；</span><br><span class="line">③、查找</span><br><span class="line">在一些（有序的/无序的）数据元素中，通过一定的方法找出与给定关键字相同的数据元素就叫做查找；</span><br><span class="line">④、统计</span><br><span class="line">指对有关数据的搜集、整理、计算、分析、解释、表述等的活动</span><br></pre></td></tr></table></figure>

<p>42.怎样实现数据加密。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目前主流的加密技术有对称加密例如DES，3DES和AES，然后还有非对称加密技术：例如RSA和椭圆加密算法。对称加密的话，就是用来加密和解密的密钥是一样的，非对称加密的话，加密的密钥和解密的密钥是不一样的，用加密的密钥加密以后，只有配对的另外一个密钥才能解开。</span><br><span class="line">另外我们还可以常常看到MD5，SHA，SHA1之类的算法，其实他们不是加密算法，因为他们的结算结果不可逆</span><br></pre></td></tr></table></figure>

<p>43.降幂怎么做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.升幂排序</span><br><span class="line">var arr = [1,12,4,124,45,8,99998,456];</span><br><span class="line">function compare(value1,value2)&#123;</span><br><span class="line">    if(value1&gt;value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else if(value1&lt;value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.sort(compare);</span><br><span class="line">2.降幂排序</span><br><span class="line">var arr = [1,12,4,124,45,8,99998,456];</span><br><span class="line">function compare(value1,value2)&#123;</span><br><span class="line">    if(value1&gt;value2)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else if(value1&lt;value2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.sort(compare);</span><br><span class="line">3还有一种更简单的排序方法</span><br><span class="line">var arr = [1,12,4,124,45,8,99998,456];</span><br><span class="line">function compare(value1,value2)&#123;</span><br><span class="line">    return value1 - value2;</span><br><span class="line">&#125;</span><br><span class="line">arr.sort(compare);</span><br></pre></td></tr></table></figure>

<p>44.less和cass区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CSS有具体以下几个缺点：</span><br><span class="line">语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</span><br><span class="line">没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</span><br><span class="line">不同之处：</span><br><span class="line">1、Less环境较Sass简单</span><br><span class="line">2、Less使用较Sass简单</span><br><span class="line">3、从功能出发，Sass较Less略强大一些</span><br><span class="line">①sass有变量和作用域。</span><br><span class="line">-$variable，likephp；</span><br><span class="line">-#｛$variable｝likeruby；</span><br><span class="line">-变量有全局和局部之分，并且有优先级。</span><br><span class="line">②sass有函数的概念；</span><br><span class="line">-@function和@return以及函数参数（还有不定参）可以让你像js开发那样封装你想要的逻辑。</span><br><span class="line">-@mixin类似function但缺少像function的编程逻辑，更多的是提高css代码段的复用性和模块化，这个用的人也是最多的。</span><br><span class="line">-ruby提供了非常丰富的内置原生api。</span><br><span class="line">③进程控制：</span><br><span class="line">-条件：@if@else；</span><br><span class="line">-循环遍历：@for@each@while</span><br><span class="line">-继承：@extend</span><br><span class="line">-引用：@import</span><br><span class="line">④数据结构：</span><br><span class="line">-$list类型=数组；</span><br><span class="line">-$map类型=object；</span><br><span class="line">其余的也有string、number、function等类型</span><br><span class="line">4、Less与Sass处理机制不一样</span><br><span class="line">5、关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。</span><br></pre></td></tr></table></figure>

<p>45.去重方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">双循环去重</span><br><span class="line">双重for（或while）循环是比较笨拙的方法，它实现的原理很简单：先定义一个包含原始数组第一个元素的数组，然后遍历原始数组，将原始数组中的每个元素与新数组中的每个元素进行比对，如果不重复则添加到新数组中，最后返回新数组；因为它的时间复杂度是O(n^2)，如果数组长度很大，那么将会非常耗费内存.</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let res = [arr[0]]</span><br><span class="line">    for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        let flag = true</span><br><span class="line">        for (let j = 0; j &lt; res.length; j++) &#123;</span><br><span class="line">            if (arr[i] === res[j]) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            res.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line">indexOf方法去重</span><br><span class="line">数组的indexOf()方法可返回某个指定的元素在数组中首次出现的位置。该方法首先定义一个空数组res，然后调用indexOf方法对原来的数组进行遍历判断，如果元素不在res中，则将其push进res中，最后将res返回即可获得去重的数组.</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let res = []</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (res.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">            res.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line">indexOf方法去重2</span><br><span class="line">利用indexOf检测元素在数组中第一次出现的位置是否和元素现在的位置相等，如果不等则说明该元素是重复元素.</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    return Array.prototype.filter.call(arr, function(item, index)&#123;</span><br><span class="line">        return arr.indexOf(item) === index;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">相邻元素去重</span><br><span class="line">这种方法首先调用了数组的排序方法sort()，然后根据排序后的结果进行遍历及相邻元素比对，如果相等则跳过改元素，直到遍历结束.</span><br><span class="line"></span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    arr = arr.sort()</span><br><span class="line">    let res = [arr[0]]</span><br><span class="line">    for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] !== arr[i-1]) &#123;</span><br><span class="line">            res.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line">利用对象属性去重</span><br><span class="line">创建空对象，遍历数组，将数组中的值设为对象的属性，并给该属性赋初始值1，每出现一次，对应的属性值增加1，这样，属性值对应的就是该元素出现的次数了.</span><br><span class="line"></span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let res = [],</span><br><span class="line">        obj = &#123;&#125;</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (!obj[arr[i]]) &#123;</span><br><span class="line">            res.push(arr[i])</span><br><span class="line">            obj[arr[i]] = 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj[arr[i]]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set与解构赋值去重</span><br><span class="line">ES6中新增了数据类型set，set的一个最大的特点就是数据不重复。Set函数可以接受一个数组（或类数组对象）作为参数来初始化，利用该特性也能做到给数组去重.</span><br><span class="line"></span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    return [...new Set(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.from与set去重</span><br><span class="line">Array.from方法可以将Set结构转换为数组结果，而我们知道set结果是不重复的数据集，因此能够达到去重的目的.</span><br><span class="line"></span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    if (!Array.isArray(arr)) &#123;</span><br><span class="line">        console.log(&#x27;type error!&#x27;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br><span class="line">总结</span><br><span class="line">数组去重是开发中经常会碰到的一个热点问题。我们可以根据不同的应用场景来选择不同的实现方式。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>46.异步请求放在created和munted中有啥区别？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</span><br><span class="line">mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</span><br><span class="line">如果放在created钩子函数中页面白屏时间会延长</span><br><span class="line">如果在mounted钩子函数中请求数据可能导致页面闪屏问题</span><br><span class="line">其实就是加载时机问题，放在created里会比mounted触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了</span><br></pre></td></tr></table></figure>

<p>47.promise的then什么场景？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是异步转化为串行执行的基本实现方式。</span><br><span class="line">promise的then中默认返回一个promise实例</span><br><span class="line">当then中没有return时返回的是undefined</span><br><span class="line">当then中return的对象或者基本类型等非new Promise实例时，对下一个进程then是同时执行的</span><br><span class="line">当then中return的是一个new Promise或者Promise.resolve()等实例时，对下一个进程then时队列顺序执行的</span><br></pre></td></tr></table></figure>

<p>48.什么是cookie，什么是持久cookie？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie 是 Web 服务器发送到浏览器的数据字符串。 当浏览器在将来请求来自同一个域的对象时，该浏览器会将同一日期字符串发送回原始服务器。</span><br><span class="line">该数据以一个称为“Set-Cookie”的 HTTP 报头格式从 Web 服务器发出。 浏览器以称为“Cookie”的 HTTP 报头格式将 cookie 发送回服务器。</span><br><span class="line">如果 cookie 不包含到期日期，则可视为会话 cookie。 会话 cookie 存储在内存中，决不会写入磁盘。 当浏览器关闭时，cookie 将从此永久丢失。</span><br><span class="line">如果 cookie 包含到期日期，则可视为持久性 cookie。 在指定的到期日期，cookie 将从磁盘中删除。</span><br><span class="line">cookie 可以包含多个不同的字段，并用分号隔开。 定义如下：</span><br><span class="line">到期：expires=&quot;Wdy, DD−Mon−YYYY HH:MM:SS GMT&quot; 确定 cookie 的删除日期。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>49.es7新增技术点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.数组中查找元素</span><br><span class="line">Array.prototype.includes()方法</span><br><span class="line">语法：array.includes(value,index),其中value为查找的值，index表示从此下标开始查找</span><br><span class="line">2.求幂运算</span><br><span class="line">求幂运算符（**）</span><br><span class="line">3**2------------------9</span><br></pre></td></tr></table></figure>

<p>50.ajax发送请求之后，中间想停止如何停止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个是$.ajax的timeout</span><br><span class="line">另一个就是XMLHttpRequest对象的abort()方法。</span><br></pre></td></tr></table></figure>

<p>51.axios发送请求之后，中间想停止如何停止</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中</span><br><span class="line">可以使用 CancelToken.source 工厂方法创建 cancel token</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">let axiosSource = axios.CancelToken.source()</span><br><span class="line">// 发送请求</span><br><span class="line">axios.get(url, &#123; cancelToken: axiosSource.token &#125;)</span><br><span class="line">axios.post(url, params, &#123; cancelToken: axiosSource.token &#125;)</span><br><span class="line">// 取消所有使用axiosSource.token的请求，这些请求Promise会走reject，即可以catch到错误。</span><br><span class="line">axiosSource.cancel(&#x27;取消请求&#x27;)</span><br></pre></td></tr></table></figure>

<p>52.vue设计模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvvm</span><br></pre></td></tr></table></figure>

<p>53.vue数据跟新之后，视图没有更新，怎样解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用方法: Vue.set( target , key , value)</span><br><span class="line">target: 要更改的数据源（可以是一个对象或者数组）</span><br><span class="line">key 要更改的具体数据 （索引）</span><br><span class="line">value 重新赋的值v</span><br></pre></td></tr></table></figure>

<p>渐进增强和优雅降级的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2.1 渐进增强</span><br><span class="line">渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</span><br><span class="line"></span><br><span class="line">2.2 优雅降级</span><br><span class="line">优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后再针对低版本浏览器进行兼容。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</span><br><span class="line">渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。而在现在前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。</span><br><span class="line"></span><br><span class="line">优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。而在现在前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。</span><br></pre></td></tr></table></figure>





        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/07/18/vue/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/07/18/vue/";
            const title         = "「vue」";
            const excerpt       = `vue1.v-show和v-if区别
123456v-show通过css display控制显示和隐藏，v-if组件真正的渲染和销毁，而不是显示和隐藏，频繁切换状态使用v-show 否则v-ifv-if 常用于一次性改变，如根据权限决...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/Vue/" rel="tag">Vue</a>
                </div>
                <div class="pull-date">
                <span>最后编辑：2022-07-18</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" vue3" href="/2022/07/14/VUE3/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" vue补充" href="/2022/07/18/vue补充/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center"></p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vue"><span class="toc-text">vue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-html%E3%80%81css"><span class="toc-text">3.html、css</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-html5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86HTML5%E6%96%B0%E6%A0%87%E7%AD%BE%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">1.html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%9F%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.行内元素和块级元素的区别？什么是重绘和回流？两者区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CSS-%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F"><span class="toc-text">3.CSS 选择符有哪些？优先级算法如何计算？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-CSS3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">4.CSS3有哪些新特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%A7%A3%E9%87%8A%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%AE%BD%E9%AB%98%E5%80%BC%E5%BE%97%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%BE%B9%E7%95%8C%E5%A1%8C%E9%99%B7%EF%BC%8C%E8%B4%9F%E5%80%BC%E4%BD%9C%E7%94%A8%EF%BC%8Cbox-sizing%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-text">5.解释盒模型宽高值得计算方式，边界塌陷，负值作用，box-sizing概念？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%AE%80%E8%BF%B0flex%E5%B8%83%E5%B1%80"><span class="toc-text">6.简述flex布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-css-%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9Fposition%E5%AE%9A%E4%BD%8D%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">7.css 隐藏元素有哪几种方法？position定位有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-BFC%EF%BC%88Block-Formatting-Context%EF%BC%89-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-text">8.BFC（Block Formatting Context） 是什么？应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%A7%A3%E9%87%8A%E4%B8%8B%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%83%E7%9A%84%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98%EF%BC%9F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%884%E7%A7%8D%EF%BC%89"><span class="toc-text">9.解释下浮动和它的遗留问题？清除浮动的方法（4种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%93%AA%E4%BA%9B%E5%A4%96%E8%BE%B9%E8%B7%9D%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F%E9%98%B2%E6%AD%A2%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">10.哪些外边距不重叠的情况？防止外边距重叠的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">11.如何让一个盒子水平垂直居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%B7%A6%E5%8F%B3%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E5%9C%A3%E6%9D%AF%E3%80%81%E5%8F%8C%E9%A3%9E%E7%BF%BC%E3%80%81%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E2%80%A6%EF%BC%89"><span class="toc-text">12.左右固定中间自适应 三栏布局（圣杯、双飞翼、弹性盒子…）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%9D%99%E6%80%81%E5%B8%83%E5%B1%80%E3%80%81%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E3%80%81%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E3%80%81%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%EF%BC%88rem%E3%80%81em%EF%BC%89"><span class="toc-text">13.静态布局、自适应布局、流式布局、响应式布局、弹性布局（rem、em）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B8%83%E5%B1%80%EF%BC%88Static-Layout%EF%BC%89"><span class="toc-text">静态布局（Static Layout）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-less%E3%80%81sass%E3%80%81-stylus%E5%88%86%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">14.less、sass、 stylus分别都有哪些优缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%9C%A8IE%EF%BC%88IE6%EF%BC%89%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">15.说一下在IE（IE6）中常见的几个兼容性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E6%B8%85%E7%A9%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">16.清空数组的方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-js"><span class="toc-text">4.js</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%A0%E5%81%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%B5%81%E8%A7%88%E5%99%A8%E6%B5%8B%E8%AF%95%E8%BF%87%EF%BC%9F%E8%BF%99%E4%BA%9B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%A0%E7%AE%80%E8%BF%B0%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.你简述盒模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-CSS3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">3.CSS3的新特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-CSS%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">4.CSS选择器及其优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%AF%B4%E8%AF%B4BFC"><span class="toc-text">5.说说BFC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E8%AF%B4%E8%AF%B4%E5%AE%9A%E4%BD%8D%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">6.说说定位相关的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%B0%88%E8%B0%88flex%E5%B8%83%E5%B1%80"><span class="toc-text">7.谈谈flex布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E4%BD%A0%E6%80%8E%E4%B9%88%E6%B8%85%E6%A5%9A%E6%B5%AE%E5%8A%A8"><span class="toc-text">8.你怎么清楚浮动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E4%B8%A4%E8%BE%B9%E5%AE%BD%E5%BA%A6%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80-%E9%BB%98%E5%86%99%E9%A2%98-%E6%89%8B%E5%86%99%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-text">9.两边宽度固定中间自适应的三栏布局(默写题,手写笔试题)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="toc-text">10.浏览器渲染机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.重绘和回流的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">12.JS数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-JS%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">13.JS判断数据类型的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-text">14.null和undefined区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">15.JS作用域的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16-call-apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%B5%81%E8%A7%88%E5%99%A8%E6%B5%8B"><span class="toc-text">16.call,apply和bind区别的页面在哪些流览器测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">17.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18-%E8%B0%88%E8%B0%88%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">18.谈谈防抖和节流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-%E8%B0%88%E8%B0%88cookie-sessionStorage%E5%92%8ClocalStorage"><span class="toc-text">19.谈谈cookie,sessionStorage和localStorage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-0-1-0-2-0-3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">20.0.1+0.2!&#x3D;0.3怎么处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA8%E4%B8%AA"><span class="toc-text">21.数组的常用方法(至少说出8个)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22-new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%90%97"><span class="toc-text">22.new一个对象的过程中发生了什么吗?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24-get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-text">24.get和post区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25-JSONP%E5%8E%9F%E7%90%86"><span class="toc-text">25.JSONP原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26-%E7%BC%93%E5%AD%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">26.缓存的理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27-XSS%E5%92%8CCSRF%E5%8C%BA%E5%88%AB"><span class="toc-text">27.XSS和CSRF区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28-HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">28.HTTP与HTTPS的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">29.HTTP状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30-%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E3%80%81%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6"><span class="toc-text">30.事件捕获、事件冒泡、阻止事件冒泡、阻止默认事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31-Js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="toc-text">31.Js事件循环机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-text">32.面向对象、原型、原型链、继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">33.什么是闭包，使用场景及优缺点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34-this%E6%8C%87%E5%90%91"><span class="toc-text">34.this指向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">35.箭头函数和普通函数的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#36-%E4%BB%80%E4%B9%88%E6%98%AFpromise"><span class="toc-text">36.什么是promise?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#37-%E4%BB%80%E4%B9%88%E6%98%AFajax%EF%BC%9F"><span class="toc-text">37.什么是ajax？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">5.兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81IE8-%E4%B8%8B%E9%9D%A2%E7%9A%84-png-%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%EF%BC%9F"><span class="toc-text">1、IE8 下面的 png 图片无法正常显示？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81rgba-%E4%B8%8D%E6%94%AF%E6%8C%81-IE8%EF%BC%9F"><span class="toc-text">2、rgba 不支持 IE8？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Css3-%E7%9A%84%E6%96%B0%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-text">3、Css3 的新属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81document-form-item-%E9%97%AE%E9%A2%98"><span class="toc-text">4、document.form.item 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E9%9B%86%E5%90%88%E7%B1%BB%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98"><span class="toc-text">5、集合类对象问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81window-event-event"><span class="toc-text">6、window.event || event</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81HTML-%E5%AF%B9%E8%B1%A1%E7%9A%84-id-%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">7、HTML 对象的 id 作为对象名的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E7%94%A8-idName-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%96%E5%BE%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">8、用 idName 字符串取得对象的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%8F%98%E9%87%8F%E5%90%8D%E4%B8%8E%E6%9F%90-HTML-%E5%AF%B9%E8%B1%A1-id-%E7%9B%B8%E5%90%8C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">9、变量名与某 HTML 对象 id 相同的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81event-x-%E4%B8%8E-event-y-%E9%97%AE%E9%A2%98"><span class="toc-text">10、event.x 与 event.y 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81-%E5%8F%96%E5%BE%97%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">11、 取得元素的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81const-%E9%97%AE%E9%A2%98"><span class="toc-text">12、const 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81body-%E5%AF%B9%E8%B1%A1"><span class="toc-text">13、body 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81url-encoding"><span class="toc-text">14、url encoding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81nodeName-%E5%92%8C-tagName-%E9%97%AE%E9%A2%98"><span class="toc-text">15、nodeName 和 tagName 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-text">16.元素属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%B0%83%E7%94%A8%E5%AD%90%E6%A1%86%E6%9E%B6%E6%88%96%E8%80%85%E5%85%B6%E5%AE%83%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">17.调用子框架或者其它框架中的元素的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%AF%B9%E8%B1%A1%E5%AE%BD%E9%AB%98%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-text">18.对象宽高赋值问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-innerText%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">19.innerText的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-event-srcElement%E5%92%8Cevent-toElement%E9%97%AE%E9%A2%98"><span class="toc-text">20.event.srcElement和event.toElement问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E7%A6%81%E6%AD%A2%E9%80%89%E5%8F%96%E7%BD%91%E9%A1%B5%E5%86%85%E5%AE%B9"><span class="toc-text">21.禁止选取网页内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%8D%95%E8%8E%B7%E4%BA%8B%E4%BB%B6"><span class="toc-text">22.捕获事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">移动端常见的兼容性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-html5%E8%B0%83%E7%94%A8%E5%AE%89%E5%8D%93%E6%88%96%E8%80%85ios%E7%9A%84%E6%8B%A8%E5%8F%B7%E5%8A%9F%E8%83%BD"><span class="toc-text">1.html5调用安卓或者ios的拨号功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%8A%E4%B8%8B%E6%8B%89%E5%8A%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%97%B6%E5%8D%A1%E9%A1%BF%E3%80%81%E6%85%A2"><span class="toc-text">2.上下拉动滚动条时卡顿、慢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%86%E8%A7%92bug"><span class="toc-text">3.圆角bug</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-ios-%E8%AE%BE%E7%BD%AEinput-%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F%E4%BC%9A%E8%A2%AB%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E8%A6%86%E7%9B%96"><span class="toc-text">4.ios 设置input 按钮样式会被默认样式覆盖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-IOS%E9%94%AE%E7%9B%98%E5%AD%97%E6%AF%8D%E8%BE%93%E5%85%A5%EF%BC%8C%E9%BB%98%E8%AE%A4%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99"><span class="toc-text">5.IOS键盘字母输入，默认首字母大写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-h5%E5%BA%95%E9%83%A8%E8%BE%93%E5%85%A5%E6%A1%86%E8%A2%AB%E9%94%AE%E7%9B%98%E9%81%AE%E6%8C%A1%E9%97%AE%E9%A2%98"><span class="toc-text">6.h5底部输入框被键盘遮挡问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-IOS%E7%A7%BB%E5%8A%A8%E7%AB%AFclick%E4%BA%8B%E4%BB%B6300ms%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%93%8D%E5%BA%94"><span class="toc-text">7.IOS移动端click事件300ms的延迟响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E5%9C%A8ios%E5%92%8Candriod%E4%B8%AD-audio%E5%85%83%E7%B4%A0%E5%92%8Cvideo%E5%85%83%E7%B4%A0%E5%9C%A8%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE"><span class="toc-text">8.在ios和andriod中,audio元素和video元素在无法自动播放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-CSS%E5%8A%A8%E7%94%BB%E9%A1%B5%E9%9D%A2%E9%97%AA%E7%99%BD-%E5%8A%A8%E7%94%BB%E5%8D%A1%E9%A1%BF"><span class="toc-text">9.CSS动画页面闪白,动画卡顿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-fixed%E5%AE%9A%E4%BD%8D%E7%BC%BA%E9%99%B7"><span class="toc-text">10.fixed定位缺陷</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-webpack"><span class="toc-text">6.webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-Webpack-%E6%89%93%E5%8C%85%E6%97%B6%E9%97%B4"><span class="toc-text">1、如何减少 Webpack 打包时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91-Webpack-%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF"><span class="toc-text">2、如何减少 Webpack 打包后的文件体积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="toc-text">3、什么是模块化？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BA%E7%8E%B0%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F"><span class="toc-text">4、为什么出现模块化？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%9E%84%E5%BB%BA%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5、构建的作用及常见功能是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">6、你了解的构建工具有哪些，各自有什么优缺点？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bwebpack"><span class="toc-text">7、简单介绍一下webpack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81Loader%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">8、Loader机制的作用是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81css-loader%E4%B8%8Estyle-loader%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">9、css-loader与style-loader的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E9%85%8D%E7%BD%AE-Loader-%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-text">10、配置 Loader 时需要注意的地方？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81Plugin%EF%BC%88%E6%8F%92%E4%BB%B6%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">11、Plugin（插件）的作用是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81ExtractTextPlugin%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">12、ExtractTextPlugin插件的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81DevServer%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-text">13、DevServer开发工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88"><span class="toc-text">14、实时预览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2%EF%BC%9F"><span class="toc-text">15、什么是模块热替换？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSource-Map-%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8"><span class="toc-text">16、什么是Source Map 及其使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81Webpack%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">17、Webpack的几个核心概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81Webpack%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">18、Webpack简单工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19-%E4%BB%80%E4%B9%88%E6%98%AFloader-%E4%BB%80%E4%B9%88%E6%98%AFPlugin-loader%E5%92%8Cplugin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">19.什么是loader ? 什么是Plugin ? loader和plugin有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20-webpack%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8F%92%E4%BB%B6%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">20.webpack中都有哪些插件，这些插件有什么作用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD"><span class="toc-text">21.如何利用webpack优化前端性能?</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-vue3-0"><span class="toc-text">7.vue3.0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Vue3-0%E5%92%8CVue2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.Vue3.0和Vue2.0的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Vue3-0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">2.Vue3.0都有哪些重要新特性？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Vue3-0-%E5%AF%B9%E6%AF%94Vue2-0%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">3.Vue3.0 对比Vue2.0的优势在哪？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Vue3-0%E5%92%8CReact-16-X%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%E5%92%8C%E7%9B%B8%E4%BC%BC%E5%A4%84%EF%BC%9F"><span class="toc-text">4.Vue3.0和React 16.X都有哪些区别和相似处？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Vue3-0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">5.Vue3.0是如何实现代码逻辑复用的？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E3%80%81%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-text">8.移动端、小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D"><span class="toc-text">1. 移动端兼容适配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-flexible%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%ADdpr"><span class="toc-text">2.flexible如何实现自动判断dpr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A5iPhone6%E4%B8%BA%E6%A0%87%E5%87%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%A8%BF%E7%9A%84%E5%B0%BA%E5%AF%B8%E6%98%AF%E4%BB%A5750px%E5%AE%BD%E5%BA%A6%E6%9D%A5%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">3.为什么以iPhone6为标准的设计稿的尺寸是以750px宽度来设计的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%BD%A2%E5%B1%8Fiphone-X"><span class="toc-text">4.如何处理异形屏iphone X</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96"><span class="toc-text">5.移动端首屏优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-PWA%E5%85%A8%E7%A7%B0Progressive-Web-App%EF%BC%8C%E5%8D%B3%E6%B8%90%E8%BF%9B%E5%BC%8FWEB%E5%BA%94%E7%94%A8"><span class="toc-text">6.PWA全称Progressive Web App，即渐进式WEB应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%A6%BB%E7%BA%BF%E5%8C%85%E6%96%B9%E6%A1%88"><span class="toc-text">7.离线包方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%87%AA%E9%80%82%E5%BA%94%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8. 自适应和响应式布局的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">9.简单描述下微信小程序的相关文件类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="toc-text">10.你是怎么封装微信小程序的数据请求的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">11.小程序有哪些参数传值的方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E7%AE%80%E8%BF%B0%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">12.简述微信小程序原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C-vue-%E5%93%AA%E9%87%8C%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F"><span class="toc-text">13.小程序的双向绑定和 vue 哪里不一样？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-webview-%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%80%8E%E4%B9%88%E8%B7%B3%E5%9B%9E%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%EF%BC%9F"><span class="toc-text">14.webview 中的页面怎么跳回小程序中？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%94%A8%E6%88%B7%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9F"><span class="toc-text">15.小程序关联微信公众号如何确定用户的唯一性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-text">16.小程序如何实现下拉刷新？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E6%8E%A5%E5%8F%A3%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">17.小程序调用后台接口遇到哪些问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84-wxss-%E5%92%8C-css-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-text">18.小程序的 wxss 和 css 有哪些不一样的地方？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E5%88%86%E6%9E%90%E4%B8%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="toc-text">19.分析下微信小程序的优劣势</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-es6"><span class="toc-text">9.es6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1、var、let、const之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2、使用箭头函数应注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ES6%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">3、ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%8B-Set%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4、介绍下 Set、Map的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81ECMAScript-6-%E6%80%8E%E4%B9%88%E5%86%99-class-%EF%BC%8C%E4%B8%BA%E4%BD%95%E4%BC%9A%E5%87%BA%E7%8E%B0-class%EF%BC%9F"><span class="toc-text">5、ECMAScript 6 怎么写 class ，为何会出现 class？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%82%A3%E4%B9%88-then-%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-text">6、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81setTimeout%E3%80%81Promise%E3%80%81Async-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81promise%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5catch%EF%BC%9F"><span class="toc-text">8、promise有几种状态，什么时候会进入catch？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%B8%8B%E9%9D%A2%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-text">9、下面的输出结果是多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E7%9A%84%E4%BA%A4%E6%8D%A2"><span class="toc-text">10、使用结构赋值，实现两个变量的值的交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%94%AE%E5%90%8D%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%87%B3%E5%B0%91%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AAsymbol%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89key"><span class="toc-text">11、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E4%B8%8B%E9%9D%A2Set%E7%BB%93%E6%9E%84%EF%BC%8C%E6%89%93%E5%8D%B0%E5%87%BA%E7%9A%84size%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-text">12、下面Set结构，打印出的size值是多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Promise-%E4%B8%ADreject-%E5%92%8C-catch-%E5%A4%84%E7%90%86%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">13、Promise 中reject 和 catch 处理上有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Set%E5%8E%BB%E9%87%8D"><span class="toc-text">14、如何使用Set去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%B0%86%E4%B8%8B%E9%9D%A2for%E5%BE%AA%E7%8E%AF%E6%94%B9%E6%88%90for-of%E5%BD%A2%E5%BC%8F"><span class="toc-text">15、将下面for循环改成for of形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E7%90%86%E8%A7%A3-async-await%E4%BB%A5%E5%8F%8A%E5%AF%B9Generator%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">16、理解 async&#x2F;await以及对Generator的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81forEach%E3%80%81for-in%E3%80%81for-of%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text">17、forEach、for in、for of三者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Bes6%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%A8%A1%E5%9D%97"><span class="toc-text">28、说一下es6的导入导出模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-React"><span class="toc-text">10.React</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%AE%9E%E6%88%98"><span class="toc-text">11.实战</span></a></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/">零散知识</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/HTTP/" style="font-size: 0.6em;">HTTP</a> <a href="/tags/Vue/" style="font-size: 0.73em;">Vue</a> <a href="/tags/css/" style="font-size: 0.6em;">css</a> <a href="/tags/egg/" style="font-size: 0.6em;">egg</a> <a href="/tags/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/" style="font-size: 0.6em;">flex弹性布局</a> <a href="/tags/hexo/" style="font-size: 0.6em;">hexo</a> <a href="/tags/koa/" style="font-size: 0.6em;">koa</a> <a href="/tags/node/" style="font-size: 0.6em;">node</a> <a href="/tags/npm/" style="font-size: 0.6em;">npm</a> <a href="/tags/react/" style="font-size: 0.6em;">react</a> <a href="/tags/vue/" style="font-size: 0.8em;">vue</a> <a href="/tags/wamp/" style="font-size: 0.6em;">wamp</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.67em;">前端</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 0.6em;">微信小程序</a> <a href="/tags/%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C/" style="font-size: 0.67em;">正则校验</a> <a href="/tags/%E9%9B%B6%E9%9B%B6%E6%95%A3%E6%95%A3/" style="font-size: 0.6em;">零零散散</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/07/18/vue%E8%A1%A5%E5%85%85/"><i class="fa  fa-book"></i> vue补充</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/07/18/vue/"><i class="fa  fa-book"></i> vue</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/07/14/VUE3/"><i class="fa  fa-book"></i> vue3</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/03/19/%E5%B0%9A%E7%A1%85%E8%B0%B7react%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="fa  fa-book"></i> 尚硅谷react课程笔记</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/01/%E9%9A%8F%E6%89%8B%E8%AE%B0/"><i class="fa  fa-book"></i> 随手记</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/CandyUnion"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@Candinya"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/Candinya"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 琼喵酱·部落 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by zengqm.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>