<!DOCTYPE html>
<html lang="zh-cn">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>2.vue和react的合集 | 橘知·部落</title>
  <meta name="author" content="zengqm" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Vue" />
  
  <meta name="description" content="架构概念mvc和mvvm的区别单页应用优缺点虚拟DOM和Diff算法框架带来的好处和弊端模块化、组件化、工程化谈谈对 MVC、MVP、MVVM 模式的理解vuev-model 作用v-model本质上不过是语法糖，可以用 v-model 指令在表单及元素上创建双向数据绑定。  它会根据控件类型自动选取正确的方法来更新元素 它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理 ???">
<meta property="og:type" content="article">
<meta property="og:title" content="2.vue和react的合集">
<meta property="og:url" content="http://example.com/2022/07/18/2.vue%E5%92%8Creact%E7%9A%84%E5%90%88%E9%9B%86/index.html">
<meta property="og:site_name" content="橘知·部落">
<meta property="og:description" content="架构概念mvc和mvvm的区别单页应用优缺点虚拟DOM和Diff算法框架带来的好处和弊端模块化、组件化、工程化谈谈对 MVC、MVP、MVVM 模式的理解vuev-model 作用v-model本质上不过是语法糖，可以用 v-model 指令在表单及元素上创建双向数据绑定。  它会根据控件类型自动选取正确的方法来更新元素 它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理 ???">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-18T14:42:59.658Z">
<meta property="article:modified_time" content="2022-09-06T16:34:10.255Z">
<meta property="article:author" content="zengqm">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">橘知·部落</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>橘知·部落</h2> <br />
                        <span>活在自己的热爱里</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/18/2.vue%E5%92%8Creact%E7%9A%84%E5%90%88%E9%9B%86/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">2.vue和react的合集</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2022-07-18T14:42:59.658Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2022-07-18</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">zengqm</span>
                </li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~24.29K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1662482050255"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">架构概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mvc%E5%92%8Cmvvm%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">mvc和mvvm的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">单页应用优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%92%8CDiff%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">虚拟DOM和Diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.4.</span> <span class="toc-text">框架带来的好处和弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">模块化、组件化、工程化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-MVC%E3%80%81MVP%E3%80%81MVVM-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">谈谈对 MVC、MVP、MVVM 模式的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue"><span class="toc-number">2.</span> <span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model-%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">v-model 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">v-model实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-0-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">Vue2.0 双向绑定的缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E5%87%BD%E6%95%B0%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-vue-%E7%9A%84-data-%E8%BF%98%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">既然函数是引用类型，为什么 vue 的 data 还是可以用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VUE-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">VUE 中什么是组件，为什么要封装组件？组件中 data 为什么是一个函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%9B%91%E5%90%ACdata%E5%8F%98%E5%8C%96"><span class="toc-number">2.6.</span> <span class="toc-text">描述监听data变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD-nextTick-%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">vue 中 $nextTick 作用与原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.8.</span> <span class="toc-text">vue的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if-v-show%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">v-if v-show区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%88%97%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0-key"><span class="toc-number">2.10.</span> <span class="toc-text">Vue 列表为什么加 key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for%E4%B8%AD%E7%9A%84key%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">v-for中的key的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E7%94%A8vue%E5%81%9A%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA"><span class="toc-number">2.12.</span> <span class="toc-text">为什么选择用vue做页面展示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">2.13.</span> <span class="toc-text">双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6-Vue-%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8F%AF%E4%BB%A5%E7%B2%BE%E5%87%86%E6%8E%A2%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%85%B7%E4%BD%93dom%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM-diff-%E5%91%A2"><span class="toc-number">2.14.</span> <span class="toc-text">既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A-new-Vue-%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">2.15.</span> <span class="toc-text">简单聊聊 new Vue 以后发生的事情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">为什么做首屏优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">vue首屏白屏如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">vue单页面和传统的多页面区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#root%E3%80%81-refs%E3%80%81-parent%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">$root、$refs、$parent的使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%92%8Clocation-href%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.20.</span> <span class="toc-text">路由跳转和location.href的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scss%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8vue-cli%E4%B8%AD%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E6%98%AF%EF%BC%9F%E6%9C%89%E5%93%AA%E5%87%A0%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E4%B8%8Evue-delete%E5%8C%BA%E5%88%AB"><span class="toc-number">2.22.</span> <span class="toc-text">delete与vue.delete区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.23.</span> <span class="toc-text">computed和watch的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8vm-set-%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E5%93%8D%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%88%EF%BC%9F"><span class="toc-number">2.24.</span> <span class="toc-text">Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题？你能说说如下代码的实现原理么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">2.25.</span> <span class="toc-text">导航守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%E7%99%BB%E5%BD%95"><span class="toc-number">2.26.</span> <span class="toc-text">路由守卫进行判断登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.27.</span> <span class="toc-text">vue-router 实现懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E6%98%AF%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%ACHistoryRouter%E7%9A%84%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">2.28.</span> <span class="toc-text">js是如何监听HistoryRouter的变化的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashRouter-%E5%92%8C-HistoryRouter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.29.</span> <span class="toc-text">HashRouter 和 HistoryRouter的区别和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-router-%E5%8E%9F%E7%90%86-%E5%93%AA%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%8D%E4%BC%9A%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.30.</span> <span class="toc-text">Vue router 原理, 哪个模式不会请求服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.31.</span> <span class="toc-text">组件通信的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%EF%BC%8C-attrs%E5%92%8Clisteners-%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">2.32.</span> <span class="toc-text">vue组件间传值， attrs和listeners 了解过吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%BB%BA%E4%BC%A0%E5%80%BC%EF%BC%8C%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">2.33.</span> <span class="toc-text">组建传值，事件总线是怎么用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9C%A8mouted%E8%BF%98%E6%98%AFcreate%E9%87%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.34.</span> <span class="toc-text">vue生命周期中异步加载在mouted还是create里实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-keep-alive"><span class="toc-number">2.35.</span> <span class="toc-text">vue keep-alive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.36.</span> <span class="toc-text">谈谈对vue生命周期的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dom-diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">2.37.</span> <span class="toc-text">dom diff算法和虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9MVVM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.38.</span> <span class="toc-text">说说你对MVVM的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.39.</span> <span class="toc-text">谈谈你对组件的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-Vue-%E4%B8%AD%EF%BC%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%BA%E4%BD%95%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84-Prop"><span class="toc-number">2.40.</span> <span class="toc-text">在 Vue 中，子组件为何不可以修改父组件传递的 Prop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%AD-Object-defineProperty-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">2.41.</span> <span class="toc-text">Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C-vuex-%E6%98%AF%E5%90%A6%E5%86%B2%E7%AA%81-%E4%BC%9A"><span class="toc-number">2.42.</span> <span class="toc-text">双向绑定和 vuex 是否冲突  会</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.43.</span> <span class="toc-text">Vue 的父组件和子组件生命周期钩子执行顺序是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E5%9C%A8-v-for-%E6%97%B6%E7%BB%99%E6%AF%8F%E9%A1%B9%E5%85%83%E7%B4%A0%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E7%94%A8%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.44.</span> <span class="toc-text">vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%B8%B2%E6%9F%93%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%97%B6%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.45.</span> <span class="toc-text">vue 渲染大量数据时应该怎么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88-nextTick-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.46.</span> <span class="toc-text">谈一谈 nextTick 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">2.47.</span> <span class="toc-text">Vue 中的 computed 和 watch 的区别在哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E3%80%81v-show%E3%80%81v-html-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%9A%84%EF%BC%9F"><span class="toc-number">2.48.</span> <span class="toc-text">v-if、v-show、v-html 的原理是什么，它是如何封装的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">2.49.</span> <span class="toc-text">如何优化自己的代码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0readyonly%E4%B8%8Edisabled%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.50.</span> <span class="toc-text">简述readyonly与disabled的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue3"><span class="toc-number">3.</span> <span class="toc-text">vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">Vue3.0 实现数据双向绑定的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vuex"><span class="toc-number">4.</span> <span class="toc-text">vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">Vuex是什么，每个属性是干嘛的，如何使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">Vuex实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutation%E5%92%8Caction%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">mutation和action有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ElementUI"><span class="toc-number">5.</span> <span class="toc-text">ElementUI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9ElementUI-%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">修改ElementUI 样式的几种方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elementui-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">elementui 有什么用?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react"><span class="toc-number">6.</span> <span class="toc-text">react</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">6.1.</span> <span class="toc-text">react组件间的数据传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E5%92%8Creact"><span class="toc-number">7.</span> <span class="toc-text">vue和react</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">react和vue的区别</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><h1 id="架构概念"><a href="#架构概念" class="headerlink" title="架构概念"></a>架构概念</h1><h2 id="mvc和mvvm的区别"><a href="#mvc和mvvm的区别" class="headerlink" title="mvc和mvvm的区别"></a>mvc和mvvm的区别</h2><h2 id="单页应用优缺点"><a href="#单页应用优缺点" class="headerlink" title="单页应用优缺点"></a>单页应用优缺点</h2><h2 id="虚拟DOM和Diff算法"><a href="#虚拟DOM和Diff算法" class="headerlink" title="虚拟DOM和Diff算法"></a>虚拟DOM和Diff算法</h2><h2 id="框架带来的好处和弊端"><a href="#框架带来的好处和弊端" class="headerlink" title="框架带来的好处和弊端"></a>框架带来的好处和弊端</h2><h2 id="模块化、组件化、工程化"><a href="#模块化、组件化、工程化" class="headerlink" title="模块化、组件化、工程化"></a>模块化、组件化、工程化</h2><h2 id="谈谈对-MVC、MVP、MVVM-模式的理解"><a href="#谈谈对-MVC、MVP、MVVM-模式的理解" class="headerlink" title="谈谈对 MVC、MVP、MVVM 模式的理解"></a>谈谈对 MVC、MVP、MVVM 模式的理解</h2><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="v-model-作用"><a href="#v-model-作用" class="headerlink" title="v-model 作用"></a>v-model 作用</h2><p>v-model本质上不过是语法糖，可以用 v-model 指令在表单及元素上创建双向数据绑定。</p>
<ol>
<li>它会根据控件类型自动选取正确的方法来更新元素</li>
<li>它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理 ???</li>
<li>v-model会忽略所有表单元素的value、checked、selected特性的初始值,而总是将 Vue 实例的数据作为数据来源，因此我们应该通过 JavaScript 在组件的data选项中声明初始值</li>
</ol>
<p>扩展：<br>v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ol>
<li>text 和 textarea 元素使用value属性和input事件；</li>
<li>checkbox 和 radio 使用checked属性和change事件；</li>
<li>select 字段将value作为 prop 并将change作为事件。</li>
</ol>
<h2 id="v-model实现原理"><a href="#v-model实现原理" class="headerlink" title="v-model实现原理"></a>v-model实现原理</h2><p>v-model只不过是一个语法糖而已,真正的实现靠的还是</p>
<ol>
<li>v-bind:绑定响应式数据</li>
<li>触发oninput 事件并传递数据<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;sth&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;sth&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;sth = $event.target.value&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自html5开始,input每次输入都会触发oninput事件，所以输入时input的内容会绑定到sth中，于是sth的值就被改变--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event 指代当前触发的事件对象;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event.target 指代当前触发的事件对象的dom;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event.target.value 就是当前dom的value值;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在@input方法中，value =&gt; sth;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在:value中,sth =&gt; value;--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Vue2-0-双向绑定的缺陷？"><a href="#Vue2-0-双向绑定的缺陷？" class="headerlink" title="Vue2.0 双向绑定的缺陷？"></a>Vue2.0 双向绑定的缺陷？</h2>Vue2.0的数据响应是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty () 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应监听回调。</li>
<li>vue 实例创建后，无法检测到对象属性的新增或删除，只能追踪到数据是否被修改</li>
<li>不能监听数组的变化</li>
</ol>
<h2 id="既然函数是引用类型，为什么-vue-的-data-还是可以用函数"><a href="#既然函数是引用类型，为什么-vue-的-data-还是可以用函数" class="headerlink" title="既然函数是引用类型，为什么 vue 的 data 还是可以用函数"></a>既然函数是引用类型，为什么 vue 的 data 还是可以用函数</h2><p>data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。</p>
<h2 id="VUE-中什么是组件，为什么要封装组件？组件中-data-为什么是一个函数？"><a href="#VUE-中什么是组件，为什么要封装组件？组件中-data-为什么是一个函数？" class="headerlink" title="VUE 中什么是组件，为什么要封装组件？组件中 data 为什么是一个函数？"></a>VUE 中什么是组件，为什么要封装组件？组件中 data 为什么是一个函数？</h2><p>为什么要封装组件？<br>主要就是为了解耦，提高代码复用率。</p>
<p>什么是组件？<br>页面上可以复用的都称之为组件 它是 HTML、CSS、JS 的聚合体。<br>组件就相当于库，把一些能在项目里或者不同项目里可以复用的代码进行需求性的封装。</p>
<p>组件中的 data 为什么是一个函数？<br>让每个返回的实例都可以维护一份被返回对象的独立的拷贝。</p>
<h2 id="描述监听data变化"><a href="#描述监听data变化" class="headerlink" title="描述监听data变化"></a>描述监听data变化</h2><p>监听对象变化：vue2.0核心api是Object.defineProperty，vue3.0是启用proxy实现响应式<br>监听数组变化：重写数组的push.pop.shift.unshift.splice.sort.reverse方法</p>
<h2 id="vue-中-nextTick-作用与原理"><a href="#vue-中-nextTick-作用与原理" class="headerlink" title="vue 中 $nextTick 作用与原理"></a>vue 中 $nextTick 作用与原理</h2><p>作用：是为了可以获取更新后的DOM 。<br>由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 Vue.nextTick()，就是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p>
<p>原理：<br>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li>Promise</li>
<li>MutationObserver</li>
<li>setImmediate</li>
<li>如果以上都不行则采用setTimeout<br>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</li>
</ul>
<h2 id="vue的特性"><a href="#vue的特性" class="headerlink" title="vue的特性"></a>vue的特性</h2><p>表单操作<br>自定义指令<br>计算属性<br>过滤器<br>侦听器<br>生命周期</p>
<h2 id="v-if-v-show区别"><a href="#v-if-v-show区别" class="headerlink" title="v-if v-show区别"></a>v-if v-show区别</h2><p>相同：都能控制元素的显示和隐藏<br>不同：v-show是通过控制css中的display设置为none，控制隐藏<br>v-if是动态的向DOM树内添加或者删除DOM元素<br>而且v-if不停的销毁和创建比较消耗性能。</p>
<p>v-show<br>v-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。之后切换的时候，通过display: none;样式来显示隐藏元素。可以说只是改变css的样式，几乎不会影响什么性能。<br>v-if<br>在首次渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。</p>
<h2 id="Vue-列表为什么加-key"><a href="#Vue-列表为什么加-key" class="headerlink" title="Vue 列表为什么加 key"></a>Vue 列表为什么加 key</h2><p>vue中列表循环需加:key=”唯一标识” 唯一标识且最好是静态的，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM</p>
<h2 id="v-for中的key的理解？"><a href="#v-for中的key的理解？" class="headerlink" title="v-for中的key的理解？"></a>v-for中的key的理解？</h2><p>需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。主要是为了高效的更新虚拟DOM。</p>
<h2 id="为什么选择用vue做页面展示"><a href="#为什么选择用vue做页面展示" class="headerlink" title="为什么选择用vue做页面展示"></a>为什么选择用vue做页面展示</h2><ol>
<li><p>MVVM 框架：<br>Vue 正是使用了这种 MVVM 的框架形式，并且通过声明式渲染和响应式数据绑定的方式来帮助我们完全避免了对 DOM 的操作。</p>
</li>
<li><p>单页面应用程序<br>Vue 配合生态圈中的 Vue-Router 就可以非常方便的开发复杂的单页应用</p>
</li>
<li><p>轻量化与易学习<br>Vue 的生产版本只有 30.90KB 的大小，几乎不会对我们的网页加载速度产生影响。同时因为 Vue 只专注于视图层，单独的 Vue 就像一个库一样，所以使我们的学习成本变得非常低</p>
</li>
<li><p>渐进式与兼容性<br>Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。Vue 只做界面，而把其他的一切都交给了它的周边生态（axios（Vue 官方推荐）、Loadsh.js、Velocity.js 等）来做处理，这就要求 Vue 必须要对其他的框架拥有最大程度的兼容性</p>
</li>
<li><p>视图组件化<br>Vue 允许通过组件来去拼装一个页面，每个组件都是一个可复用的 Vue 实例，组件里面可以包含自己的数据，视图和代码逻辑。方便复用</p>
</li>
<li><p>虚拟 DOM（Virtual DOM）<br>Vue 之所以可以完全避免对 DOM 的操作，就是因为 Vue 采用了虚拟 DOM 的方式，不但避免了我们对 DOM 的复杂操作，并且大大的加快了我们应用的运行速度。</p>
</li>
<li><p>社区支持<br>得益于 Vue 的本土化身份（Vue 的作者为国人尤雨溪），再加上 Vue 本身的强大，所以涌现出了特别多的国内社区，这种情况在其他的框架身上是没有出现过的，这使得我们在学习或者使用 Vue 的时候，可以获得更多的帮助</p>
</li>
<li><p>未来的 Vue 走向<br>Vue 是由国人尤雨溪在 Google 工作的时候，为了方便自己的工作而开发出来的一个库，而在 Vue 被使用的过程中，突然发现越来越多的人喜欢上了它。所以尤雨溪就进入了一个边工作、边维护的状态，在这种情况下 Vue 依然迅速的发展。</p>
</li>
</ol>
<h2 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理"></a>双向数据绑定原理</h2><p>采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。</p>
<h2 id="既然-Vue-通过数据劫持可以精准探测数据在具体dom上的变化-为什么还需要虚拟-DOM-diff-呢"><a href="#既然-Vue-通过数据劫持可以精准探测数据在具体dom上的变化-为什么还需要虚拟-DOM-diff-呢" class="headerlink" title="既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?"></a>既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?</h2><p>前置知识: 依赖收集、虚拟 DOM、响应式系统</p>
<p>现代前端框架有两种方式侦测变化，一种是 pull ，一种是 push</p>
<ol>
<li><p>pull: 其代表为React，我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</p>
</li>
<li><p>push: Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一但数据发生变化,响应式系统就会立刻得知。因此Vue是一开始就知道是「在哪发生变化了」，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher<br><code>一但我们的绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化</code>,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。</p>
</li>
</ol>
<h2 id="简单聊聊-new-Vue-以后发生的事情"><a href="#简单聊聊-new-Vue-以后发生的事情" class="headerlink" title="简单聊聊 new Vue 以后发生的事情"></a>简单聊聊 new Vue 以后发生的事情</h2><p>new Vue会调用 Vue 原型链上的_init方法<code>对 Vue 实例进行初始化</code>；<br>首先是initLifecycle初始化生命周期，对 Vue 实例内部的一些属性（如 children、parent、isMounted）进行初始化；<br>initEvents，初始化当前实例上的一些自定义事件（Vue.$on）；<br>initRender，解析slots绑定在 Vue 实例上，绑定createElement方法在实例上；<br>完成对生命周期、自定义事件等一系列属性的初始化后，触发生命周期钩子beforeCreate；<br>initInjections，在初始化data和props之前完成<code>依赖注入</code>（类似于 React.Context）；<br>initState，完成对data和props的初始化，同时对属性完成数据劫持内部，启用监听者对数据进行监听（更改）；<br>initProvide，对依赖注入进行解析；<br>完成对数据（state 状态）的初始化后，触发生命周期钩子created；<br>进入挂载阶段，将 vue 模板语法通过vue-loader解析成虚拟 DOM 树，虚拟 DOM 树与数据完成双向绑定，触发生命周期钩子beforeMount；<br>将解析好的虚拟 DOM 树通过 vue 渲染成真实 DOM，触发生命周期钩子mounted；</p>
<h2 id="为什么做首屏优化？"><a href="#为什么做首屏优化？" class="headerlink" title="为什么做首屏优化？"></a>为什么做首屏优化？</h2><p>首屏时间的快与慢，直接影响到了用户对网站的认知度。所以首屏时间的长短对于用户的滞留时间的长短、用户转化率都尤为重要。</p>
<h2 id="vue首屏白屏如何解决？"><a href="#vue首屏白屏如何解决？" class="headerlink" title="vue首屏白屏如何解决？"></a>vue首屏白屏如何解决？</h2><ol>
<li>路由懒加载</li>
<li>vue-cli开启打包压缩 和后台配合 gzip访问</li>
<li>进行cdn加速</li>
<li>开启vue服务渲染模式</li>
<li>用webpack的externals属性把不需要打包的库文件分离出去，减少打包后文件的大小</li>
<li>在生产环境中删除掉不必要的console.log<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123; <span class="comment">//添加-删除console.log</span></span><br><span class="line">    <span class="attr">compress</span>: &#123;</span><br><span class="line">      <span class="attr">warnings</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">drop_debugger</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">drop_console</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sourceMap</span>: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br></pre></td></tr></table></figure></li>
<li>开启nginx的gzip ,在nginx.conf配置文件中配置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;  <span class="comment">//在 http中配置如下代码，</span></span><br><span class="line">   gzip on;</span><br><span class="line">   gzip_disable <span class="string">&quot;msie6&quot;</span>;</span><br><span class="line">   gzip_vary on;</span><br><span class="line">   gzip_proxied any;</span><br><span class="line">   gzip_comp_level <span class="number">8</span>; #压缩级别</span><br><span class="line">   gzip_buffers <span class="number">16</span> 8k;</span><br><span class="line">   #gzip_http_version <span class="number">1.1</span>;</span><br><span class="line">   gzip_min_length <span class="number">100</span>; #不压缩临界值</span><br><span class="line">   gzip_types text/plain application/javascript application/x-javascript text/css</span><br><span class="line">    application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>添加loading效果，给用户一种进度感受</li>
</ol>
<h2 id="vue单页面和传统的多页面区别？"><a href="#vue单页面和传统的多页面区别？" class="headerlink" title="vue单页面和传统的多页面区别？"></a>vue单页面和传统的多页面区别？</h2><p>单页面应用（SPA）<br>通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p>
<p>多页面（MPA）<br>指一个应用中有多个页面，页面跳转时是整页刷新</p>
<p>单页面的优点：<br>用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。</p>
<p>单页面缺点：<br>不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</p>
<h2 id="root、-refs、-parent的使用？"><a href="#root、-refs、-parent的使用？" class="headerlink" title="$root、$refs、$parent的使用？"></a>$root、$refs、$parent的使用？</h2><ol>
<li>$root<br>可以用来获取vue的根实例，比如在简单的项目中将公共数据放再vue根实例上(可以理解为一个全局 store ),因此可以代替vuex实现状态管理；</li>
<li>$refs<br>在子组件上使用ref特性后，this.属性可以直接访问该子组件。可以代替事件$emit 和 $on的作用。使用方式是通过ref特性为这个子组件赋予一个ID的引用，再通过 this.$refs.testId获取指定元素。注意：refs只会在组件渲染完成之后生效，并且他们不是响应式的。应该避免在模板和计算属性中访问refs。</li>
<li>$parent<br>$parent属性可以用来从一个子组件访问父组件的实例，可以替代将数据以 prop 的方式传入子组件的方式；当变更父级组件的数据的时候，容易造成调试和理解难度增加；</li>
</ol>
<h2 id="路由跳转和location-href的区别？"><a href="#路由跳转和location-href的区别？" class="headerlink" title="路由跳转和location.href的区别？"></a>路由跳转和location.href的区别？</h2><ol>
<li>使用location.href=’/url’来跳转，简单方便，但是刷新了页面；</li>
<li>使用路由方式跳转，无刷新页面，静态跳转</li>
</ol>
<h2 id="scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="headerlink" title="scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？"></a>scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h2><ol>
<li>css的预编译。</li>
<li>使用步骤：<br>先装css-loader、node-loader、sass-loader等加载器模块<br>在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss<br>在同一个文件，配置一个module属性<br>然后在组件的style标签加上lang属性 ，例如：lang=”scss”</li>
<li>特性:<br>可以用变量，例如（$变量名称=值）；<br>可以用混合器，例如（）<br>可以嵌套</li>
</ol>
<h2 id="delete与vue-delete区别"><a href="#delete与vue-delete区别" class="headerlink" title="delete与vue.delete区别?"></a>delete与vue.delete区别?</h2><ol>
<li>delte会删除数组的值，但是它依然会在内存中占位置</li>
<li>而vue.delete会删除数组在内存中的占位<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">delete</span> arr1[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">this</span>.$delete(arr2,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1)    <span class="comment">//【1, empty, 3】</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)    <span class="comment">//【1,2】</span></span><br></pre></td></tr></table></figure>
<h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2></li>
<li>computed<br>计算结果并返回，只有当被计算的属性发生改变时才会触发（即：计算属性的结果会被缓存，除非依赖的响应属性变化才会重新及孙）</li>
<li>watch<br>监听某一个值，当被监听的值发生变化时，执行相关操作。</li>
<li>与computed的区别是，watch更加适用于监听某一个值得变化，并做对应操作，比如请求后端接口等。而computed适用于计算已有的值并返回结果。 监听简单数据类型：</li>
</ol>
<h2 id="Vue为什么要用vm-set-解决对象新增属性不能响应的问题？你能说说如下代码的实现原理么？"><a href="#Vue为什么要用vm-set-解决对象新增属性不能响应的问题？你能说说如下代码的实现原理么？" class="headerlink" title="Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题？你能说说如下代码的实现原理么？"></a>Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题？你能说说如下代码的实现原理么？</h2><ol>
<li>Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题</li>
</ol>
<ul>
<li>Vue使用了Object.defineProperty实现双向数据绑定</li>
<li>在初始化实例时对属性执行 getter/setter 转化</li>
<li>属性必须在data对象上存在才能让Vue将它转换为响应式的（这也就造成了Vue无法检测到对象属性的添加或删除）<br>所以Vue提供了Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</li>
</ul>
<ol start="2">
<li>框架本身是如何实现的呢?<br>Vue 源码位置：vue/src/core/instance/index.js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: <span class="built_in">Array</span>&lt;any&gt; | <span class="built_in">Object</span>, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// target 为数组 </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式 </span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key 已经存在，直接修改属性值 </span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对属性进行响应式处理</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们阅读以上源码可知，vm.$set 的实现原理是：</li>
</ol>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，</li>
<li>最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理</li>
</ul>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>导航守卫主要用来通过跳转或取消的方式守卫导航。<br>简单的说，导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。</p>
<p>扩展：</p>
<ol>
<li>路由守卫的具体方法：<br>(1)全局前置守卫<br>你可以使用 router.beforeEach 注册一个全局前置守卫<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
当一个导航开始时，全局前置守卫按照注册顺序调用。守卫是异步链式调用的，导航在最后的一层当中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;第一个全局前置守卫&#x27;</span>)</span><br><span class="line">&#125;.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;第二个全局前置守卫&#x27;</span></span><br><span class="line">&#125;.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;导航终于开始了&#x27;</span>) <span class="comment">// 导航在最后一层中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
每个守卫方法接收三个参数（往后的守卫都大同小异）：</li>
<li>to: Route: 即将要进入的目标 路由对象</li>
<li>from: Route: 当前导航正要离开的路由</li>
<li>next: Function: 一定要调用该方法将控制权交给下一个守卫，执行效果依赖 next 方法的参数。<br>next(): 进入下一个守卫。如果全部守卫执行完了。则导航的状态就是 confirmed (确认的)。<br>next(false): 中断当前的导航（把小明腿打断了）。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器 后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。<br>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航（小明被打断腿并且送回家了）。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。<br>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递router.<br>onError() 注册过的回调。</li>
</ol>
<p>注意：永远不要使用两次next，这会产生一些误会。</p>
<ul>
<li>全局解析守卫<br>这和 router.beforeEach 类似，但他总是被放在最后一个执行。</li>
<li>全局后置钩子<br>导航已经确认了的，小明已经到了外婆家了，你打断他的腿他也是在外婆家了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 你并不能调用next</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>路由独享的守卫<br>在路由内写的守卫<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: Foo,</span><br><span class="line">      <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>组件内的守卫</li>
</ul>
<p>5.1 beforeRouteEnter<br>5.2 beforeRouteUpdate (2.2 新增)<br>5.3 beforeRouteLeave</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 组件还未渲染出来，不能获取组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`，一般用来数据获取。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导航全过程<br>导航被触发。<br>在准备离开的组件里调用 beforeRouteLeave 守卫。<br>调用全局的 beforeEach 守卫。<br>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。（如果你的组件是重用的）<br>在路由配置里调用 beforeEnter。<br>解析即将抵达的组件。<br>在即将抵达的组件里调用 beforeRouteEnter。<br>调用全局的 beforeResolve 守卫 (2.5+)。<br>导航被确认。<br>调用全局的 afterEach 钩子。<br>触发 DOM 更新。<br>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h2 id="路由守卫进行判断登录"><a href="#路由守卫进行判断登录" class="headerlink" title="路由守卫进行判断登录"></a>路由守卫进行判断登录</h2><p>在vue项目中，切换路由时肯定会碰到需要登录的路由，其原理就是在切换路径之前进行判断，你不可能进入页面再去判断有无登录重新定向到login，那样的话会导致页面已经渲染以及它的各种请求已经发出。</p>
<p>如需要登录的路由可在main.js中统一处理（全局前置守卫）<br>我们可以在入口文件man.js里面进行配置，使用router.beforeEach方法，不懂得可以打印to，from的参数就ok，requireAuth可以随意换名的，只要man.js里面跟配置路由的routes里面的字段保持一致：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">record</span> =&gt;</span> record.meta.requireAuth))&#123;  <span class="comment">// 判断该路由是否需要登录权限</span></span><br><span class="line">    <span class="keyword">if</span>(!sessionStorage.getItem(<span class="string">&#x27;token&#x27;</span>) &amp;&amp; !<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>))&#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;<span class="attr">redirect</span>: to.fullPath&#125;  <span class="comment">// 将跳转的路由path作为参数，登录成功后跳转到该路由</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">            <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: Home,</span><br><span class="line">            <span class="attr">meta</span>: &#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">              <span class="attr">requireAuth</span>: <span class="literal">true</span>,  <span class="comment">// 添加该字段，表示进入这个路由是需要登录的</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:Login</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/register&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;register&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:Register</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vue-router-实现懒加载"><a href="#vue-router-实现懒加载" class="headerlink" title="vue-router 实现懒加载"></a>vue-router 实现懒加载</h2><p>懒加载：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>实现：结合 Vue 的异步组件和 Webpack 的代码分割功能，可以实现路由组件的懒加载<br>首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="comment">/* 组件定义对象 */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>) <span class="comment">// 返回 Promise</span></span><br></pre></td></tr></table></figure>
<p>结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在路由配置中什么都不需要改变，只需要像往常一样使用Foo：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="js是如何监听HistoryRouter的变化的"><a href="#js是如何监听HistoryRouter的变化的" class="headerlink" title="js是如何监听HistoryRouter的变化的"></a>js是如何监听HistoryRouter的变化的</h2><h2 id="HashRouter-和-HistoryRouter的区别和原理"><a href="#HashRouter-和-HistoryRouter的区别和原理" class="headerlink" title="HashRouter 和 HistoryRouter的区别和原理"></a>HashRouter 和 HistoryRouter的区别和原理</h2><h2 id="Vue-router-原理-哪个模式不会请求服务器"><a href="#Vue-router-原理-哪个模式不会请求服务器" class="headerlink" title="Vue router 原理, 哪个模式不会请求服务器"></a>Vue router 原理, 哪个模式不会请求服务器</h2><h2 id="组件通信的方式"><a href="#组件通信的方式" class="headerlink" title="组件通信的方式"></a>组件通信的方式</h2><p>组件通信的方式的方式有以下8种方法：<br>父与子</p>
<ol>
<li>props和$emit<br>这是最最常用的父子组件通信方式，父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的</li>
<li>parent和children</li>
<li>ref 也可以访问组件实例；</li>
<li>v-model<br>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</li>
<li>boradcast和dispatch<br>vue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。 比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和on和emit的封装，但在一些基础组件中却很实用</li>
</ol>
<p>兄弟组件</p>
<ol>
<li>中央事件总线<br>上面方式都是处理的父子组件之间的数据传递，那如果两个组件不是父子关系呢?也就是兄弟组件如何通信?<br>这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.on监听触发的事件。</li>
</ol>
<p>跨级通信</p>
<ol>
<li>attrs和listeners<br>第一种方式处理父子组件之间的数据传输有一个问题：如果多层嵌套，父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢?<br>如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C;要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。从Vue 2.4开始，提供了listeners来解决这个问题，能够让组件A之间传递消息给组件C。</li>
<li>provide和inject<br>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</li>
</ol>
<p>多个组件</p>
<ol>
<li>vuex处理组件之间的数据交互<br>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的</li>
</ol>
<h2 id="vue组件间传值，-attrs和listeners-了解过吗？"><a href="#vue组件间传值，-attrs和listeners-了解过吗？" class="headerlink" title="vue组件间传值， attrs和listeners 了解过吗？"></a>vue组件间传值， attrs和listeners 了解过吗？</h2><p>attrs和listeners的作用：解决多层嵌套情况下，父组件A下面有子组件B，组件B下面有组件C，组件A传递数据给组件B的问题，这个方法是在Vue 2.4提出的。</p>
<p>listeners解决问题的过程：<br>C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性<br>通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props(除了B组件中props声明的)</p>
<h2 id="组建传值，事件总线是怎么用的"><a href="#组建传值，事件总线是怎么用的" class="headerlink" title="组建传值，事件总线是怎么用的"></a>组建传值，事件总线是怎么用的</h2><p>中央事件总线主要用来解决兄弟组件通信的问题。<br>实现方式：新建一个Vue事件bus对象，然后通过bus.on监听触发的事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;brother1&#x27;</span>,&#123;</span><br><span class="line"> <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">myMessage</span>:<span class="string">&#x27;Hello brother1&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt;</span></span><br><span class="line"><span class="string"> &lt;p&gt;this is brother1 compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;input type=&quot;text&quot; v-model=&quot;myMessage&quot; @input=&quot;passData(myMessage)&quot;&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string"> `</span>,</span><br><span class="line"> <span class="attr">methods</span>:&#123;</span><br><span class="line">     <span class="function"><span class="title">passData</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">         <span class="comment">//触发全局事件globalEvent</span></span><br><span class="line">         bus.$emit(<span class="string">&#x27;globalEvent&#x27;</span>,val)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">&#x27;brother2&#x27;</span>,&#123;</span><br><span class="line"> <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt;</span></span><br><span class="line"><span class="string"> &lt;p&gt;this is brother2 compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string"> `</span>,</span><br><span class="line"> <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">myMessage</span>:<span class="string">&#x27;Hello brother2&#x27;</span>,</span><br><span class="line">         <span class="attr">brothermessage</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//绑定全局事件globalEvent</span></span><br><span class="line">     bus.$on(<span class="string">&#x27;globalEvent&#x27;</span>,<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brothermessage=val;</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//中央事件总线</span></span><br><span class="line"><span class="keyword">var</span> bus=<span class="keyword">new</span> Vue();</span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"> <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt;</span></span><br><span class="line"><span class="string"> &lt;brother1&gt;&lt;/brother1&gt;</span></span><br><span class="line"><span class="string"> &lt;brother2&gt;&lt;/brother2&gt;</span></span><br><span class="line"><span class="string"> &lt;/div&gt;</span></span><br><span class="line"><span class="string"> `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vue生命周期中异步加载在mouted还是create里实现"><a href="#vue生命周期中异步加载在mouted还是create里实现" class="headerlink" title="vue生命周期中异步加载在mouted还是create里实现"></a>vue生命周期中异步加载在mouted还是create里实现</h2><p>最常用的是在 created 钩子函数中调用异步请求</p>
<p>解析：<br>一般来说，可以在，created，mounted中都可以发送数据请求，但是，大部分时候，会在created发送请求。<br>Created的使用场景：如果页面首次渲染的就来自后端数据。因为，此时data已经挂载到vue实例了。<br>在 created（如果希望首次选的数据来自于后端，就在此处发请求）（只发了异步请求，渲染是在后端响应之后才进行的）、beforeMount、mounted（在mounted中发请求会进行二次渲染） 这三个钩子函数中进行调用。<br>因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是最常用的是在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有两个优点：<br>第一点：能更快获取到服务端数据，减少页面 loading 时间；<br>第二点：放在 created 中有助于一致性，因为ssr 不支持 beforeMount 、mounted 钩子函数。</p>
<h2 id="vue-keep-alive"><a href="#vue-keep-alive" class="headerlink" title="vue keep-alive"></a>vue keep-alive</h2><p>keep-alive：keep-alive可以实现组件缓存，是Vue.js的一个内置组件。</p>
<ol>
<li>作用：<br>它能够把不活动的组件实例保存在内存中，而不是直接将其销毁<br>它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中</li>
<li>使用方式：<br>常用的两个属性include/exclude，允许组件有条件的进行缓存。<br>两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。<br>keep-alive的中还运用了LRU(Least Recently Used)算法。</li>
<li>原理：<br>Vue 的缓存机制并不是直接存储 DOM 结构，而是将 DOM 节点抽象成了一个个 VNode节点，所以，keep-alive的缓存也是基于VNode节点的而不是直接存储DOM结构。<br>其实就是将需要缓存的VNode节点保存在this.cache中／在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。</li>
</ol>
<p>所有组件都实现缓存：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/find&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实现指定组件缓存就需要用到include和exclude这两个属性了</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;home&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>include所绑定的Home组件就实现缓存了 其他的组件就没实现缓存  而Home对应的是Home组件中的name名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是home组件</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  exprot default &#123;</span><br><span class="line">    name: &#x27;home&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>而exclude属性与include的功能恰恰相反  exclude绑定的组件中name名不实现缓存，没绑定的实现缓存</p>
<p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p>
<h2 id="谈谈对vue生命周期的理解"><a href="#谈谈对vue生命周期的理解" class="headerlink" title="谈谈对vue生命周期的理解"></a>谈谈对vue生命周期的理解</h2><p>beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。<br>created在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。<br>beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。<br>mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。<br>beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。<br>updated发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。<br>beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。<br>destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p>
<h2 id="dom-diff算法和虚拟DOM"><a href="#dom-diff算法和虚拟DOM" class="headerlink" title="dom diff算法和虚拟DOM"></a>dom diff算法和虚拟DOM</h2><p>算法实现 1 步骤一：用JS对象模拟DOM树<br>2 步骤二：比较两棵虚拟DOM树的差异<br>3 步骤三：把差异应用到真正的DOM树上 </p>
<h2 id="说说你对MVVM的理解"><a href="#说说你对MVVM的理解" class="headerlink" title="说说你对MVVM的理解"></a>说说你对MVVM的理解</h2><p>用户操作view层，view数据变化会同步到Model，Model数据变化会立即反应到view中。<br>viewModel通过双向数据绑定把view层和Model层连接了起来</p>
<p>单向绑定的优点是可以带来单向数据流，这样的好处是流动方向可以跟踪，流动单一，<br>程序的调试会变得相对容易</p>
<h2 id="谈谈你对组件的理解"><a href="#谈谈你对组件的理解" class="headerlink" title="谈谈你对组件的理解"></a>谈谈你对组件的理解</h2><p>可组合，可复用，可维护，可测试</p>
<h2 id="在-Vue-中，子组件为何不可以修改父组件传递的-Prop"><a href="#在-Vue-中，子组件为何不可以修改父组件传递的-Prop" class="headerlink" title="在 Vue 中，子组件为何不可以修改父组件传递的 Prop"></a>在 Vue 中，子组件为何不可以修改父组件传递的 Prop</h2><p>为了保证数据的单向流动，防止从子组件意外改变父级组件的状态，<br>便于对数据进行追踪，避免数据混乱。</p>
<h2 id="Vue-的响应式原理中-Object-defineProperty-有什么缺陷？"><a href="#Vue-的响应式原理中-Object-defineProperty-有什么缺陷？" class="headerlink" title="Vue 的响应式原理中 Object.defineProperty 有什么缺陷？"></a>Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</h2><p>Object.defineProperty无法监控到数组下标的变化，<br>导致直接通过数组的下标给数组设置值，不能实时响应。</p>
<h2 id="双向绑定和-vuex-是否冲突-会"><a href="#双向绑定和-vuex-是否冲突-会" class="headerlink" title="双向绑定和 vuex 是否冲突  会"></a>双向绑定和 vuex 是否冲突  会</h2><p>在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误。<br>当需要在组件中使用vuex中的state时，有2种解决方案：<br>1、在input中绑定value(vuex中的state)，然后监听input的change或者input事件，<br>在事件回调中调用mutation修改state的值<br>2、使用带有setter的双向绑定计算属性</p>
<h2 id="Vue-的父组件和子组件生命周期钩子执行顺序是什么"><a href="#Vue-的父组件和子组件生命周期钩子执行顺序是什么" class="headerlink" title="Vue 的父组件和子组件生命周期钩子执行顺序是什么"></a>Vue 的父组件和子组件生命周期钩子执行顺序是什么</h2><ol>
<li>加载渲染过程父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li>
<li>子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</li>
<li>父组件更新过程父beforeUpdate-&gt;父updated</li>
<li>销毁过程父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</li>
</ol>
<h2 id="vue-在-v-for-时给每项元素绑定事件需要用事件代理吗？为什么？"><a href="#vue-在-v-for-时给每项元素绑定事件需要用事件代理吗？为什么？" class="headerlink" title="vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？"></a>vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</h2><p>不需要，直接监听就行，如果循环的是组件，而且组件没有支持该事件，需要加native修饰符(一般UI库会对这个做支持，兼听不到事件的时候才需要加)</p>
<p>vue本身不做事件代理（react将所有事件都委托到document上，然后进行派发）</p>
<ol>
<li>普通html元素和在组件上挂了.native修饰符的事件。最终EventTarget.addEventListener()挂载事件</li>
<li>组件上的，vue组件实例上的自定义事件（不包括.native）会调用原型上的$on,$emit（包括一些其他api $off,$once等等）</li>
<li>vue自身没有做事件代理，如果需要，则直接代理到父节点<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> @<span class="attr">click</span>=<span class="string">&quot;meths&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,key) in 10&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span> <span class="attr">:data-index</span>=<span class="string">&quot;key&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">meths</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.target.nodeName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">        <span class="built_in">console</span>.log(e.target.dataset)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>事件代理作用主要是 2 个<br>将事件处理程序代理到父节点，减少内存占用率<br>动态生成子节点时能自动绑定事件处理程序到父节点</li>
</ol>
<h2 id="vue-渲染大量数据时应该怎么优化？"><a href="#vue-渲染大量数据时应该怎么优化？" class="headerlink" title="vue 渲染大量数据时应该怎么优化？"></a>vue 渲染大量数据时应该怎么优化？</h2><ol>
<li>增加加载动画提升用户体验</li>
<li>异步渲染组件</li>
<li>使用分页</li>
</ol>
<h2 id="谈一谈-nextTick-的原理"><a href="#谈一谈-nextTick-的原理" class="headerlink" title="谈一谈 nextTick 的原理"></a>谈一谈 nextTick 的原理</h2><p>为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback)。这样回调函数在 DOM 更新完成后就会调用。</p>
<h2 id="Vue-中的-computed-和-watch-的区别在哪里"><a href="#Vue-中的-computed-和-watch-的区别在哪里" class="headerlink" title="Vue 中的 computed 和 watch 的区别在哪里"></a>Vue 中的 computed 和 watch 的区别在哪里</h2><p>computed：计算属性 一个数据受多个数据影响<br>watch：监听数据的变化 一个数据影响多个数据</p>
<h2 id="v-if、v-show、v-html-的原理是什么，它是如何封装的？"><a href="#v-if、v-show、v-html-的原理是什么，它是如何封装的？" class="headerlink" title="v-if、v-show、v-html 的原理是什么，它是如何封装的？"></a>v-if、v-show、v-html 的原理是什么，它是如何封装的？</h2><ol>
<li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li>
<li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； </li>
<li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值</li>
</ol>
<h2 id="如何优化自己的代码？"><a href="#如何优化自己的代码？" class="headerlink" title="如何优化自己的代码？"></a>如何优化自己的代码？</h2><p>代码重用<br>避免全局变量（命名空间，封闭空间，模块化mvc..）<br>拆分函数避免函数过于臃肿<br>注释</p>
<h2 id="简述readyonly与disabled的区别"><a href="#简述readyonly与disabled的区别" class="headerlink" title="简述readyonly与disabled的区别"></a>简述readyonly与disabled的区别</h2><p>Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效<br>在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去</p>
<h1 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h1><h2 id="Vue3-0-实现数据双向绑定的方法"><a href="#Vue3-0-实现数据双向绑定的方法" class="headerlink" title="Vue3.0 实现数据双向绑定的方法"></a>Vue3.0 实现数据双向绑定的方法</h2><p>vue3.0 实现数据双向绑定是通过Proxy<br>Proxy是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<br>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p>
<p>扩展：<br>使用proxy实现，双向数据绑定，相比2.0的Object.defineProperty ()优势：</p>
<ol>
<li>可以劫持整个对象，并返回一个新对象</li>
<li>有13种劫持操作 ？？</li>
</ol>
<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="Vuex是什么，每个属性是干嘛的，如何使用"><a href="#Vuex是什么，每个属性是干嘛的，如何使用" class="headerlink" title="Vuex是什么，每个属性是干嘛的，如何使用"></a>Vuex是什么，每个属性是干嘛的，如何使用</h2><ol>
<li><p>Vuex是专门为Vuejs应用程序设计的状态管理工具。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p>
</li>
<li><p>Vuex的属性包含以下6个：<br>1）state<br>state是存储的单一状态，是存储的基本数据。<br>2）Getters<br>getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。<br>3）Mutations<br>mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）<br>4）Actions<br>actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）<br>5）Module<br>Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。<br>6）辅助函数<br>Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store。</p>
</li>
<li><p>vuex的工作流程就是：<br>（1）通过dispatch去提交一个actions，<br>（2）actions接收到这个事件之后，在actions中可以执行一些异步|同步操作，根据不同的情况去分发给不同的mutations，<br>（3）actions通过commit去触发mutations，<br>（4）mutations去更新state数据，state更新之后，就会通知vue进行渲染。<br>（5）也可以使用$store.commit方法去触发mutations，更改state存储的状态。</p>
</li>
<li><p>Vuex的使用方法？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">Vue.use(Vuex); <span class="comment">// 1. vue的插件机制，安装vuex</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> Vuex.Store(&#123; <span class="comment">// 2.实例化store，调用install方法</span></span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    modules,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    plugins</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="comment">// 3.注入store, 挂载vue实例</span></span><br><span class="line">    store,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span>=&gt;</span>h(app)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Vuex实现原理"><a href="#Vuex实现原理" class="headerlink" title="Vuex实现原理"></a>Vuex实现原理</h2><p>具体见 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/96/c885e81dc46b4dcfa579d76d0aa94c96">https://www.nowcoder.com/tutorial/96/c885e81dc46b4dcfa579d76d0aa94c96</a><br>通过以下三个方面来阐述vuex的实现原理：</p>
<ol>
<li>store是怎么注册的?</li>
<li>mutation，commit 是怎么实现的?</li>
<li>辅助函数是怎么实现的?</li>
</ol>
<h2 id="mutation和action有什么区别？"><a href="#mutation和action有什么区别？" class="headerlink" title="mutation和action有什么区别？"></a>mutation和action有什么区别？</h2><p>action中处理异步，mutation不可以<br>mutation做原子操作，action可以整合多个mutation<br>action 提交的是 mutation，而不是直接变更状态。</p>
<h1 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h1><h2 id="修改ElementUI-样式的几种方式"><a href="#修改ElementUI-样式的几种方式" class="headerlink" title="修改ElementUI 样式的几种方式?"></a>修改ElementUI 样式的几种方式?</h2><p>修改ElementUI 样式的方式有四种：</p>
<ol>
<li><p>新建全局样式表<br>新建 global.css 文件，并在 main.js 中引入。 global.css 文件一般都放在 src-&gt;assets 静态资源文件夹下的 style 文件夹下，在 main.js 的引用写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./assets/style/global.css&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 global.css 文件中写的样式，无论在哪一个 vue 单页面都会覆盖 ElementUI 默认的样式。</p>
</li>
<li><p>在当前-vue-单页面中添加一个新的style标签<br>在当前的vue单页面的style标签后，添加一对新的style标签，新的style标签中不要添加scoped属性。在有写scoped的style标签中书写的样式不会覆盖 ElementUI 默认的样式。</p>
</li>
<li><p>使用/deep/深度修改标签样式(vue样式穿透)<br>找到需要修改的 ElementUI 标签的类名，然后在类名前加上/deep/，可以强制修改默认样式。这种方式可以直接用到有scoped属性的 style 标签中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果vue的style使用的是css，那么则 */</span></span><br><span class="line"><span class="selector-class">.a</span> &gt;&gt;&gt; <span class="selector-class">.b</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 但是像scss等预处理器却无法解析&gt;&gt;&gt;，所以我们使用下面的方式. */</span></span><br><span class="line">/deep/ <span class="selector-class">.el-cascader</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 但是有些开发者反应，在vue-cli3编译时，deep的方式会报错或者警告。</span></span><br><span class="line"><span class="comment">此时我们可以使用第三种方式 */</span></span><br><span class="line">::v-deep .el-cascader &#123;</span><br><span class="line">  width: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过内联样式 或者 绑定类样式覆盖默认样式<br>通过内联样式 style ，绑定类样式的方式，可以在某些标签中可以直接覆盖默认样式，不是很通用。具体实例如下：<br><el-button :style="selfstyle">默认按钮</el-button></p>
<script>
 export default {
   data() {
     return {
         selfstyle: {
             color: "white",
             marginTop: "10px",
             width: "100px",
             backgroundColor: "cadetblue"
         }
     };
   }
 }
</script>
<p>通过绑定修改样式方式修改：<br><el-button :class="[selfbutton]">默认按钮</el-button></p>
<script>
export default {
 data() {
   return {
     selfbutton: "self-button"
   };
 }
}
</script>
<style lang="stylus" rel="stylesheet/stylus" scoped>
.self-button {
 color: white;
 margin-top: 10px;
 width: 100px;
 background-Color: cadetblue;
}
</style></li>
</ol>
<p>扩展：<br>第一种全局引入css文件的方式，适合于对elementUI整体的修改，比如整体配色的修改；<br>第二种添加一个style标签的形式，也能够实现修改默认样式的效果，但实际上因为是修改了全局的样式，因此 在不同的vue组件中修改同一个样式有可能会有冲突。<br>第三种方式通过 /deep/ 的方式可以很方便的在vue组件中修改默认样式，也不会于其他页面有冲突。<br>第四种方式局限性比较大，可以使用，但不推荐使用。</p>
<h2 id="elementui-有什么用"><a href="#elementui-有什么用" class="headerlink" title="elementui 有什么用?"></a>elementui 有什么用?</h2><p>Element-UI：是一套采用 Vue 2.0 作为基础框架实现的组件库，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的组件库，提供了配套设计资源，帮助网站快速成型</p>
<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h2 id="react组件间的数据传递"><a href="#react组件间的数据传递" class="headerlink" title="react组件间的数据传递"></a>react组件间的数据传递</h2><ol>
<li>兄弟组件不能直接相互传送数据，此时可以将数据挂载在父组件中，由两个组件共享</li>
<li>子组件向父组件通讯，可以通过父组件定义事件（回调函数），子组件调用该函数，通过实参的形式来改变父组件的数据来通信</li>
<li>非父子组件间的通信：可以使用全局事件来实现组件间的沟通，React中可以引入eventProxy模块，利用eventProxy.trigger()方法发布消息，eventProxy.on()方法监听并接收消息。</li>
<li>组件间层级太深，可以使用上下文方式，让子组件直接访问祖先的数据或函数，通过this.context.xx</li>
</ol>
<h1 id="vue和react"><a href="#vue和react" class="headerlink" title="vue和react"></a>vue和react</h1><h2 id="react和vue的区别"><a href="#react和vue的区别" class="headerlink" title="react和vue的区别"></a>react和vue的区别</h2><ol>
<li>相同：都有虚拟dom，都支持服务器渲染，都可以使用props对组件进行父子通信，组件化开发，<br>数据驱动视图</li>
<li>不同：React严格上只针对MVC的view层，Vue则是MVVM模式<br>虚拟dom不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。<br>React每当应用的状态被改变时，全部子组件都会重新渲染。<br>当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制。<br>vue是双向数据绑定，react则是单向数据流</li>
</ol>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/07/18/2.vue%E5%92%8Creact%E7%9A%84%E5%90%88%E9%9B%86/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/07/18/2.vue%E5%92%8Creact%E7%9A%84%E5%90%88%E9%9B%86/";
            const title         = "「2.vue和react的合集」";
            const excerpt       = `架构概念mvc和mvvm的区别单页应用优缺点虚拟DOM和Diff算法框架带来的好处和弊端模块化、组件化、工程化谈谈对 MVC、MVP、MVVM 模式的理解vuev-model 作用v-model本质上不过是语法糖，可以用 v-mode...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/Vue/" rel="tag">Vue</a>
                </div>
                <div class="pull-date">
                    <time datetime="2022-09-06T16:34:10.255Z" itemprop="dateModified">最后编辑：2022-09-07</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" vue" href="/2022/07/18/vue/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" 1.js合集" href="/2022/07/31/1.js合集/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">念念不忘，必有回响</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                30
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                15
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                21
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5"><span class="toc-text">架构概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mvc%E5%92%8Cmvvm%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">mvc和mvvm的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">单页应用优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%92%8CDiff%E7%AE%97%E6%B3%95"><span class="toc-text">虚拟DOM和Diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-text">框架带来的好处和弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E3%80%81%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-text">模块化、组件化、工程化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-MVC%E3%80%81MVP%E3%80%81MVVM-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">谈谈对 MVC、MVP、MVVM 模式的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue"><span class="toc-text">vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model-%E4%BD%9C%E7%94%A8"><span class="toc-text">v-model 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">v-model实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-0-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-text">Vue2.0 双向绑定的缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E5%87%BD%E6%95%B0%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-vue-%E7%9A%84-data-%E8%BF%98%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">既然函数是引用类型，为什么 vue 的 data 还是可以用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VUE-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%EF%BC%9F%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">VUE 中什么是组件，为什么要封装组件？组件中 data 为什么是一个函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%9B%91%E5%90%ACdata%E5%8F%98%E5%8C%96"><span class="toc-text">描述监听data变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD-nextTick-%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-text">vue 中 $nextTick 作用与原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">vue的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if-v-show%E5%8C%BA%E5%88%AB"><span class="toc-text">v-if v-show区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%88%97%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0-key"><span class="toc-text">Vue 列表为什么加 key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for%E4%B8%AD%E7%9A%84key%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">v-for中的key的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E7%94%A8vue%E5%81%9A%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA"><span class="toc-text">为什么选择用vue做页面展示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-text">双向数据绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6-Vue-%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8F%AF%E4%BB%A5%E7%B2%BE%E5%87%86%E6%8E%A2%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%85%B7%E4%BD%93dom%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM-diff-%E5%91%A2"><span class="toc-text">既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A-new-Vue-%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-text">简单聊聊 new Vue 以后发生的事情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%9A%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">为什么做首屏优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">vue首屏白屏如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">vue单页面和传统的多页面区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#root%E3%80%81-refs%E3%80%81-parent%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">$root、$refs、$parent的使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%92%8Clocation-href%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">路由跳转和location.href的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scss%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8vue-cli%E4%B8%AD%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E6%98%AF%EF%BC%9F%E6%9C%89%E5%93%AA%E5%87%A0%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E4%B8%8Evue-delete%E5%8C%BA%E5%88%AB"><span class="toc-text">delete与vue.delete区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">computed和watch的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8vm-set-%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E5%93%8D%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%88%EF%BC%9F"><span class="toc-text">Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题？你能说说如下代码的实现原理么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-text">导航守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%E7%99%BB%E5%BD%95"><span class="toc-text">路由守卫进行判断登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">vue-router 实现懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E6%98%AF%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%ACHistoryRouter%E7%9A%84%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-text">js是如何监听HistoryRouter的变化的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashRouter-%E5%92%8C-HistoryRouter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">HashRouter 和 HistoryRouter的区别和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-router-%E5%8E%9F%E7%90%86-%E5%93%AA%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%8D%E4%BC%9A%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">Vue router 原理, 哪个模式不会请求服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">组件通信的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%EF%BC%8C-attrs%E5%92%8Clisteners-%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-text">vue组件间传值， attrs和listeners 了解过吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%BB%BA%E4%BC%A0%E5%80%BC%EF%BC%8C%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-text">组建传值，事件总线是怎么用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9C%A8mouted%E8%BF%98%E6%98%AFcreate%E9%87%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">vue生命周期中异步加载在mouted还是create里实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-keep-alive"><span class="toc-text">vue keep-alive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">谈谈对vue生命周期的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dom-diff%E7%AE%97%E6%B3%95%E5%92%8C%E8%99%9A%E6%8B%9FDOM"><span class="toc-text">dom diff算法和虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9MVVM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">说说你对MVVM的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">谈谈你对组件的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-Vue-%E4%B8%AD%EF%BC%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%BA%E4%BD%95%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E7%9A%84-Prop"><span class="toc-text">在 Vue 中，子组件为何不可以修改父组件传递的 Prop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%AD-Object-defineProperty-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-text">Vue 的响应式原理中 Object.defineProperty 有什么缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C-vuex-%E6%98%AF%E5%90%A6%E5%86%B2%E7%AA%81-%E4%BC%9A"><span class="toc-text">双向绑定和 vuex 是否冲突  会</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Vue 的父组件和子组件生命周期钩子执行顺序是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E5%9C%A8-v-for-%E6%97%B6%E7%BB%99%E6%AF%8F%E9%A1%B9%E5%85%83%E7%B4%A0%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E9%9C%80%E8%A6%81%E7%94%A8%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%B8%B2%E6%9F%93%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%97%B6%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">vue 渲染大量数据时应该怎么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88-nextTick-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">谈一谈 nextTick 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-text">Vue 中的 computed 和 watch 的区别在哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E3%80%81v-show%E3%80%81v-html-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E7%9A%84%EF%BC%9F"><span class="toc-text">v-if、v-show、v-html 的原理是什么，它是如何封装的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-text">如何优化自己的代码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0readyonly%E4%B8%8Edisabled%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">简述readyonly与disabled的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue3"><span class="toc-text">vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Vue3.0 实现数据双向绑定的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vuex"><span class="toc-text">vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">Vuex是什么，每个属性是干嘛的，如何使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">Vuex实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutation%E5%92%8Caction%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">mutation和action有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ElementUI"><span class="toc-text">ElementUI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9ElementUI-%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">修改ElementUI 样式的几种方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elementui-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">elementui 有什么用?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#react"><span class="toc-text">react</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-text">react组件间的数据传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E5%92%8Creact"><span class="toc-text">vue和react</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#react%E5%92%8Cvue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">react和vue的区别</span></a></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/">性能优化与安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%93%E5%8C%85/">打包</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/">零散知识</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/HTTP/" style="font-size: 0.6em;">HTTP</a> <a href="/tags/Vue/" style="font-size: 0.73em;">Vue</a> <a href="/tags/css/" style="font-size: 0.6em;">css</a> <a href="/tags/egg/" style="font-size: 0.6em;">egg</a> <a href="/tags/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/" style="font-size: 0.6em;">flex弹性布局</a> <a href="/tags/hexo/" style="font-size: 0.6em;">hexo</a> <a href="/tags/js/" style="font-size: 0.6em;">js</a> <a href="/tags/koa/" style="font-size: 0.6em;">koa</a> <a href="/tags/node/" style="font-size: 0.6em;">node</a> <a href="/tags/npm/" style="font-size: 0.6em;">npm</a> <a href="/tags/react/" style="font-size: 0.6em;">react</a> <a href="/tags/vue/" style="font-size: 0.8em;">vue</a> <a href="/tags/wamp/" style="font-size: 0.6em;">wamp</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.67em;">前端</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 0.6em;">开发工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 0.67em;">微信小程序</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/" style="font-size: 0.6em;">性能优化与安全</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 0.6em;">打包</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/08/31/8.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><i class="fa  fa-book"></i> 8.开发工具</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/25/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/"><i class="fa  fa-book"></i> 7.性能优化与安全</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/16/6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"><i class="fa  fa-book"></i> 6.浏览器</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/14/5.%E6%89%93%E5%8C%85/"><i class="fa  fa-book"></i> 5.打包</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/14/3.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%88%E9%9B%86/"><i class="fa  fa-book"></i> 3.微信小程序合集</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 橘知·部落 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by zengqm.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>