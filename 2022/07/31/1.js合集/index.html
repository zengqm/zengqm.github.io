<!DOCTYPE html>
<html lang="zh-cn">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
  
  <title>1.js合集 | 橘知·部落</title>
  <meta name="author" content="zengqm" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="js" />
  
  <meta name="description" content="js1.怎么判断一个对象是否为空前提：对象属性是可遍历  for-in 遍历，并通过 hasOwnProperty 方法确认是否存在某个 key , 这种方法不能够遍历到 enumerable 为 false 的属性 1234567891011   const isEmptyObj &#x3D; object &#x3D;&gt; &amp;#123;    if (!!Object.getOwnPropertySymbol">
<meta property="og:type" content="article">
<meta property="og:title" content="1.js合集">
<meta property="og:url" content="http://example.com/2022/07/31/1.js%E5%90%88%E9%9B%86/index.html">
<meta property="og:site_name" content="橘知·部落">
<meta property="og:description" content="js1.怎么判断一个对象是否为空前提：对象属性是可遍历  for-in 遍历，并通过 hasOwnProperty 方法确认是否存在某个 key , 这种方法不能够遍历到 enumerable 为 false 的属性 1234567891011   const isEmptyObj &#x3D; object &#x3D;&gt; &amp;#123;    if (!!Object.getOwnPropertySymbol">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-31T12:08:08.256Z">
<meta property="article:modified_time" content="2022-08-27T15:23:53.019Z">
<meta property="article:author" content="zengqm">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">橘知·部落</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>橘知·部落</h2> <br />
                        <span>活在自己的热爱里</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/31/1.js%E5%90%88%E9%9B%86/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">1.js合集</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2022-07-31T12:08:08.256Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2022-07-31</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">zengqm</span>
                </li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~33.89K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1661613833019"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js"><span class="toc-number">1.</span> <span class="toc-text">js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1.怎么判断一个对象是否为空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4-%E5%8E%BB%E9%87%8D-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.数组降维&#x2F;去重&#x2F;排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 数组降维</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 数组排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.3.</span> <span class="toc-text">3.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-js%E4%B8%ADbind-call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">4. js中bind,call和apply的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-js%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.5.</span> <span class="toc-text">5.js判断数据类型的方式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.6.</span> <span class="toc-text">6.JS数据类型有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">7.null和undefined区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA8%E4%B8%AA"><span class="toc-number">1.8.</span> <span class="toc-text">8.数组的常用方法(至少说出8个)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.</span> <span class="toc-text">9.对象的原生方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8JS%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">外部JS文件出现中文字符，会出现什么问题，怎么解决？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#es6"><span class="toc-number">2.</span> <span class="toc-text">es6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-async-await"><span class="toc-number">2.1.</span> <span class="toc-text">1. async await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Promise"><span class="toc-number">2.2.</span> <span class="toc-text">2. Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-let-%E5%92%8C-const-%E5%92%8C-var"><span class="toc-number">2.3.</span> <span class="toc-text">3. let 和 const 和 var</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是暂时性死区？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ES6-%E4%B8%80%E5%85%B1%E6%9C%89-6-%E7%A7%8D%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">4. ES6 一共有 6 种声明变量的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">5. 箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-number">2.6.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-proxy"><span class="toc-number">2.7.</span> <span class="toc-text">6. proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-map%E5%92%8Cset"><span class="toc-number">2.8.</span> <span class="toc-text">7. map和set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-es6%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8Ces5%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">8. es6的继承和es5的继承有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Symbol%EF%BC%8C%E5%86%99%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B9%B6%E8%AF%B4%E5%87%BA%E5%AE%83%E7%9A%84%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.10.</span> <span class="toc-text">9. Symbol，写一个应用实例，并说出它的其他应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js-1"><span class="toc-number">3.</span> <span class="toc-text">js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.</span> <span class="toc-text">构造函数、原型、实例的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proto-%E5%92%8Cprototype"><span class="toc-number">3.2.</span> <span class="toc-text">_proto_和prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.3.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E2%80%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">内存泄漏 –内存泄漏分析工具的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">3.6.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">3.7.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91"><span class="toc-number">3.8.</span> <span class="toc-text">this指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.9.</span> <span class="toc-text">new操作符具体做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8-%E6%A0%88%E4%B8%8E%E5%A0%86"><span class="toc-number">3.10.</span> <span class="toc-text">V8 栈与堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">3.11.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1-%EF%BC%88macrotask%EF%BC%89%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-%EF%BC%88microtask%EF%BC%89"><span class="toc-number">3.12.</span> <span class="toc-text">宏任务 （macrotask）和微任务 （microtask）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.13.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.14.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%EF%BC%88%E6%B6%89%E5%8F%8A%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="toc-number">3.15.</span> <span class="toc-text">经典面试题：（涉及闭包，作用域链，事件循环）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.16.</span> <span class="toc-text">全局执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-number">3.17.</span> <span class="toc-text">防抖节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">3.18.</span> <span class="toc-text">函数柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">3.19.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">3.20.</span> <span class="toc-text">事件捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">3.21.</span> <span class="toc-text">事件委托&#x2F;事件代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax"><span class="toc-number">3.22.</span> <span class="toc-text">ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">3.23.</span> <span class="toc-text">axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99"><span class="toc-number">3.24.</span> <span class="toc-text">正则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">设计 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.2.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">线程和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.2.</span> <span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">线程间的通信方式</span></a></li></ol></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="1-怎么判断一个对象是否为空"><a href="#1-怎么判断一个对象是否为空" class="headerlink" title="1.怎么判断一个对象是否为空"></a>1.怎么判断一个对象是否为空</h2><p><strong>前提：对象属性是可遍历</strong></p>
<ol>
<li><p>for-in 遍历，并通过 hasOwnProperty 方法确认是否存在某个 key , 这种方法不能够遍历到 enumerable 为 false 的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> isEmptyObj = <span class="function"><span class="params">object</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">Object</span>.getOwnPropertySymbols(object).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li>使用 Object.keys()方法， 然后判断 length 即可，keys 返回的是自身可枚举属性，因此同样的不可遍历到 enumerable 为 false 的属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmptyObj = <span class="function"><span class="params">object</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">Object</span>.getOwnPropertySymbols(object).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(object).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用 JSON.Stringify() 方法将对象转为字符串，与字符串 ‘{}’ 对比，同样该方法无法获取到不可遍历属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmptyObj = <span class="function"><span class="params">object</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">Object</span>.getOwnPropertySymbols(object).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(object) === <span class="string">&#x27;&#123;&#125;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Object.getOwnPropertyNames() 方法，获取所有属性名，这样就算是不可枚举属性依然能够获取到（推荐使用）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEmptyObj = <span class="function"><span class="params">object</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">Object</span>.getOwnPropertySymbols(object).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!!<span class="built_in">Object</span>.getOwnPropertyNames(object).length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>扩展知识：</p>
<ol>
<li>Symbol的特点：</li>
</ol>
<ul>
<li><p>Symbol的值是唯一的，用来解决命名冲突的问题</p>
</li>
<li><p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
</li>
<li><p>Symbol 定义的属性不可以使用for…in进行遍历,可以使用Reflect.ownKeys()获取所有的键名，<strong>可以通过Object.getOwnPropertySymbols获取所有的Symbol值</strong></p>
</li>
<li><p>可以通过显示的方式转为字符串或者布尔类型，不可以转为数字类型</p>
</li>
<li><p>Symbol类型是不可枚举的，作为key值使用要加方括号[]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym=<span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> sym2=<span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> sym3=<span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    [sym]:<span class="string">&quot;mooshine&quot;</span>,</span><br><span class="line">    <span class="attr">sym2</span>:<span class="string">&quot;sunshine&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[sym3]=<span class="string">&quot;stars&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]);</span><br><span class="line"><span class="comment">//mooshine</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym2]);</span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym3]);</span><br><span class="line"><span class="comment">//stars</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>可枚举性（enumerable）:</li>
</ol>
<p>用来控制所描述的属性，是否将被包括在for…in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。</p>
<ul>
<li>for..in循环</li>
<li>Object.keys方法</li>
<li>JSON.stringify方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javascriptvar o = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">o.c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&#x27;d&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.d</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> o ) <span class="built_in">console</span>.log( o[key] ); </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(o)  <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(o <span class="comment">// =&gt; &quot;&#123;a:1,b:2,c:3&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>Object.getOwnPropertyNames</code>返回的是对象所有自己的属性，而<code>Object.keys(obj)</code>则返回的是所有可枚举属性</li>
</ol>
<h2 id="2-数组降维-去重-排序"><a href="#2-数组降维-去重-排序" class="headerlink" title="2.数组降维/去重/排序"></a>2.数组降维/去重/排序</h2><h3 id="1-数组降维"><a href="#1-数组降维" class="headerlink" title="1. 数组降维"></a>1. 数组降维</h3><p>（1）数组字符串化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）数组字符串化：</span></span><br><span class="line">     <span class="keyword">let</span> arr = [</span><br><span class="line">       [<span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>],</span><br><span class="line">       [<span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>]</span><br><span class="line">     ]</span><br><span class="line">     arr += <span class="string">&#x27;&#x27;</span></span><br><span class="line">     arr = arr.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">     <span class="built_in">console</span>.log(arr) <span class="comment">// [&quot;222&quot;, &quot;333&quot;, &quot;444&quot;, &quot;55&quot;, &quot;66&quot;, &quot;77&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （2）递归</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">reduceDimension</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">let</span> ret = []</span><br><span class="line">       <span class="keyword">let</span> toArr = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">         arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">           <span class="comment">// 如果item为数组，则再次进入toArr(item)，如果不是数组，则压入ret数组中</span></span><br><span class="line">           item <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? toArr(item) : ret.push(item)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">       toArr(arr)</span><br><span class="line">       <span class="keyword">return</span> ret</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> arr = [</span><br><span class="line">       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]</span><br><span class="line">     ]</span><br><span class="line">     <span class="built_in">console</span>.log(reduceDimension(arr)) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span></span><br></pre></td></tr></table></figure>

<p>（3）flat()   es10新特性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （3）flat()</span></span><br><span class="line">     <span class="keyword">let</span> arr = [ <span class="comment">// 二维数组</span></span><br><span class="line">       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]</span><br><span class="line">     ]</span><br><span class="line">     <span class="built_in">console</span>.log(arr.flat()) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span></span><br></pre></td></tr></table></figure>

<p>（4）flatMap()   es10新特性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （4）flatMap()</span></span><br><span class="line">      <span class="keyword">let</span> arr = [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>] ]</span><br><span class="line">       <span class="built_in">console</span>.log(arr.flatMap(<span class="function"><span class="params">item</span> =&gt;</span> item)) <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>



<h3 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2. 数组去重"></a>2. 数组去重</h3><p>主要考察数组的常用方法和基本操作<br>是否能用多种方式去重</p>
<p>（1）将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique1</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr2 = arr.sort();</span><br><span class="line">    <span class="keyword">var</span> res = [arr2[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;arr2.length; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr2[i] !== res[res.length-<span class="number">1</span>])&#123;</span><br><span class="line">      res.push(arr2[i]);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">console</span>.log(unique1([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<p>（2）利用数组的indexOf下标属性来查询</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique2</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(res.indexOf(arr[i]) == -<span class="number">1</span>)&#123;</span><br><span class="line">      res.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">console</span>.log(unique2([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<p>（3）利用forEach和数组原型对象上的includes方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique3</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> res = [];</span><br><span class="line"> </span><br><span class="line"> arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  res.includes(item) ? <span class="string">&#x27;&#x27;</span> : res.push(item);</span><br><span class="line"> &#125;); </span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique3([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>]));</span><br></pre></td></tr></table></figure>

<p>（4）利用ES6的set方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//Set数据结构，它类似于数组，其成员的值都是唯一的</span></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)); <span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique4([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>]));</span><br></pre></td></tr></table></figure>



<h3 id="3-数组排序"><a href="#3-数组排序" class="headerlink" title="3. 数组排序"></a>3. 数组排序</h3><p>（1）冒泡排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</span><br></pre></td></tr></table></figure>

<p>原理：不断<strong>比较相邻元素</strong>，如果前一个比后一个大，就元素<strong>交换</strong>，直到没有需要比较的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> ( <span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;  <span class="comment">// 比较相邻元素        </span></span><br><span class="line">         <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];   <span class="comment">//元素交换        </span></span><br><span class="line">         arr[j+<span class="number">1</span>] = arr[j];        </span><br><span class="line">         arr[j] = temp;      </span><br><span class="line">       &#125;    </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）选择排序</p>
<p>原理：每一次从待排序的数据元素中选出<strong>最小</strong>（或<strong>最大</strong>）的一个元素，存放在序列的<strong>起始位置</strong>，直到全部待排序的数据元素排完。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;  <span class="comment">//寻找最小的数</span></span><br><span class="line">                minIndex = j;   <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）快速排序</p>
<p>原理：在数组中找到基准点（比如中间位置的数字），其他数与之比较，新建两个数组，小于基准点的数存储在左边数组，大于基准点的数存储在右边数组，拼接数组，然后左边数组与右边数组继续比较存储，直到最后完成数组排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>)</span>&#123;        </span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;            </span><br><span class="line">        <span class="keyword">return</span> arr  <span class="comment">// 如果数组长度小于或等于1，则直接返回数组</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 找到数组中间的索引，如果是浮点数，则向下取整  </span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);  </span><br><span class="line">    <span class="keyword">var</span> centerVal = arr.splice(num,<span class="number">1</span>);  <span class="comment">// 找到数组中间索引的值</span></span><br><span class="line">    <span class="keyword">var</span> left = [];        </span><br><span class="line">    <span class="keyword">var</span> right = [];        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;            </span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;centerVal)&#123;</span><br><span class="line">            left.push(arr[i])  <span class="comment">// 基准点左边的数放到左边数组</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.push(arr[i]) <span class="comment">// 基准点右边的数放到右边数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">// 利用concat拼接数组，并调用sort方法</span></span><br><span class="line">    <span class="keyword">return</span> sort(left).concat([centerVal],sort(right)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>扩展知识：</p>
<p>当+号作为二元操作符时</p>
<p>为了方便描述，我们把+号左侧的值叫做A，右侧的叫做B：</p>
<ul>
<li>第一步：如果A和B都是number类型，直接相加；</li>
<li>第二步：接下来看A和B两个操作数是否有一个是string类型，存在一个字符类型的话，那么另外一个操作数也会无条件地转换为字符串，然后连接；</li>
<li>第三步：既不是number,也不是string, 两个操作数会隐式转换成数字类型(如果无法成功转换成数字，则变成NaN，再往下操作)，再进行加法算数操作</li>
</ul>
<p>例如：如果是[1,2,3]+4</p>
<p>转换规则如下：</p>
<ol>
<li>能转换成数字，返回之</li>
<li>否则调用valueOf()，如果执行结果是基本类型，返回之；</li>
<li>否则调用toString()，如果执行结果是基础类型，返回之；</li>
<li>无法得到原始值，抛异常。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">计算 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] + <span class="number">1</span>的过程：</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].valueOf() =&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1,2,3&#x27;</span> + <span class="number">1</span></span><br><span class="line">(此时得到了字符串，则去匹配加号两边又一边为字符串的规则)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;1,2,31&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_57135756/article/details/124024502">https://blog.csdn.net/m0_57135756/article/details/124024502</a></p>
<h2 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3.深拷贝和浅拷贝"></a>3.深拷贝和浅拷贝</h2><p>浅拷贝，深拷贝只针对引用数据类型，如对象</p>
<p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝，如果对象里的属性是基本类型，拷贝的就是基本类型的值。如果对象里的属性是引用类型，拷贝的就是内存地址即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p>
<p>深拷贝，开辟一个新的栈，两个对象属性完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
<h2 id="4-js中bind-call和apply的区别"><a href="#4-js中bind-call和apply的区别" class="headerlink" title="4. js中bind,call和apply的区别"></a>4. js中bind,call和apply的区别</h2><ol>
<li>作用： bind,call,apply都是用来改变this指向的</li>
<li>区别：<br>call和apply的传参方式不同<br>bind,call,apply的返回值不同<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Tencent = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params">company</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,company)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Tencent = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params">company</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name,company)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tencent.say.call(Alibaba,<span class="string">&#x27;Alibaba&#x27;</span>); <span class="comment">// call传参挨个传递</span></span><br><span class="line"></span><br><span class="line">Tencent.say.apply(Alibaba,[<span class="string">&#x27;Alibaba&#x27;</span>]); <span class="comment">// apply传参传递的是数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> say = Tencent.say.bind(Alibaba,<span class="string">&#x27;Alibaba&#x27;</span>); <span class="comment">// bind返回的是函数 传参挨个传递</span></span><br><span class="line">say();</span><br></pre></td></tr></table></figure></li>
<li>使用场景:</li>
</ol>
<p>call:</p>
<ul>
<li>判断数据类型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> type = <span class="built_in">Object</span>.prototype.toString.call(array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;type&#x27;</span>,type);</span><br></pre></td></tr></table></figure></li>
<li>类数组转数组<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLike = &#123;</span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="string">&#x27;age&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>:<span class="string">&#x27;sex&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.prototype.slice.call(arrayLike)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// [&quot;name&quot;,&quot;age&quot;,&quot;sex&quot;]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>apply:</p>
<ul>
<li>给定数组求最大值/最小值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,array)</span><br><span class="line"><span class="comment">//相当于 const max = Math.max(1,2,3,4,5) </span></span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></table></figure>
bind:</li>
<li>react类组件事件响应函数的绑定</li>
</ul>
<h2 id="5-js判断数据类型的方式有哪些"><a href="#5-js判断数据类型的方式有哪些" class="headerlink" title="5.js判断数据类型的方式有哪些"></a>5.js判断数据类型的方式有哪些</h2><ol>
<li><p>typeof<br>优点：使用简单<br>缺点：功能残缺，只能用来判断6种数据类型</p>
</li>
<li><p>Object.prototype.toString.call()<br>优点：适用于判断所有数据类型<br>缺点：使用上相对typeof而言比较麻烦</p>
</li>
<li><p>instanceof<br>instanceof 运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="comment">// 优点：能够快速区分基本数据类型 </span></span><br><span class="line"><span class="comment">// 缺点：不能将Object、Array和Null区分，都返回object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">instanceof</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 </span></span><br><span class="line"><span class="comment">// 缺点：Number，Boolean，String基本数据类型不能判断</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call()</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">2</span>));                      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));                   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;str&#x27;</span>));                  <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([]));                     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));           <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;));                     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));              <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));                   <span class="comment">//[object Null]</span></span><br><span class="line"><span class="comment">// 优点：精准判断数据类型 </span></span><br><span class="line"><span class="comment">// 缺点：写法繁琐不容易记，推荐进行封装后使用</span></span><br></pre></td></tr></table></figure>

<h2 id="6-JS数据类型有哪些"><a href="#6-JS数据类型有哪些" class="headerlink" title="6.JS数据类型有哪些"></a>6.JS数据类型有哪些</h2><ol>
<li>基本数据类型:string,number,Boolean,null,undefined,symbol(ES6新增)</li>
<li>引用数据类型object(Object,Array),function</li>
</ol>
<h2 id="7-null和undefined区别"><a href="#7-null和undefined区别" class="headerlink" title="7.null和undefined区别"></a>7.null和undefined区别</h2><ol>
<li>null 表示一个对象是“没有值”的值，也就是值为“空”；<br>undefined 表示一个变量声明了没有初始化(赋值)；</li>
<li>undefined不是一个有效的JSON，而null是；</li>
<li>undefined的类型(typeof)是undefined；<br>null 的类型(typeof)是object；</li>
</ol>
<h2 id="8-数组的常用方法-至少说出8个"><a href="#8-数组的常用方法-至少说出8个" class="headerlink" title="8.数组的常用方法(至少说出8个)"></a>8.数组的常用方法(至少说出8个)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.shift 删除数组中的第一个元素</span><br><span class="line">2.pop 删除数组中的最后一个元素</span><br><span class="line">3.unshift 增加元素在数组的前面</span><br><span class="line">4.push 增加元素在数组的后面</span><br><span class="line">5.map 循环，并且返回新的数组</span><br><span class="line">6.forEach 循环，遍历</span><br><span class="line">7.filter 过滤，筛选出数组中的满足条件的，并且返回新的数组</span><br><span class="line">8.concnt 合并数组</span><br><span class="line">9.find 查找出第一个符合条件中的数组元素</span><br><span class="line">10.findIndex 查找出第一个符合条件中的数组元素，所在的索引位置</span><br><span class="line">11.flat 将多维数组转为一维数组</span><br><span class="line">12.join将数组转为字符串</span><br><span class="line">13.reverse 颠倒数组中的顺序</span><br><span class="line">14.every检测数组中元素是否都是符合条件 === bollean</span><br><span class="line">15.some检测数组中元素是否有满足条件的元素 === bollean</span><br><span class="line">16.splice(start,n,添加元素) 开始位置 删除个数，添加元素</span><br><span class="line">17.sort 排序</span><br><span class="line">18.slice(start,end) 选中[start.end)之间的元素</span><br><span class="line">19.indexOf 查找值所在的位置</span><br><span class="line">20.includes 查看数组中是否存在此元素</span><br></pre></td></tr></table></figure>
<h2 id="9-对象的原生方法"><a href="#9-对象的原生方法" class="headerlink" title="9.对象的原生方法"></a>9.对象的原生方法</h2><p>1.Object.hasOwnProperty( ) 检查属性是否被继承<br>2.Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型<br>3.Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性<br>4.Object.toLocaleString( ) 返回对象的本地字符串表示<br>5.Object.toString( ) 定义一个对象的字符串表示<br>6.Object.valueOf( ) 指定对象的原始值</p>
<h2 id="外部JS文件出现中文字符，会出现什么问题，怎么解决？"><a href="#外部JS文件出现中文字符，会出现什么问题，怎么解决？" class="headerlink" title="外部JS文件出现中文字符，会出现什么问题，怎么解决？"></a>外部JS文件出现中文字符，会出现什么问题，怎么解决？</h2><p>会出现乱码，加charset=”utf-8”;</p>
<h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async await"></a>1. async await</h2><ol>
<li>async await 理解</li>
</ol>
<ul>
<li>async 是一个修饰符，async 定义的函数会默认的返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数</li>
<li>await 也是一个修饰符，await 关键字 只能放在 async 函数内部， await关键字的作用 就是获取 Promise中返回的内容， 获取的是Promise函数中resolve或者reject的值</li>
<li>async/await 的优势在于处理 then 链<br>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，<code>Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它</code>）</li>
<li>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</li>
<li>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误</li>
</ul>
<ol start="2">
<li>理解 async/await以及对Generator的优势<br>async await 是用来解决异步的，async函数是Generator函数的语法糖<br>使用关键字async来表示，在函数内部使用 await 来表示异步<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数<br>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</li>
</ol>
<p><strong>async较Generator的优势：</strong><br>（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样<br>（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　<br>（3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值<br>（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用</p>
<h2 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h2><ol>
<li><p>什么是promise?<br>简单来说可以把promise当作一个装着异步操作结果的容器。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。它将异步函数以同步的方式书写，也解决了回调地狱问题<br>特点：（1）对象状态不受外界影响<br>  （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果<br>缺点：（1），无法取消promise，一旦新建它就会立即执行，无法中途取消<br>  （2），如果不设置回调函数，promise内部抛出的错误，不会反应到外部<br>  （3）无法得知目前进展到哪一个阶段（刚刚开始还是即将结束）<br>三个状态：进行中、已成功、已失败。 </p>
</li>
<li><p>Promise构造函数是同步执行还是异步执行，那么 then 方法呢?</p>
</li>
</ol>
<ul>
<li>promise构造函数是同步执行的，then方法是异步执行的</li>
</ul>
<ol start="3">
<li>promise有几种状态，什么时候会进入catch?</li>
</ol>
<ul>
<li>三个状态: pending、fulfilled、reject</li>
<li>两个过程: padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch</li>
</ul>
<ol start="4">
<li><p>下面的输出结果是多少</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3</p>
</blockquote>
</li>
<li><p>promise.all</p>
</li>
</ol>
<ul>
<li>Promise.all的使用<br>常见使用场景 ： 多个异步结果合并到一起<br>Promise.all可以将多个Promise实例包装成一个新的Promise实例。用于将多个Promise实例，包装成一个新的Promise实例。</li>
<li>Promise.race的使用<br>类似于Promise.all() ,区别在于 它有任意一个返回成功后，就算完成，但是 进程不会立即停止<br>常见使用场景：把异步操作和定时器放到一起，如果定时器先触发，认为超时，告知用户</li>
</ul>
<ol start="6">
<li>promise的then什么场景？</li>
</ol>
<ul>
<li>是异步转化为串行执行的基本实现方式。<br>promise的then中默认返回一个promise实例<br>当then中没有return时返回的是undefined<br>当then中return的对象或者基本类型等非new Promise实例时，对下一个进程then是同时执行的<br>当then中return的是一个new Promise或者Promise.resolve()等实例时，对下一个进程then时队列顺序执行的</li>
</ul>
<ol start="7">
<li>Promise 中reject 和 catch 处理上有什么区别</li>
</ol>
<ul>
<li>reject 是用来抛出异常，catch 是用来处理异常</li>
<li>reject 是 Promise 的方法，而 catch 是 Promise 实例的方法</li>
<li>reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch</li>
<li>网络异常（比如断网），会直接进入catch而不会进入then的第二个回调</li>
</ul>
<h2 id="3-let-和-const-和-var"><a href="#3-let-和-const-和-var" class="headerlink" title="3. let 和 const 和 var"></a>3. let 和 const 和 var</h2><ul>
<li>var </li>
</ul>
<ol>
<li>全局作用域</li>
<li>声明覆盖</li>
<li>变量提升</li>
</ol>
<ul>
<li>let</li>
</ul>
<ol>
<li>块级作用域</li>
<li>for循环使用let声明变量，每一轮声明的变量都是新的变量i。那变量i是怎么知道上一轮循环的值呢，这是因为 JavaScript 引擎内部会记住上一轮循环的值</li>
<li>同一个作用域不可使用 let 重复声明同一个变量</li>
<li>for循环设置循环的那一部分是一个父作用域，而循环内部是一个子作用域</li>
<li>不出现变量提升<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 父作用域</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 子作用域</span></span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>const</li>
</ul>
<ol>
<li>一但声明必须初始化（赋值）</li>
<li>块级作用域</li>
<li>不可重复声明</li>
<li>不出现变量提升</li>
<li>const声明一个变量，变量指向的那个内存地址所保存的数据不得改动。也就是说声明基本类型，就等同于常量；声明引用类型，则不能改变内存地址<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="什么是暂时性死区？"><a href="#什么是暂时性死区？" class="headerlink" title="什么是暂时性死区？"></a>什么是暂时性死区？</h3><ol>
<li>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</li>
<li>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li>
<li>看下面代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​ 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。<br>​ ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br>​ 再看如下代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束(let声明之前都是暂时性死区)</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
​ 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。<br>​ 再看如下代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
​ 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“ .<br>​ 改成如下代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>
​ 上面代码中，如果y的默认值是x，就不会报错，因为此时x已经声明了。</li>
</ol>
<h2 id="4-ES6-一共有-6-种声明变量的方法"><a href="#4-ES6-一共有-6-种声明变量的方法" class="headerlink" title="4. ES6 一共有 6 种声明变量的方法"></a>4. ES6 一共有 6 种声明变量的方法</h2><ul>
<li>var,function,let,const,import,class</li>
</ul>
<h2 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5. 箭头函数"></a>5. 箭头函数</h2><p>特点：</p>
<ol>
<li><p>相比普通函数，箭头函数有更加简洁的语法。</p>
</li>
<li><p>箭头函数不绑定this，会捕获其所在上下文的this，作为自己的this。<br>这句话需要注意的是，箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量。</p>
</li>
<li><p>箭头函数是匿名函数，不能作为构造函数，不可以使用new命令，否则后抛出错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> f(); <span class="comment">// f is not a constructor</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数不绑定arguments，值由外围最近一层非箭头函数决定。<br>下面的这个函数会报错，在浏览器环境下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">f(); <span class="comment">// arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>下面的箭头函数不会报错，因为arguments是外围函数的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>箭头函数可以通过拓展运算符获取传入的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args); <span class="comment">// [[1,2,3]]</span></span><br><span class="line">&#125;</span><br><span class="line">func([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数没有原型对象prototype这个属性<br>由于不可以通过new关键字调用，所以没有构建原型的需求，所以箭头函数没有prototype这个属性。</p>
</li>
<li><p>箭头函数不能用作Generator函数，不能使用yeild关键字</p>
</li>
<li><p>在以下场景中不要使用箭头函数去定义：</p>
<blockquote>
<p>定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。<br>箭头函数里不但没有 this，也没有 arguments, super</p>
</blockquote>
</li>
</ol>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><ol>
<li>Genertor 函数是es6 新增的一种异步编程的解决方案，语法和传统的函数完全不同；Genertor 函数的最大的特点就是可以交出函数的执行权（即暂停执行）</li>
<li>对于Generator 函数也可以叫做生成器函数<blockquote>
<p>形式上： Generator函数是一个普通的函数，不过相对于普通函数多出了两个特征。一是在function关键字和函数明之间多了’*’号；二是函数内部使用了* yield表达式，用于定义Generator函数中的每个状态。<br>语法上： Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator(迭代器)对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。<br>调用上： 普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">myGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> MG = myGenerator()</span><br><span class="line"></span><br><span class="line">MG.next() <span class="comment">// &#123;value:&#x27;Hello&#x27;,done:false&#125;</span></span><br><span class="line">MG.next() <span class="comment">// &#123;value:&#x27;world&#x27;,done:false&#125;</span></span><br><span class="line">MG.next() <span class="comment">// &#123;value:&#x27;ending&#x27;,done:true&#125;</span></span><br><span class="line">MG.next() <span class="comment">// &#123;value:&#x27;undefined&#x27;,done:false&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<h2 id="6-proxy"><a href="#6-proxy" class="headerlink" title="6. proxy"></a>6. proxy</h2><h2 id="7-map和set"><a href="#7-map和set" class="headerlink" title="7. map和set"></a>7. map和set</h2><h2 id="8-es6的继承和es5的继承有什么区别"><a href="#8-es6的继承和es5的继承有什么区别" class="headerlink" title="8. es6的继承和es5的继承有什么区别"></a>8. es6的继承和es5的继承有什么区别</h2><ol>
<li><p>ES6 中有类 class 的概念，类 class 的继承是通过 extends 来实现的。</p>
</li>
<li><p>ES5 中是通过设置构造函数的 prototype 属性，来实现继承的。</p>
</li>
<li><p>ES6 与 ES5 中的继承有 2 个区别:</p>
</li>
</ol>
<ul>
<li>ES6 中子类会继承父类的属性</li>
<li>super() 与 A.call(this) 是不同的，在继承原生构造函数的情况下，体现得很明显，ES6 中的子类实例可以继承原生构造函数实例的内部属性，而在 ES5 中做不到。</li>
</ul>
<h2 id="9-Symbol，写一个应用实例，并说出它的其他应用场景"><a href="#9-Symbol，写一个应用实例，并说出它的其他应用场景" class="headerlink" title="9. Symbol，写一个应用实例，并说出它的其他应用场景"></a>9. Symbol，写一个应用实例，并说出它的其他应用场景</h2><h1 id="js-1"><a href="#js-1" class="headerlink" title="js"></a>js</h1><h2 id="构造函数、原型、实例的关系"><a href="#构造函数、原型、实例的关系" class="headerlink" title="构造函数、原型、实例的关系"></a>构造函数、原型、实例的关系</h2><p>每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例，就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。</p>
<h2 id="proto-和prototype"><a href="#proto-和prototype" class="headerlink" title="_proto_和prototype"></a>_proto_和prototype</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,score</span>)</span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">introduce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>,考了<span class="subst">$&#123;<span class="built_in">this</span>.score&#125;</span>分`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">99</span>);</span><br><span class="line"><span class="built_in">console</span>.log(student)</span><br><span class="line"><span class="comment">// student实例的展开</span></span><br><span class="line"><span class="comment">// &#123;name: &quot;张三&quot;</span></span><br><span class="line"><span class="comment">// score: 99</span></span><br><span class="line"><span class="comment">// [[Prototype]]: Object // 隐式原型</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [[Prototype]]: Object 隐式原型的展开</span></span><br><span class="line"><span class="comment">// &#123; constructor: class Student // 原型上constructor属性指向构造函数</span></span><br><span class="line"><span class="comment">// introduce: ƒ introduce()</span></span><br><span class="line"><span class="comment">// [[Prototype]]: Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">student.introduce();</span><br></pre></td></tr></table></figure>

<p>student.<em>proto</em> === Student.prototype<br>    隐式原型           显式原型</p>
<ul>
<li>当在一个对象上寻找不到属性和方法的时候，就会到它的隐式原型上去找</li>
<li>student实例由Student类创建的，Student类上有个prototype的属性与student实例上的_proto_是一样的</li>
<li>因此student实例上的_proto_ 和 Student类上prototype 指向的是同一个对象（Student.prototype），即构造这个类的显式原型</li>
<li>而这个显式原型是一个对象，对象上还会有一个_proto_隐式原型</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul>
<li>从某个对象出发，依次寻找隐式原型的指向，将形成一条链条，这条链条叫做原型链。</li>
<li>原型链最终的指向是Object的prototype, 而Object中的__proto__是null<br><code>console.log(Object.prototype.__proto__); //null</code></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>原型链</li>
<li>盗用构造函数</li>
<li>组合继承</li>
<li>原型链式继承</li>
<li>寄生式继承</li>
<li>寄生式组合继承</li>
</ol>
<h2 id="内存泄漏-–内存泄漏分析工具的使用"><a href="#内存泄漏-–内存泄漏分析工具的使用" class="headerlink" title="内存泄漏 –内存泄漏分析工具的使用"></a>内存泄漏 –内存泄漏分析工具的使用</h2><p>[<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZS4y1T7fc/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=8c5b3af7676319185eb40a980fd6c69b%5D">https://www.bilibili.com/video/BV1ZS4y1T7fc/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=8c5b3af7676319185eb40a980fd6c69b]</a></p>
<ol>
<li><p>内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用，于是产生溢出；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>
</li>
<li><p>内存泄露（memory leak），是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>比如，内存泄露是指new了一块内存，但无法被释放或者被垃圾回收。new了一个对象之后，它申请占用了一块堆内存，当把这个对象指针置为null时或者离开作用域导致被销毁，那么这块内存没有人引用它了在JS里面就会被自动垃圾回收。但是如果这个对象指针没有被置为null，且代码里面没办法再获取到这个对象指针了，就会导致无法释放掉它指向的内存，也就是说发生了内存泄露。</p>
</li>
<li><p>导致内存泄漏的几种常见情况</p>
</li>
</ol>
<ul>
<li>意外形成全局变量<br>解决方法：加上 ‘use strict’ 启用严格模式来避免这类问题, 严格模式会阻止你创建意外的全局变量.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> a=b=<span class="number">0</span>;</span><br><span class="line">   a++;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//undefind</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);  <span class="comment">//number</span></span><br><span class="line"><span class="comment">// let a=b=0; 相当于 b=0; let a=b; b前面没有let,这样的话相当于window.b,那么b即为全局变量 所以输出的时候,a是局部的,只在demo函数内有效,b是全局的</span></span><br></pre></td></tr></table></figure></li>
<li>闭包<br>解决方法：在函数外部定义事件处理函数，解除闭包。或在闭包中，删除没用的属性以减少对内存的消耗。或在外部函数中删除对DOM的引用。</li>
<li>清除页面dom元素时，dom元素绑定的事件未解绑<br>解决办法：手工移除事件。</li>
<li>console<br>解决办法：及时清理console.log。</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ol>
<li>作用域链：上下文中的代码在执行的时候，会创建变量对象的一个作用域链，这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。</li>
<li>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol>
<li>什么是闭包：指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</li>
<li>闭包形成的原理：作用域链。内部函数的作用域链，包含了外部函数的作用域，可以访问外部函数作用域中的变量。</li>
<li>闭包不会造成内存泄漏，程序写错了才会造成内存泄漏。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">getP</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">// 如果不去引用这3个对象，而是直接return&#123;&#125;,就不会产生内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> winP = create(); <span class="comment">//注意只有create的返回值被外部引用，才不会被回收</span></span><br><span class="line">winP()</span><br></pre></td></tr></table></figure></li>
<li>栈不需要垃圾回收，垃圾回收是堆的问题；将函数指向null,解除对函数的引用,这样就可以释放内存了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建比较函数</span></span><br><span class="line"><span class="keyword">let</span> compareNames = createComparisonFunction(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">let</span> result = compareNames(&#123;<span class="attr">name</span>: <span class="string">&#x27;Nicholas&#x27;</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">&#x27;Matt&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 解除对函数的引用,这样就可以释放内存了</span></span><br><span class="line"><span class="keyword">let</span> compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>栈–<br>create执行上下文<br>全局执行上下文<br>–</p>
<ul>
<li>变量p分配内存（Person对象），getP方法指向p（Person对象），winP指向getP()。</li>
<li>当create方法执行结束后create执行上下文就销毁了,也就是变量p和getP方法被销毁了。但由于winP指向getP()，而getP()指向p。因此p没有被垃圾回收，会在堆里形成一个闭包（closure）的变量，把p放进去。</li>
</ul>
<ol start="3">
<li>闭包解决的问题：能够让函数作用域中的变量在函数执行结束之后不被销毁，同时也能在函数外部可以访问函数内部的局部变量；避免命名冲突；</li>
</ol>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol>
<li>如果在全局函数中调用，this在非严格模式下等于window，在严格模式下this等于undefined</li>
<li>如果作为某个对象的方法调用，则this等于这个对象。但匿名函数在这种情况下，this不会绑定某个对象，就意味着this在非严格模式下等于window，在严格模式下this等于undefined.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    <span class="attr">identity</span>:<span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.identity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()); <span class="comment">// &#x27;The Window&#x27;</span></span><br></pre></td></tr></table></figure>
不是说内部函数的作用域链，包含了外部函数的作用域，为什么匿名函数没有使用其包含作用域的this对象呢？<br>因为每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments，内部函数永远不可能直接访问外部函数的这两个变量，<br>但如果把this保存到闭包可以访问的另一个变量中，则是行的通的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.identity = <span class="string">&#x27;The Window&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    <span class="attr">identity</span>: <span class="string">&#x27;My Object&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">getIdentityFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.identity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(object.getIdentityFunc()()); <span class="comment">// &#x27;My Object&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在箭头函数中，this引用的是定义箭头函数的上下文<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> sayColor = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>.color);</span><br><span class="line">sayColor(); <span class="comment">// &#x27;red&#x27; 等于window.sayColor()</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="new操作符具体做了什么"><a href="#new操作符具体做了什么" class="headerlink" title="new操作符具体做了什么"></a>new操作符具体做了什么</h2><ol>
<li>创建一个空对象，并且this变量引用该对象，同时继承了该函数的原型<br>（实例对象通过__proto__属性指向原型对象；obj.<strong>proto</strong> = Base.prototype;） </li>
<li>属性和方法被加入到 this 引用的对象中。</li>
</ol>
<h2 id="V8-栈与堆"><a href="#V8-栈与堆" class="headerlink" title="V8 栈与堆"></a>V8 栈与堆</h2><ul>
<li>基本类型分配到栈里，引用类型分配到堆里</li>
</ul>
<ol>
<li>栈</li>
</ol>
<ul>
<li>栈用于存放js中的基本类型和引用类型指针</li>
<li>栈的空间是连续的，增加删除只需要移动指针，操作速度非常快</li>
<li>栈的空间是有限的，当栈满了，就会抛出一个错误</li>
<li>栈一般是在执行函数时创建的，在函数执行完毕后，栈就会被销毁</li>
</ul>
<ol start="2">
<li>堆</li>
</ol>
<ul>
<li>如果不需要连续空间，或是申请的内存较大，可以使用堆</li>
<li>堆主要用于存储JS中的引用类型</li>
</ul>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>所谓单线程，无非就是同步队列和异步队列，js代码是自上向下执行的，在主线程中立即执行的就是同步任务，比如简单的逻辑操作及函数，而异步任务不会立马执行，会挪步放到到异步队列中，比如ajax、promise、事件、计时器等等。</p>
<p>也就是先执行同步，主线程结束后再按照异步的顺序再次执行。</p>
<ol>
<li>同步：阻塞的<br>浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面</li>
<li>异步：非阻塞的<br>浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新</li>
</ol>
<h2 id="宏任务-（macrotask）和微任务-（microtask）"><a href="#宏任务-（macrotask）和微任务-（microtask）" class="headerlink" title="宏任务 （macrotask）和微任务 （microtask）"></a>宏任务 （macrotask）和微任务 （microtask）</h2><p>异步队列可以分为宏任务队列和微任务队列。<br>在事件循环中，每进行一次循环操作称为tick，tick 的任务处理模型是比较复杂的，里边有两个词：<br>分别是 Macro Task （宏任务）和 Micro Task（微任务）。</p>
<p>宏任务：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)<br>微任务：Promise .then() .catch() .finally()、MutaionObserver、process.nextTick(Node.js 环境)</p>
<ul>
<li>先执行微观任务，再执行宏观任务</li>
</ul>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>先执行主任务，把异步任务放入循环队列当中，等待主任务执行完，再执行队列中的异步任务。异步任务先执行微观任务，再执行宏观任务。一直这样循环，反复执行，就是事件循环机制。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ol>
<li>执行上下文（执行环境）分为，全局环境和函数环境、eval环境</li>
</ol>
<ul>
<li>全局执行上下文：只有一个，浏览器中的全局对象就是window对象，this指向这个全局对象</li>
<li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</li>
<li>Eval 函数执行上下文：指的是运行在eval函数中的代码，很少用而且不建议使用</li>
</ul>
<ol start="2">
<li>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶<blockquote>
<p>创建阶段<br>创建阶段即当函数被调用，但未执行任何其内部代码之前<br>创建阶段做了三件事：</p>
</blockquote>
</li>
</ol>
<ul>
<li>确定 this 的值，也被称为This Binding</li>
<li>LexicalEnvironment（词法环境） 组件被创建</li>
<li>VariableEnvironment（变量环境） 组件被创建<blockquote>
<p>执行阶段<br>在这阶段，执行变量赋值、代码执行<br>如果Javascript引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配undefined值<br>回收阶段<br>执行上下文出栈等待虚拟机回收执行上下文</p>
</blockquote>
</li>
</ul>
<h2 id="经典面试题：（涉及闭包，作用域链，事件循环）"><a href="#经典面试题：（涉及闭包，作用域链，事件循环）" class="headerlink" title="经典面试题：（涉及闭包，作用域链，事件循环）"></a>经典面试题：（涉及闭包，作用域链，事件循环）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i++); <span class="comment">// 序号2</span></span><br><span class="line">    &#125;,<span class="number">4000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//序号1 全局的i 值为5</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>执行栈–</p>
<h2 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h2><p>任务队列–<br>i++,i++,i++,i++,i++<br>–<br>首先在执行任何代码前，先创建执行上下文，然后在全局环境执行for循环，共执行5次。因为js是单线程的，setTimeout不能马上执行，因此出现了任务队列的机制，由浏览器经行处理，得出结果后把结果放入任务队列里，等到执行栈执行结束后，才会根据时间间隔来开始执行任务队列里的结果。<br>因此序号1的i为全局的i，循环后输出值为5。现在全局执行上下文没有需要执行的代码了，就可以执行任务队列里的任务。现在5个i++依次放入执行栈中，当前i的值为5，因此setTimeout里面的匿名函数，序号2会依次输出5，6，7，8，9。相当于闭包的原理，匿名函数可以访问到作用域链上的全局i。注意，这里的4秒指的是执行栈执行完所有任务以后，执行4秒。再执行任务队列里的任务。因此真正执行的时间会超过4秒。</p>
<p>如果希望setTimeout后输出i的值为0，1，2，3，4，那就使用立即执行函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 立即调用的函数表达式</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="comment">// x为形参相当于实参i的值</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(x++); <span class="comment">// 序号2</span></span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 序号1  5</span></span><br></pre></td></tr></table></figure>
<p>先全局执行上下文，再立即执行函数执行上下文，遇到回调函数，把这个函数交给浏览器处理，处理的结果是0，0就放在任务队列里，函数执行栈执行完成以后，</p>
<p><code>立即执行函数执行上下文 = &#123;作用域链:&#123;立即执行函数变量对象+全局对象&#125;,&#123;变量对象:x&#125;&#125;</code><br><code>全局执行上下文 = &#123;作用域链:&#123;全局变量对象&#125;,&#123;变量对象:i&#125;&#125;</code></p>
<p>从全局弹出，回到全局执行上下文</p>
<p><code>全局执行上下文 = &#123;作用域链:&#123;全局变量对象&#125;,&#123;变量对象:i&#125;&#125;</code></p>
<p>进入第二次for循环此时i等于1，于是立即执行函数执行上下文，同时创建作用域链和变量对象，遇到回调函数，把这个函数交给浏览器处理，处理的结果是1，1就放在任务队列里，函数执行栈执行完成以后，从全局弹出，回到全局执行上下文, 以此类推，数值2，3，4依次加入到任务队列里，现在序号1输出5后，全局执行上下文没有要执行的任务了，于是从执行栈中弹出。任务队列再依次输出0，1，2，3，4</p>
<h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><p>说白了，防抖节流就是使用定时器来实现我们的目的。</p>
<ol>
<li>防抖(debounce)：<br>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<br>典型的案例：输入框搜索，输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时；<br>思路：触发事件，清除定时器，重新设置定时器，计时结束后执行任务<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">payMoney</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;已剁&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 难点1：在定义监听函数的时候就直接执行了函数,所以要返回一个函数</span></span><br><span class="line"><span class="comment">// 难点2：使用闭包，把timer声明放在外层函数，使得clearTimeOut和匿名函数都能通过作用域链访问到timer</span></span><br><span class="line"><span class="comment">// 难点3：this的指向被改变</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>; <span class="comment">// 保存this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeOut(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// func.call(context); // call改变this指向          </span></span><br><span class="line">            func.apply(context,<span class="built_in">arguments</span>); <span class="comment">// apply改变this指向,增加参数</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当按钮在这1000毫秒内反复触发，则会一直清除定时器，重新计时，直到计时结束后才提交表单</span></span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>,debounce(payMoney, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure></li>
<li>节流(throttle)：<br>规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。<br>典型的案例：鼠标不断点击触发，规定在n秒内多次点击只生效一次；滚动屏幕请求数据；<br>思路：触发事件，执行任务，并设置时间间隔，如果时间间隔内有触发行为就不执行任务；如果时间间隔后有触发行为，就再次执行任务和设置时间间隔<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">coloring</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> );</span><br><span class="line">    <span class="keyword">let</span> g = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> );</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Math</span>.floor( <span class="built_in">Math</span>.random() * <span class="number">255</span> );</span><br><span class="line">    <span class="built_in">document</span>.body.style.background = <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用定时器</span></span><br><span class="line"><span class="comment">// function throttle(func, delay)&#123;</span></span><br><span class="line"><span class="comment">//     let timer;</span></span><br><span class="line"><span class="comment">//     return function()&#123;</span></span><br><span class="line"><span class="comment">//         let context = this; // 保存this</span></span><br><span class="line"><span class="comment">//         let args = arguments;</span></span><br><span class="line"><span class="comment">//         if(timer) &#123; // 如果timer被赋值了，就不执行任务</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         timer = setTimeout(function()&#123;</span></span><br><span class="line"><span class="comment">//             // func()</span></span><br><span class="line"><span class="comment">//             func.apply(context,arguments);</span></span><br><span class="line"><span class="comment">//             timer = null;</span></span><br><span class="line"><span class="comment">//         &#125;, delay);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 使用Data</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>; <span class="comment">// 保存this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span>(now - pre &gt; delay) &#123;</span><br><span class="line">            func.apply(context,<span class="built_in">arguments</span>);</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, throttle(coloring, <span class="number">2000</span>));</span><br></pre></td></tr></table></figure></li>
<li>为什么要掌握防抖和节流<br>函数节流（throttle）与函数防抖（debounce）都是可以限制函数的执行频次，根据不同的场景来对执行频率进行限制，避免了函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。</li>
</ol>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>函数柯里化是指将使用多个参数的函数转化成一系列使用一个参数的函数的技术, 它返回一个新的函数, 这个新函数去处理剩余的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add1 = add(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">1</span>)); <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = add(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add10); <span class="comment">// 是个函数</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">1</span>)); <span class="comment">// 输出11</span></span><br></pre></td></tr></table></figure>
<p>柯里化通常有以下三大作用</p>
<ol>
<li>参数复用<br>所谓参数复用，就是利用闭包的原理，让我们前面传输过来的参数不要被释放掉。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常封装check函数进行字符串正则匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)        <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)     <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用柯里化函数进行字符串正则匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>提前确认<br>这一特性经常是用来对浏览器的兼容性做出一些判断并初始化api，比如说我们目前用来监听事件大部分情况是使用addEventListener来实现的，但是一些较久的浏览器并不支持该方法，所以在使用之前，我们可以先做一次判断，之后便可以省略这个步骤了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* element：哪个元素需要添加事件监听</span></span><br><span class="line"><span class="comment">* type：元素需要添加什么类型的事件</span></span><br><span class="line"><span class="comment">* listener：执行的回调函数</span></span><br><span class="line"><span class="comment">* useCapture：进行事件冒泡或事件捕获的选择</span></span><br><span class="line"><span class="comment">* handler: 执行函数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">const</span> whichEvent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">element, type, listener, useCapture</span>) </span>&#123;</span><br><span class="line">            element.addEventListener(type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                listener.call(element, e); <span class="comment">// 规避this指向</span></span><br><span class="line">            &#125;, useCapture); <span class="comment">// addEventListener 主流浏览器的监听方法</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">            element.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                handler.call(element, e);</span><br><span class="line">            &#125;); <span class="comment">// attachEvent 是IE的监听方法</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
<li>延迟运行<br>js中的bind这个方法，用到的就是柯里化的这个特征。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
面试题:<br>实现一个add函数的方法<br>add(1)(2)(3) = 6;<br>add(1,2,3)(4) = 10;<br>add(1)(2)(3)(4)(5) = 15;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// let args = arguments; // arguments 在这里是对象，需要转换成数组</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); <span class="comment">// 转换成数组</span></span><br><span class="line">    <span class="comment">// console.log(Object.prototype.toString.call(args));</span></span><br><span class="line">    <span class="keyword">let</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        args.push( ...arguments );</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 隐式转换 实际上返回的依旧是函数，只是隐式转换成了字符串</span></span><br><span class="line">    inner.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev + cur</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>).toString();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）。</p>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。向下传播。</p>
<h2 id="事件委托-事件代理"><a href="#事件委托-事件代理" class="headerlink" title="事件委托/事件代理"></a>事件委托/事件代理</h2><ul>
<li><p>事件委托：又名事件代理，事件委托利用事件冒泡，可以只使用一个事件处理程序，来管理一种类型的事件。</p>
</li>
<li><p>事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件是在冒泡阶段触发，事件委托就是在冒泡阶段完成。</p>
</li>
<li><p>当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。</p>
</li>
<li><p>适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress</p>
</li>
<li><p>优点：<br>减少整个页面所需的内存，提升整体性能<br>动态绑定，减少重复工作</p>
</li>
<li><p>局限性：<br>focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件<br>mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>鸭梨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要点击删除香蕉、苹果、鸭梨</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给每个li元素绑定删除的事件</span></span><br><span class="line"><span class="keyword">let</span> li = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; li.length; i++)&#123;</span><br><span class="line">    li[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        ul.removeChild(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用事件委托，在ul元素上绑定事件</span></span><br><span class="line"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    ul.removeChild(e.target); <span class="comment">// e.target 捕获的是最小的单位 如li</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击li，因为事件冒泡，所以事件可以在父级触发，而把删除li元素的事件委托给父级，就能让父级ul代替子级li执行删除操作。</p>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ol>
<li>AjAX（异步JavaScript加XML） 是在不重新加载整个页面的情况下，与服务器交换数据并更新部分网络页面内容</li>
<li>目的：为了提高用户浏览网站的体验</li>
<li>场景：<ul>
<li>页面上拉加载更多数据</li>
<li>列表数据无刷新分页</li>
<li>表单项离开焦点数据验证</li>
<li>搜索框提示文字下拉列表</li>
</ul>
</li>
<li>实现：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;&#x27;</span>; <span class="comment">// json数据</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">// responseText 以字符串的形式返回结果</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>XMLHttpRequest 对象 :用于在后台与服务器交换数据<br>open(method, url, async) :规定请求的类型、URL以及是否异步处理请求<br>send() :将请求发送到服务器<br>readyState 属性 :保存 XMLHttpRequest 的状态，从0到4发生变化<br>    0: 请求未初始化<br>    1: 服务器连接已建立<br>    2: 请求已接收<br>    3: 请求处理中<br>    4: 请求已完成，且响应已就绪<br>onreadystatechange 事件: 每当readyState属性改变时，就会调用该函数<br>status :<br>    200: “OK”<br>    404: 未找到页面</p>
<ol start="4">
<li>ajax请求应该放在哪个生命周期？<br>mounted，因为js是单线程，ajax异步获取数据</li>
</ol>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><ol>
<li>axios 是一个基于promise的http客户端，同时支持浏览器和nodejs环境</li>
<li>特点：</li>
</ol>
<ul>
<li>它是一个基于promise的异步ajax请求库，支持promise所有的api</li>
<li>node和浏览器环境都可以使用</li>
<li>支持请求或响应拦截器</li>
<li>支持请求取消</li>
<li>可以转换请求数据和响应数据，并对响应回来的内容自动转换成JSON类型的数据</li>
<li>批量发送多个请求</li>
<li>安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从cookie中拿到的key,根据浏览器同源策略，假的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假网站上的误导输入，从而采取正确的策略。</li>
</ul>
<ol start="3">
<li><p>拦截器简介<br>对于大多数SPA应用程序来说，通常会使用token进行用户的身份认证。这就要求在认证通过后，我们需要在每个请求上都携带认证信息。针对这个需求，为了避免为每个请求单独处理，我们可以通过封装统一的request函数来为每个请求统一添加 token 信息。但后期如果需要为某些GET请求设置缓存时间或者控制某些请求的调用频率的话，我们就需要不断修改request函数来扩展对应的功能。此时，如果在考虑对响应进行统一处理的话，我们的request函数将变得越来越庞大，也越来越难维护。</p>
</li>
<li><p>Axios提供了请求拦截器和响应拦截器来分别处理请求和响应<br>通过service.interceptors.request和service.interceptors.response 提供的use方法就可以分别设置请求拦截器和响应拦截器</p>
</li>
</ol>
<ul>
<li>请求拦截器：<br>该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加token字段</li>
<li>响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为401时，自动跳转到登录页</li>
</ul>
<ol start="5">
<li><p>axios是什么，怎么使用，简述使用它完成登录的流程<br>axios是一个基于promise的用于浏览器和nodejs的http客户端<br>主要作用是向后端发送请求<br>优势：<br>支持promise<br>提供了一些并发的方法<br>提供了拦截器<br>浏览器支持防止csrf（跨站请求伪造）</p>
</li>
<li><p>axios fetch ajax (jquery) 区别<br>axios、fetch是基于promise的，ajax主要还是利用callback的形式<br>fetch 脱离了xhr 是新语法（默认不传cookie）<br>axios、ajax 可以监听到请求的进度</p>
</li>
</ol>
<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="设计-模式"><a href="#设计-模式" class="headerlink" title="设计 模式"></a>设计 模式</h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>常用的设计模式：</p>
<ol>
<li>单体模式：单体是一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象，如果他可以被实例化，那么他只能被实例化一次。</li>
<li>工厂模式:提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）</li>
<li>单例模式：单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</li>
<li>观察者模式（发布订阅模式）： 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。</li>
<li>策略模式：策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体</li>
<li>模板模式：定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑</li>
<li>代理模式：代理模式的中文含义就是帮别人做事，javascript的解释为：把对一个对象的访问, 交给另一个代理对象来操作.</li>
<li>外观模式： 外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3></div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/07/31/1.js%E5%90%88%E9%9B%86/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/07/31/1.js%E5%90%88%E9%9B%86/";
            const title         = "「1.js合集」";
            const excerpt       = `js1.怎么判断一个对象是否为空前提：对象属性是可遍历

for-in 遍历，并通过 hasOwnProperty 方法确认是否存在某个 key , 这种方法不能够遍历到 enumerable 为 false 的属性
12345678...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/js/" rel="tag">js</a>
                </div>
                <div class="pull-date">
                    <time datetime="2022-08-27T15:23:53.019Z" itemprop="dateModified">最后编辑：2022-08-27</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 2.vue和react的合集" href="/2022/07/18/2.vue和react的合集/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" 4.css合集" href="/2022/08/14/4.css合集/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">念念不忘，必有回响</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                30
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                15
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                21
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js"><span class="toc-text">js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-text">1.怎么判断一个对象是否为空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4-%E5%8E%BB%E9%87%8D-%E6%8E%92%E5%BA%8F"><span class="toc-text">2.数组降维&#x2F;去重&#x2F;排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4"><span class="toc-text">1. 数组降维</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">2. 数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">3. 数组排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">3.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-js%E4%B8%ADbind-call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4. js中bind,call和apply的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-js%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">5.js判断数据类型的方式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">6.JS数据类型有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-text">7.null和undefined区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%87%B3%E5%B0%91%E8%AF%B4%E5%87%BA8%E4%B8%AA"><span class="toc-text">8.数组的常用方法(至少说出8个)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-text">9.对象的原生方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8JS%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">外部JS文件出现中文字符，会出现什么问题，怎么解决？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#es6"><span class="toc-text">es6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-async-await"><span class="toc-text">1. async await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Promise"><span class="toc-text">2. Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-let-%E5%92%8C-const-%E5%92%8C-var"><span class="toc-text">3. let 和 const 和 var</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%EF%BC%9F"><span class="toc-text">什么是暂时性死区？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ES6-%E4%B8%80%E5%85%B1%E6%9C%89-6-%E7%A7%8D%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">4. ES6 一共有 6 种声明变量的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">5. 箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-proxy"><span class="toc-text">6. proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-map%E5%92%8Cset"><span class="toc-text">7. map和set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-es6%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8Ces5%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">8. es6的继承和es5的继承有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Symbol%EF%BC%8C%E5%86%99%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B9%B6%E8%AF%B4%E5%87%BA%E5%AE%83%E7%9A%84%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">9. Symbol，写一个应用实例，并说出它的其他应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js-1"><span class="toc-text">js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E3%80%81%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">构造函数、原型、实例的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proto-%E5%92%8Cprototype"><span class="toc-text">_proto_和prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-%E2%80%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">内存泄漏 –内存泄漏分析工具的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91"><span class="toc-text">this指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">new操作符具体做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8-%E6%A0%88%E4%B8%8E%E5%A0%86"><span class="toc-text">V8 栈与堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1-%EF%BC%88macrotask%EF%BC%89%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-%EF%BC%88microtask%EF%BC%89"><span class="toc-text">宏任务 （macrotask）和微任务 （microtask）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%EF%BC%88%E6%B6%89%E5%8F%8A%E9%97%AD%E5%8C%85%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="toc-text">经典面试题：（涉及闭包，作用域链，事件循环）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">全局执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81"><span class="toc-text">防抖节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-text">函数柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-text">事件捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-text">事件委托&#x2F;事件代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax"><span class="toc-text">ajax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-text">axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99"><span class="toc-text">正则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="toc-text">计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">线程和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">线程间的通信方式</span></a></li></ol></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/">性能优化与安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%93%E5%8C%85/">打包</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99/">正则</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/">零散知识</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/HTTP/" style="font-size: 0.6em;">HTTP</a> <a href="/tags/Vue/" style="font-size: 0.73em;">Vue</a> <a href="/tags/css/" style="font-size: 0.6em;">css</a> <a href="/tags/egg/" style="font-size: 0.6em;">egg</a> <a href="/tags/flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/" style="font-size: 0.6em;">flex弹性布局</a> <a href="/tags/hexo/" style="font-size: 0.6em;">hexo</a> <a href="/tags/js/" style="font-size: 0.6em;">js</a> <a href="/tags/koa/" style="font-size: 0.6em;">koa</a> <a href="/tags/node/" style="font-size: 0.6em;">node</a> <a href="/tags/npm/" style="font-size: 0.6em;">npm</a> <a href="/tags/react/" style="font-size: 0.6em;">react</a> <a href="/tags/vue/" style="font-size: 0.8em;">vue</a> <a href="/tags/wamp/" style="font-size: 0.6em;">wamp</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.67em;">前端</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 0.6em;">开发工具</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 0.67em;">微信小程序</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/" style="font-size: 0.6em;">性能优化与安全</a> <a href="/tags/%E6%89%93%E5%8C%85/" style="font-size: 0.6em;">打包</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/08/31/8.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><i class="fa  fa-book"></i> 8.开发工具</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/25/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%AE%89%E5%85%A8/"><i class="fa  fa-book"></i> 7.性能优化与安全</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/16/6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"><i class="fa  fa-book"></i> 6.浏览器</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/14/5.%E6%89%93%E5%8C%85/"><i class="fa  fa-book"></i> 5.打包</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/08/14/3.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%88%E9%9B%86/"><i class="fa  fa-book"></i> 3.微信小程序合集</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2023 橘知·部落 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by zengqm.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>